# 0. Routing

- Tree: 계층적 구조를 시각화하기 위한 관례. 예를 들어, 부모와 자식 컴포넌트로 구성된 컴포넌트 트리나 폴더 구조 등이 있음.
- Subtree: 트리의 일부로, 새로운 루트(시작점)에서 시작하여 끝 노드(리프)까지 이어지는 구조.
- Root: 트리나 서브트리에서 첫 번째 노드로, 예를 들어 루트 레이아웃이 여기에 해당.
- Leaf: 자식 노드가 없는 트리 또는 서브트리의 노드를 말하며, 예를 들어 URL 경로의 마지막 세그먼트 등이 이에 해당.
- URL Segment: 슬래시(`/`)로 구분된 URL 경로의 일부.
- URL Path: 도메인 뒤에 오는 URL의 일부로, 여러 세그먼트로 구성.

## App Router

버전 13부터 Next.js는 App Router를 도입하였다.

App Router는 React Server Components 를 기반으로 만들어졌으며, shared layout, nested routing, loading state, error handling 등을 지원한다.

`app` 디렉토리에서 동작하는데, 이는 `pages` 디렉토리와 함께 사용 가능하며, 점진적으로 새로운 기능을 적용할 수 있다.

App Router는 Pages Router보다 우선순위를 가진다. 두 디렉토리가 동일한 URL 경로로 라우트를 설정할 경우, 충돌을 방지하기 위해 빌드 시 오류가 발생한다.

## Roles of Folders and Files

Next.js는 파일 시스템 기반 라우터를 사용하며, 다음과 같이 동작하낟.

- 폴더는 라우트를 정의하는 데 사용된다. 라우트는 루트 폴더에서 시작해 `page.js` 파일이 포함된 최종 리프 폴더까지 파일 시스템 계층을 따라가는 단일 경로이다.
- 파일은 특정 라우트 세그먼트에 대해 표시되는 UI를 생성하는데 사용된다.

## Route Segments

라우트의 각 폴더는 하나의 라우트 세그먼트를 나타낸다. 각 라우트 세그먼트는 URL 경로의 해당 세그먼트에 매핑된다.

## Component Hierarchy

특별한 파일로 정의된 React 컴포넌트는 특정 계층 구조로 렌더링된다.

1. layout
2. template
3. error
4. loading
5. not-found
6. page 또는 중첩된 layout

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/53d079c9-18de-432b-9b86-7622d82eb136/image.png)

## Colocation

특별 파일 외에도, `app` 디렉토리 내 폴더에 사용자 정의 파일 (컴포넌트, 스타일, 테스트 등)을 함께 배치할 수 있다.

이는 폴더가 라우트를 정의하지만, `page.js` 혹은 `route.js` 가 반환하는 내용만 공개적으로 접근 가능하기 때문이다.

# 1. Defining Routes

## Creating Routes

- 폴더: 경로 정의
  - 각 폴더들은 URL 의 각 세그먼트들을 나타낸다.
  - 폴더를 중첩으로 구조화하여, 중첩 경로를 구현할 수 있다.
- `page.tsx` : 퍼블릭하게 저ㅂ근 가능한 경로 세그먼트를 만드는데 사용

## Creating UI

- `page.tsx` : 특정 라우트에 대한 UI 담당
- `layout.tsx` : 여러 경로에 공유되는 UI 담당

# 2. Pages and Layouts

## Pages

page는 기본적으로 서버 컴포넌트이나, 클라이언트 컴포넌트로 설정할 수도 있다.

## Layouts

layout은 여러 경로 간에 공유되는 UI이다.

내비게이션에서 layout은 상태를 유지하고, 상호작용 상태를 유지하며, 다시 렌더링하지 않는다. 레이아웃은 중첩될 수도 있다.

기본적으로 layout.js 파일에서 React component를 내보내는 방식으로 레이아웃을 정의할 수 있다.

이 component는 자식 레이아웃(존재하는 경우)이나 렌더링 중에 페이지가 채워질 자식 prop을 허용해야 gksek.

예를 들어 레이아웃은 /dashboard 및 /dashboard/setting 페이지와 공유된다.

```tsx
export default function DashboardLayout({
  children, // will be a page or nested layout
}: {
  children: React.ReactNode;
}) {
  return (
    <section>
      {/* Include shared UI here e.g. a header or sidebar */}
      <nav></nav>

      {children}
    </section>
  );
}
```

- root layout 만이 유일하게 `<html>` 과 `<body>` 태그를 가질 수 있다.
- 레이아웃은 기본적으로 서버 컴포넌트이나, 클라이언트 컴포넌트로 설정할 수도 있다.
- ⭐️ 부모 레이아웃과 그 자식 사이에 데이터를 넘기는 것은 불가능하다. 하지만, 동일한 데이터를 라우트에서 여러 번 가져오는 것은 가능하다. 이 경우 React는 요청을 자동으로 중복 제거(deduplication)하여 성능에 영향을 주지 않는다.
  - 앱 라우터는 RSC(React Server Components)를 기반으로 동작한다. 이 환경에서는 데이터가 클라이언트와 서버에서 서로 독립적으로 처리되기 때문에, 부모 레이아웃이 데이터를 가져왔더라도 자식 컴포넌트에게 props로 넘겨주는 전통적인 방식이 작동하지 않는다.
  - 자식 컴포넌트에서 부모와 동일한 데이터를 다시 가져와야 한다면, 중복된 API 요청이 발생한 것처럼 보이지만, React는 중복 제거를 통해 최적화한다.
    - 부모 레이아웃이 데이터를 가져왔고,
    - 자식 컴포넌트도 동일한 데이터를 요청하면, React는 이미 같은 요청이 처리되었음을 감지하여 추가 요청을 막는다.
    - 서버&서버, 서버&클라이언트, 클라이언트&클라이언트
      ```jsx
      // 부모 레이아웃 (서버 컴포넌트)
      export default function Layout({ children }) {
        const data = fetchData(); // 데이터를 가져옴
        return (
          <div>
            <h1>Parent Layout</h1>
            {children}
          </div>
        );
      }

      // 자식 컴포넌트 (서버 컴포넌트)
      export default function Page() {
        const data = fetchData(); // 동일한 데이터를 다시 가져옴
        return <div>Child Data: {data}</div>;
      }
      ```
      ```jsx
      // 부모 레이아웃 (서버 컴포넌트)
      export default function Layout({ children }) {
        return (
          <div>
            <h1>Parent Layout</h1>
            {children}
          </div>
        );
      }

      // 자식 컴포넌트 (클라이언트 컴포넌트)
      'use client';

      export default function Page() {
        const data = fetchData(); // 자식에서 데이터를 다시 요청
        return <div>Child Data: {data}</div>;
      }

      ```
      ```jsx
      // 부모 레이아웃 (클라이언트 컴포넌트)
      'use client';

      export default function Layout({ children }) {
        const [data, setData] = useState(null);

        useEffect(() => {
          fetchData().then(setData);
        }, []);

        return (
          <div>
            <h1>Parent Layout</h1>
            {React.cloneElement(children, { data })}
          </div>
        );
      }

      // 자식 컴포넌트 (클라이언트 컴포넌트)
      'use client';

      export default function Page({ data }) {
        return <div>Child Data: {data}</div>;
      }

      ```
- ⭐️ 레이아웃은 자신 아래의 라우트 세그먼트에 접근할 수 없다. 모든 라우트 세그먼트에 접근하려면 클라이언트 컴포넌트에서 `useSelectedLayoutSegment` 또는 `useSelectedLayoutSegements` 를 사용할 수 있다.
  - `useSelectedLayoutSegment`
    - 클라이언트 컴포넌트에서 사용하는 훅
    - 호출된 레이아웃 바로 아래 수준의 활성 경로 세그먼트를 읽을 수 있어, 부모 레이아웃 내부에서 활성 자식 세그먼트에 따라 스타일을 변경하는 탭 네비게이션과 같은 UI를 구현할 때 유용하다.
    - 이 훅은 호출된 레이아웃 바로 아래의 단일 활성 세그먼트만 반환한다. 모든 활성 세그먼트를 반환하려면 `useSelectedLayoutSegments` 를 사용한다.
  - `useSelectedLayoutSegments`
    - 클라이언트 컴포넌트에서 사용하는 훅
    - 호출된 레이아웃 아래의 모든 활성 경로 세그먼트를 배열 형태로 반환한다.
    - 부모 레이아웃에서 자식 세그먼트의정보를 필요로 하는 UI를 생성할 때 유용하다.
- 특정 라우트 세그먼트를 공유 레이아웃에서 포함하거나 제외하려면 Route Groups를 사용할 수 있다.
- 루트 레이아웃은 기존의 `_app.js` 와 `_document.js` 파일을 대체하낟.

## Templates

Templates는 레이아웃과 유사하게 자식 레이아웃이나 페이지를 감싸는 역할을 한다.

하지만 Template은 라우트 간 전환 시 상태를 유지하지 않고 새로운 인스턴스를 생성한다는 점에서 레이아웃과 다르다.

- 레이아웃은 라우트 간 전환 시에도 DOM을 유지하며, 동일한 레이아웃을 계속 사용한다.
- 템플릿은 라우트를 전환할 때마다 새로운 컴포넌트를 마운트하고, DOM 요소를 다시 생성하며, 상태가 초기화되고, useEffect가 재실행된다.

### Templates를 사용하는 경우

1. `useEffect` 나 `useState` 에 의존하는 기능이 필요한 경우
   1. 페이지 뷰 로깅(useEffect), 페이지별 피드백 폼(useState)
2. 기본 프레임워크 동작을 변경하려는 경우
   1. 레이아웃 내부의 Suspense Boundary는 레이아웃이 처음 로드될 때만 폴백을 보여준다. 그러나, 템플릿은 페이지를 전환할때마다 폴백을 보여준다.

### Templates 렌더링 계층

레이아웃과 레이아웃의자식 사이에 렌더링된다.

1. 부모 레이아웃
2. 템플릿
3. 자식 레이아웃 또는 페이지

## Metadata

`app` 디렉토리에서는 Metadata API를 사용하여 HTML의 `<head>` 요소를 수정할 수 있다.

`<head>` 태그를 루트 레이아웃에 수동으로 추가해서는 안 된다.

**Metadata API**를 사용해야 하며, 이 API는 다음과 같은 고급 기능들을 처리한다.

1. 스트리밍(Streaming): 콘텐츠를 점진적으로 로드.
2. 중복 제거(Deduplication): `<head>` 요소가 중복되지 않도록 방지.
