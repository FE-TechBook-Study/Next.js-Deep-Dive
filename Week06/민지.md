# 민지

# 6주차

# **Caching in Next.js**

Next.js는 캐싱을 활용하여 애플리케이션의 성능을 향상시키고 비용을 줄입니다. 이 페이지에서는 Next.js의 캐싱 메커니즘, 이를 구성할 수 있는 API, 그리고 이들이 서로 어떻게 상호작용하는지에 대해 깊이 있게 다룹니다.

[Good to know]

이 페이지는 Next.js가 내부적으로 어떻게 동작하는지 이해하는 데 도움을 주지만, Next.js를 생산적으로 사용하는 데 필수적인 지식은 아닙니다. 대부분의 Next.js 캐싱 방식은 API 사용 방식에 따라 자동으로 결정되며, 최상의 성능을 제공하기 위해 기본적으로 설정되어 있어 별도의 구성이 거의 필요하지 않습니다.

## 개요

다음은 다양한 캐싱 메커니즘과 그 목적에 대한 대략적인 설명입니다:

| **메커니즘**            | **내용**                                     | **위치**   | **목적**                                | **지속 시간**              |
| ----------------------- | -------------------------------------------- | ---------- | --------------------------------------- | -------------------------- |
| **Request Memoization** | 함수의 반환 값                               | 서버       | React 컴포넌트 트리에서 데이터를 재사용 | 요청 수명 주기 동안        |
| **Data Cache**          | 데이터                                       | 서버       | 사용자 요청 및 배포 간 데이터를 저장    | 지속됨 (재검증 가능)       |
| **Full Route Cache**    | HTML 및 RSC(React Server Component) 페이로드 | 서버       | 렌더링 비용 절감 및 성능 향상           | 지속됨 (재검증 가능)       |
| **Router Cache**        | RSC 페이로드                                 | 클라이언트 | 페이지 이동 시 서버 요청 감소           | 사용자 세션 또는 시간 기반 |

기본적으로 Next.js는 성능을 향상시키고 비용을 절감하기 위해 가능한 한 많은 데이터를 캐싱합니다. 즉, 경로(Route)는 기본적으로 정적으로 렌더링되며, 데이터 요청 또한 캐싱됩니다. 이러한 동작을 변경하려면 명시적으로 설정을 변경해야 합니다.

아래 다이어그램은 기본 캐싱 동작을 보여줍니다. 즉, **빌드 시(static generation) 정적으로 렌더링된 경로**와 **정적 경로가 처음 방문될 때의 동작**을 설명합니다.

경로가 정적으로 렌더링되는지 동적으로 렌더링되는지, 데이터가 캐싱되는지 아닌지, 그리고 요청이 초기 방문의 일부인지 이후 탐색의 일부인지에 따라 캐싱 동작이 변경됩니다. 사용 사례에 따라 개별 경로와 데이터 요청의 캐싱 동작을 구성할 수 있습니다.

## 1. Request Memoization

React는 `fetch` API를 확장하여 **같은 URL과 옵션을 가진 요청을 자동으로 메모이제이션**합니다. 즉, React 컴포넌트 트리 내에서 동일한 데이터를 가져오는 `fetch` 함수를 여러 번 호출하더라도 한 번만 실행됩니다.

![image.png](6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20197dea0778cb80a3876fde52d6de95cd/image.png)

예를 들어, 하나의 경로(Route)에서 동일한 데이터를 여러 곳에서 사용해야 하는 경우(예: `Layout`, `Page`, 여러 컴포넌트), 트리 최상단에서 데이터를 가져와 하위 컴포넌트로 props를 전달할 필요가 없습니다. 대신 필요한 컴포넌트에서 직접 데이터를 가져오면 되며, 동일한 데이터에 대해 여러 번 네트워크 요청이 발생하는 성능 문제를 걱정할 필요 없습니다.

## 동작 방식

![image.png](6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20197dea0778cb80a3876fde52d6de95cd/image%201.png)

- 경로를 렌더링하는 동안, 특정 요청이 처음 호출될 때 해당 결과는 메모리에 존재하지 않으므로 **캐시 미스(cache MISS)** 가 발생합니다.
- 따라서 함수가 실행되며, 외부 소스에서 데이터를 가져오고 그 결과가 메모리에 저장됩니다.
- 같은 렌더링 패스 내에서 동일한 요청이 다시 호출되면 **캐시 히트(cache HIT)** 가 발생하여, 함수가 다시 실행되지 않고 메모리에 저장된 데이터가 반환됩니다.
- 경로 렌더링이 완료되고 렌더링 패스가 끝나면 메모리가 "초기화"되며, 모든 요청 메모이제이션 항목이 삭제됩니다.

[Good to know]

- Request Memoization은 Next.js가 아닌 React의 기능입니다.
- Memoization은 GET 메서드가 사용된 `fetch` 요청에만 적용됩니다.
- Memoization은 React 컴포넌트 트리에서만 적용됩니다.
  - `generateMetadata`, `generateStaticParams`, `Layouts`, `Pages` 및 기타 **서버 컴포넌트**에서의 `fetch` 요청에는 적용됩니다.
  - **Route Handlers에서는 적용되지 않습니다**, 왜냐하면 Route Handlers는 React 컴포넌트 트리의 일부가 아니기 때문입니다.
- `fetch`를 사용할 수 없는 경우(예: 일부 데이터베이스 클라이언트, CMS 클라이언트 또는 GraphQL 클라이언트), React의 `cache` 함수를 사용하여 함수를 메모이제이션할 수 있습니다.

### **Duration - 지속 시간**

캐시는 **서버 요청의 수명 동안 유지**되며, React 컴포넌트 트리의 렌더링이 완료될 때까지 지속됩니다.

### **Revalidating - 재검증**

메모이제이션은 **서버 요청 간에 공유되지 않으며, 렌더링 중에만 적용**되므로 별도의 재검증이 필요하지 않습니다.

### **Opting out**

- 메모이제이션은 `fetch` 요청 중 **GET 메서드에만 적용**됩니다.
- `POST`, `DELETE` 등 다른 메서드는 메모이제이션되지 않습니다.
- 이 동작은 **React의 최적화 기능**이며, 이를 비활성화하는 것은 권장되지 않습니다.

**개별 요청을 관리하는 방법**

- `AbortController`의 `signal` 속성을 사용하여 개별 요청을 제어할 수 있습니다.
- 하지만, 이는 **요청을 메모이제이션에서 제외하는 것이 아니라, 진행 중인 요청을 중단(Abort)하는 기능**입니다.

## **2. Data Cache**

Next.js에는 **내장된 데이터 캐시(Data Cache)** 가 있으며, 이를 통해 **서버로 들어오는 요청 및 배포(deployments) 간에도 데이터 요청 결과를 유지**할 수 있습니다.

이것이 가능한 이유는, Next.js가 **기본 `fetch` API를 확장하여 각 서버 요청이 자체적으로 지속적인 캐싱 정책을 설정할 수 있도록 지원**하기 때문입니다.

### [Good to know]

- **브라우저에서의 `fetch` 캐시 동작**:
  - `fetch`의 `cache` 옵션은 **브라우저의 HTTP 캐시와의 상호작용 방식**을 결정합니다.
- **Next.js에서의 `fetch` 캐시 동작**:
  - `fetch`의 `cache` 옵션은 **서버 측 요청이 Next.js의 데이터 캐시와 어떻게 상호작용할지를 결정**합니다.

### **기본 동작**

기본적으로 **`fetch`를 사용하는 데이터 요청은 캐싱됩니다**. `fetch`의 `cache` 및 `next.revalidate` 옵션을 사용하여 캐싱 동작을 구성할 수 있습니다.

### **동작 방식**

![image.png](6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20197dea0778cb80a3876fde52d6de95cd/image%202.png)

렌더링 중에 `fetch` 요청이 처음 호출되면, Next.js는 데이터 캐시에서 캐시된 응답을 확인합니다.

- **캐시된 응답이 발견되면**: 즉시 반환되며, 메모이제이션됩니다.
- **캐시된 응답이 발견되지 않으면**: 데이터 소스로 요청을 보내고, 그 결과는 데이터 캐시에 저장된 후 메모이제이션됩니다.
- **캐시되지 않은 데이터**(예: `{ cache: 'no-store' }`)의 경우: 항상 데이터 소스에서 직접 가져오며, 그 결과는 메모이제이션됩니다.

캐시된 데이터든 캐시되지 않은 데이터든, 요청은 항상 메모이제이션되어 **같은 데이터에 대한 중복 요청을 방지**합니다.

**[데이터 캐시와 요청 메모이제이션의 차이점]**

두 캐싱 메커니즘은 모두 캐시된 데이터를 재사용하여 성능을 향상시키는 데 도움이 되지만, **데이터 캐시는 들어오는 요청과 배포 간에 지속적**인 반면, **메모이제이션은 요청의 수명 동안만 지속**됩니다.

- **메모이제이션**에서는 **같은 렌더링 패스 내에서 중복 요청을 줄여** 렌더링 서버에서 데이터 캐시 서버(CDN 또는 엣지 네트워크)나 데이터 소스(데이터베이스, CMS 등)로 네트워크 경계를 넘는 요청을 줄입니다.
- **데이터 캐시**에서는 **원본 데이터 소스에 대한 요청 횟수를 줄여** 데이터 소스로의 요청을 최소화합니다.

### **지속 시간 (Duration)**

데이터 캐시는 **들어오는 요청과 배포 간에 지속적**이며, **재검증**을 하거나 **옵트아웃**하지 않는 한 계속 유지됩니다.

### **재검증 (Revalidating)**

캐시된 데이터는 두 가지 방법으로 재검증할 수 있습니다:

1. **시간 기반 재검증(Time-based Revalidation)**
   - 특정 시간이 지난 후에 새로운 요청이 들어올 때 데이터를 다시 검증하는 방식입니다.
   - 이는 자주 변경되지 않는 데이터를 다룰 때 유용한 방법입니다.
   - 데이터의 실시간성이 매우 중요하지 않은 경우에 적합합니다.
2. **온디맨드 재검증(On-demand Revalidation)**:
   - 이벤트(예: 폼 제출)를 기반으로 데이터를 재검증합니다.
   - 요청 기반 재검증은 한 번에 데이터 그룹을 재검증하기 위해 태그 기반 또는 경로 기반 접근 방식을 사용할 수 있습니다.
   - 최신 데이터를 가능한 한 빨리 표시하고 싶을 때 유용합니다(예: headless CMS의 콘텐츠가 업데이트될 때).

### **시간 기반 재검증 (Time-based Revalidation)**

데이터를 특정 시간 간격으로 재검증하려면, `fetch`의 `next.revalidate` 옵션을 사용하여 자원의 **캐시 수명(초 단위)** 을 설정할 수 있습니다.

```jsx
// Revalidate at most every hour
fetch("https://...", { next: { revalidate: 3600 } });
```

또는 **Route Segment Config** 옵션을 사용하여 세그먼트 내의 모든 `fetch` 요청을 구성하거나, `fetch`를 사용할 수 없는 경우에도 적용할 수 있습니다.

### **동작 방식**

![image.png](6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20197dea0778cb80a3876fde52d6de95cd/image%203.png)

- `revalidate`가 있는 fetch 요청이 처음 호출될 때, 데이터는 외부 데이터 소스에서 가져와서 데이터 캐시에 저장됩니다.
- 지정된 시간 프레임(예: 60초) 내에 호출되는 모든 요청은 캐시된 데이터를 반환합니다.
- 시간 프레임이 지난 후에는, 다음 요청도 여전히 캐시된(이제는 오래된) 데이터를 반환합니다.
  - Next.js는 백그라운드에서 데이터 재검증을 시작합니다.
  - 데이터를 성공적으로 가져오면, Next.js는 데이터 캐시를 새로운 데이터로 업데이트합니다.
  - 백그라운드 재검증이 실패하면, 이전 데이터는 변경되지 않은 채로 유지됩니다.

이는 **stale-while-revalidate** 동작과 유사합니다.

### **요청 기반 재검증 (Demand-based Revalidation)**

데이터는 경로(`revalidatePath`)나 캐시 태그(`revalidateTag`)를 통해 요청 시 재검증될 수 있습니다.

![image.png](6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20197dea0778cb80a3876fde52d6de95cd/image%204.png)

### **동작 방식**

- `fetch` 요청이 처음 호출될 때, 데이터는 외부 데이터 소스에서 가져와서 데이터 캐시에 저장됩니다.
- 요청 기반 재검증이 트리거되면, 해당하는 캐시 항목들이 캐시에서 제거됩니다.
  - 이는 새로운 데이터를 가져올 때까지 오래된 데이터를 캐시에 유지하는 시간 기반 재검증과는 다릅니다.
- 다음 요청이 이루어질 때, 다시 캐시 `MISS`가 되어 데이터를 외부 데이터 소스에서 가져와 데이터 캐시에 저장합니다.

### Opting out

개별 데이터 fetch의 경우, `cache` 옵션을 `no-store`로 설정하여 캐싱을 비활성화할 수 있습니다. 이는 `fetch`가 호출될 때마다 데이터를 가져온다는 의미입니다.

```
// Opt out of caching for an individual `fetch` request
fetch(`https://...`, { cache: 'no-store' })
```

또는 Route Segment Config 옵션을 사용하여 특정 라우트 세그먼트에 대한 캐싱을 비활성화할 수도 있습니다. 이는 서드파티 라이브러리를 포함하여 해당 라우트 세그먼트의 모든 데이터 요청에 영향을 미칩니다.

```
// Opt out of caching for all data requests in the route segment
export const dynamic = 'force-dynamic'
```

**참고**: 데이터 캐시는 현재 미들웨어가 아닌 페이지/라우트에서만 사용 가능합니다. 미들웨어 내에서 수행되는 모든 fetch는 기본적으로 캐시되지 않습니다.

---

## 3. Full Route Cache

Next.js는 빌드 시 자동으로 경로를 렌더링하고 캐시합니다. 이는 모든 요청에 ​​대해 서버에서 렌더링하는 대신 캐시된 경로를 제공할 수 있는 최적화로, 결과적으로 페이지 로드가 더 빨라집니다.

Full Route Cache가 어떻게 작동하는지 이해하려면 React가 렌더링을 처리하는 방식과 Next.js가 결과를 캐시하는 방식을 살펴보는 것이 좋습니다.

**1. 서버에서의 React 렌더링**

서버에서 Next.js는 렌더링을 조정하기 위해 React의 API들을 사용합니다. 렌더링 작업은 개별 라우트 세그먼트와 Suspense 경계에 따라 청크로 나뉩니다.

각 청크는 두 단계로 렌더링됩니다.

1. React는 서버 컴포넌트를 스트리밍에 최적화된 특별한 데이터 형식인 **React 서버 컴포넌트 페이로드**로 렌더링합니다.
2. Next.js는 React 서버 컴포넌트 페이로드와 클라이언트 컴포넌트 JavaScript 명령을 사용하여 서버에서 **HTML**을 렌더링합니다.

이는 작업을 캐싱하거나 응답을 보내기 전에 모든 것이 렌더링될 때까지 기다릴 필요가 없다는 것을 의미합니다. 대신, 작업이 완료되는 대로 응답을 스트리밍할 수 있습니다.

**React 서버 컴포넌트 페이로드란 무엇인가?**

React 서버 컴포넌트 페이로드는 렌더링된 React 서버 컴포넌트 트리의 압축된 이진 표현입니다. 이는 클라이언트에서 React가 브라우저의 DOM을 업데이트하는 데 사용됩니다. React 서버 컴포넌트 페이로드는 다음을 포함합니다.

- 서버 컴포넌트의 렌더링 결과
- 클라이언트 컴포넌트가 렌더링되어야 할 위치와 JavaScript 파일에 대한 참조를 위한 플레이스홀더
- 서버 컴포넌트에서 클라이언트 컴포넌트로 전달된 모든 props

**2. 서버에서의 Next.js 캐싱 (전체 라우트 캐시)**
Next.js의 기본 동작은 서버에서 라우트의 렌더링 결과(React 서버 컴포넌트 페이로드와 HTML)를 캐싱하는 것입니다. 이는 빌드 시점이나 재검증 중에 정적으로 렌더링되는 라우트에 적용됩니다.

**3. 클라이언트에서의 React 하이드레이션과 재조정**
요청 시점에, 클라이언트에서

1. HTML은 클라이언트와 서버 컴포넌트의 상호작용이 불가능한 초기 미리보기를 즉시 보여주는 데 사용됩니다.
2. React 서버 컴포넌트 페이로드는 클라이언트와 렌더링된 서버 컴포넌트 트리를 재조정하고 DOM을 업데이트하는 데 사용됩니다.
3. JavaScript 명령은 클라이언트 컴포넌트를 하이드레이션하고 애플리케이션을 상호작용 가능하게 만드는 데 사용됩니다.

**4. 클라이언트에서의 Next.js 캐싱 (라우터 캐시)**
React 서버 컴포넌트 페이로드는 개별 라우트 세그먼트로 나뉜 별도의 메모리 내 캐시인 클라이언트 측 라우터 캐시에 저장됩니다. 이 라우터 캐시는 이전에 방문한 라우트를 저장하고 향후 라우트를 미리 가져옴으로써 네비게이션 경험을 개선하는 데 사용됩니다.

**5. 후속 내비게이션**
후속 내비게이션이나 프리페칭 중에, Next.js는 React 서버 컴포넌트 페이로드가 라우터 캐시에 저장되어 있는지 확인합니다. 만약 있다면, 서버에 새로운 요청을 보내는 것을 건너뜁니다.

만약 라우트 세그먼트가 캐시에 없다면, Next.js는 서버에서 React 서버 컴포넌트 페이로드를 가져와서 클라이언트의 라우터 캐시를 채웁니다.

**정적 및 동적 렌더링**
라우트가 빌드 시점에 캐시되는지 여부는 해당 라우트가 정적으로 렌더링되는지 동적으로 렌더링되는지에 달려있습니다. 정적 라우트는 기본적으로 캐시되는 반면, 동적 라우트는 요청 시점에 렌더링되며 캐시되지 않습니다.

이 다이어그램은 캐시된 데이터와 캐시되지 않은 데이터를 가진 정적 및 동적으로 렌더링된 라우트의 차이를 보여줍니다.

![image.png](6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20197dea0778cb80a3876fde52d6de95cd/image%205.png)

**지속 기간**
기본적으로 전체 라우트 캐시는 영구적입니다. 이는 렌더링 출력이 사용자 요청 간에 캐시된다는 것을 의미합니다.

**무효화**
전체 라우트 캐시를 무효화하는 두 가지 방법이 있습니다:

- **데이터 재검증**: 데이터 캐시를 재검증하면, 서버에서 컴포넌트를 다시 렌더링하고 새로운 렌더링 출력을 캐싱함으로써 라우터 캐시가 무효화됩니다.
- **재배포**: 배포 간에도 유지되는 데이터 캐시와 달리, 전체 라우트 캐시는 새로운 배포 시 지워집니다.

**비활성화**
다음과 같은 방법으로 전체 라우트 캐시를 비활성화하거나, 다시 말해 들어오는 모든 요청에 대해 컴포넌트를 동적으로 렌더링할 수 있습니다:

- **동적 함수 사용**: 이는 라우트를 전체 라우트 캐시에서 제외하고 요청 시점에 동적으로 렌더링합니다. 데이터 캐시는 계속 사용될 수 있습니다.
- **`dynamic = 'force-dynamic'` 또는 `revalidate = 0` 라우트 세그먼트 설정 옵션 사용**: 이는 전체 라우트 캐시와 데이터 캐시를 건너뜁니다. 즉, 서버로 들어오는 모든 요청에 대해 컴포넌트가 렌더링되고 데이터가 가져와집니다. 라우터 캐시는 클라이언트 측 캐시이므로 계속 적용됩니다.
- **데이터 캐시 비활성화**: 라우트에 캐시되지 않은 `fetch` 요청이 있는 경우, 이는 라우트를 전체 라우트 캐시에서 제외합니다. 특정 `fetch` 요청에 대한 데이터는 들어오는 모든 요청에 대해 가져옵니다. 캐싱을 비활성화하지 않는 다른 `fetch` 요청은 여전히 데이터 캐시에 캐시됩니다. 이를 통해 캐시된 데이터와 캐시되지 않은 데이터의 하이브리드가 가능합니다.

---

## 4. Router Cache

Next.js는 사용자 세션 동안 개별 라우트 세그먼트로 나뉜 React 서버 컴포넌트 페이로드를 저장하는 메모리 내 클라이언트 측 캐시를 가지고 있습니다. 이를 라우터 캐시라고 합니다.

![image.png](6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20197dea0778cb80a3876fde52d6de95cd/image%206.png)

사용자가 라우트 간 이동할 때, Next.js는 방문한 라우트 세그먼트를 캐시하고 사용자가 이동할 가능성이 있는 라우트들을(뷰포트 내의 `<Link>` 컴포넌트를 기반으로) 미리 가져옵니다.

이는 사용자에게 향상된 내비게이션 경험을 제공합니다.

- 방문했던 라우트들이 캐시되어 있어 즉각적인 뒤로/앞으로 이동이 가능하며, 프리페칭과 부분 렌더링 덕분에 새로운 라우트로의 빠른 이동이 가능합니다.
- 내비게이션 간에 전체 페이지 새로고침이 없으며, React 상태와 브라우저 상태가 보존됩니다.

**라우터 캐시와 전체 라우트 캐시의 차이**
라우터 캐시는 사용자 세션 동안 React 서버 컴포넌트 페이로드를 브라우저에 임시로 저장하는 반면, 전체 라우트 캐시는 여러 사용자 요청에 걸쳐 React 서버 컴포넌트 페이로드와 HTML을 서버에 영구적으로 저장합니다.

전체 라우트 캐시는 정적으로 렌더링된 라우트만 캐시하는 반면, 라우터 캐시는 정적으로 렌더링된 라우트와 동적으로 렌더링된 라우트 모두에 적용됩니다.

### Duration

캐시는 브라우저의 임시 메모리에 저장됩니다. 라우터 캐시가 지속되는 기간은 두 가지 요소에 의해 결정됩니다:

- **세션**: 캐시는 페이지 내비게이션 동안 유지됩니다. 하지만 페이지를 새로고침하면 지워집니다.
- **자동 무효화 기간**: 레이아웃과 로딩 상태의 캐시는 특정 시간이 지나면 자동으로 무효화됩니다. 지속 시간은 리소스가 어떻게 프리페치되었는지, 그리고 리소스가 정적으로 생성되었는지에 따라 달라집니다:
  - **기본 프리페치** (`prefetch={null}` 또는 미지정):
    - 동적 페이지의 경우: 캐시되지 않음
    - 정적 페이지의 경우: 5분 동안 캐시
  - **전체 프리페치** (`prefetch={true}` 또는 `router.prefetch`):
    - 정적/동적 페이지 모두: 5분 동안 캐시

페이지 새로고침은 **모든** 캐시된 세그먼트를 지우지만, 자동 무효화 기간은 프리페치된 시점부터 개별 세그먼트에만 영향을 미칩니다.

### **Invalidation**

라우터 캐시를 무효화하는 두 가지 방법이 있습니다:

- **서버 액션**
  - (`revalidatePath`)를 사용한 경로별 요청 기반 데이터 재검증 또는 (`revalidateTag`)를 사용한 캐시 태그별 재검증
  - `cookies.set` 또는 `cookies.delete` 사용 시 라우터 캐시가 무효화됩니다. 이는 쿠키를 사용하는 라우트가 오래된 상태가 되는 것을 방지합니다 (예: 인증 관련)
- `router.refresh`를 호출하면 라우터 캐시가 무효화되고 현재 라우트에 대해 서버에 새로운 요청을 보냅니다.

### **Opting out**

라우터 캐시는 비활성화할 수 없습니다. 하지만 `router.refresh`, `revalidatePath`, 또는 `revalidateTag`를 호출하여 무효화할 수 있습니다(위 내용 참조). 이렇게 하면 캐시가 지워지고 서버에 새로운 요청을 보내어 최신 데이터가 표시되도록 합니다.

또한 `<Link>` 컴포넌트의 `prefetch` 속성을 `false`로 설정하여 **프리페칭**을 비활성화할 수 있습니다. 하지만 이렇게 해도 탭 바나 뒤로/앞으로 이동과 같은 중첩된 세그먼트 간의 즉각적인 내비게이션을 위해 라우트 세그먼트가 30초 동안 임시로 저장됩니다. 방문했던 라우트들은 계속 캐시됩니다.

---

## 5. **Cache Interactions**

다양한 캐싱 메커니즘을 구성할 때, 이들이 서로 어떻게 상호작용하는지 이해하는 것이 중요합니다:

**데이터 캐시와 전체 라우트 캐시**

- 데이터 캐시를 재검증하거나 비활성화하면 렌더링 출력이 데이터에 의존하기 때문에 전체 라우트 캐시가 무효화됩니다.
- 전체 라우트 캐시를 무효화하거나 비활성화해도 데이터 캐시에는 영향을 미치지 않습니다. 캐시된 데이터와 캐시되지 않은 데이터를 모두 가진 라우트를 동적으로 렌더링할 수 있습니다. 이는 페이지의 대부분이 캐시된 데이터를 사용하지만, 요청 시점에 가져와야 하는 데이터에 의존하는 몇 개의 컴포넌트가 있을 때 유용합니다. 모든 데이터를 다시 가져오는 성능 영향을 걱정하지 않고 동적으로 렌더링할 수 있습니다.

**데이터 캐시와 클라이언트 측 라우터 캐시**

- 라우트 핸들러에서 데이터 캐시를 재검증해도 라우트 핸들러가 특정 라우트에 연결되어 있지 않기 때문에 라우터 캐시가 즉시 무효화되지 않습니다. 이는 강제 새로고침을 하거나 자동 무효화 기간이 만료될 때까지 라우터 캐시가 이전 페이로드를 계속 제공한다는 것을 의미합니다.
- 데이터 캐시와 라우터 캐시를 즉시 무효화하려면 서버 액션에서 `revalidatePath` 또는 `revalidateTag`를 사용할 수 있습니다.

---

## 6. APIs

다음 표는 다양한 Next.js API들이 캐싱에 어떤 영향을 미치는지에 대한 개요를 제공합니다:

### `<Link>`

기본적으로, `<Link>` 컴포넌트는 전체 라우트 캐시에서 자동으로 라우트를 프리페치하고 React 서버 컴포넌트 페이로드를 라우터 캐시에 추가합니다.

프리페칭을 비활성화하려면 `prefetch` 속성을 `false`로 설정할 수 있습니다. 하지만 이는 캐시를 영구적으로 건너뛰지는 않으며, 사용자가 라우트를 방문할 때 라우트 세그먼트는 여전히 클라이언트 측에서 캐시됩니다.

### `router.prefetch`

`router.prefetchuseRouter` 훅의 `prefetch` 옵션을 사용하여 수동으로 라우트를 프리페치할 수 있습니다. 이는 React 서버 컴포넌트 페이로드를 라우터 캐시에 추가합니다.

### `router.refresh`

`router.refreshuseRouter` 훅의 `refresh` 옵션을 사용하여 수동으로 라우트를 새로고침할 수 있습니다. 이는 라우터 캐시를 완전히 지우고, 현재 라우트에 대해 서버에 새로운 요청을 보냅니다. `refresh`는 데이터 캐시나 전체 라우트 캐시에는 영향을 미치지 않습니다.

렌더링된 결과는 React 상태와 브라우저 상태를 유지하면서 클라이언트에서 재조정됩니다.

### `fetch`

`fetch`에서 반환된 데이터는 자동으로 데이터 캐시에 저장됩니다.

```jsx
// 기본적으로 캐시됩니다. 'force-cache'는 기본 옵션이며 생략할 수 있습니다.
fetch(`https://...`, { cache: "force-cache" });
```

### `fetch options.cache`

`cache` 옵션을 `no-store`로 설정하여 개별 `fetch` 요청의 데이터 캐싱을 비활성화할 수 있습니다:

```jsx
// 캐싱 비활성화
fetch(`https://...`, { cache: "no-store" });
```

렌더링 출력이 데이터에 의존하기 때문에, `cache: 'no-store'`를 사용하면 `fetch` 요청이 사용되는 라우트의 전체 라우트 캐시도 건너뜁니다. 즉, 라우트는 매 요청마다 동적으로 렌더링되지만, 같은 라우트 내에서 다른 캐시된 데이터 요청을 여전히 가질 수 있습니다.

### `fetch-options.next.revalidate`

`fetch`의 `next.revalidate` 옵션을 사용하여 개별 `fetch` 요청의 재검증 기간(초 단위)을 설정할 수 있습니다. 이는 데이터 캐시를 재검증하며, 이어서 전체 라우트 캐시도 재검증합니다. 새로운 데이터를 가져오고, 컴포넌트들이 서버에서 다시 렌더링됩니다.

```jsx
// 최대 1시간 후에 재검증
fetch(`https://...`, { next: { revalidate: 3600 } });
```

### `fetch options.next.tags` and `revalidateTag`

Next.js는 세밀한 데이터 캐싱과 재검증을 위한 캐시 태그 시스템을 가지고 있습니다.

1. `fetch` 또는 `unstable_cache` 사용 시, 하나 이상의 태그로 캐시 항목을 태그할 수 있습니다.
2. 그런 다음 `revalidateTag`를 호출하여 해당 태그와 연관된 캐시 항목들을 제거할 수 있습니다.

예를 들어, 데이터를 가져올 때 태그를 설정할 수 있습니다:

```jsx
// 데이터를 태그와 함께 캐시
fetch(`https://...`, { next: { tags: ["a", "b", "c"] } });
```

그리고 나서, 특정 태그를 사용하여 `revalidateTag`를 호출하여 캐시 항목을 제거할 수 있습니다.

```jsx
// 특정 태그를 가진 항목들을 재검증
revalidateTag("a");
```

목적에 따라 `revalidateTag`를 사용할 수 있는 두 가지 방법이 있습니다.

1. Router Handlers - 써드파티 이벤트(예: 웹훅)에 응답하여 데이터를 재검증할 때. 라우트 핸들러가 특정 라우트에 연결되어 있지 않기 때문에 라우터 캐시를 즉시 무효화하지 않습니다.
1. Server actions - 사용자 액션(예: 폼 제출) 후에 데이터를 재검증할 때. 이는 연관된 라우트의 라우터 캐시를 무효화합니다.

### `revalidatepath`

`revalidatePath`는 단일 작업으로 데이터를 수동으로 재검증하고 특정 경로 아래의 라우트 세그먼트를 다시 렌더링할 수 있게 해줍니다. `revalidatePath` 메서드를 호출하면 데이터 캐시를 재검증하고, 이어서 전체 라우트 캐시를 무효화합니다.

```jsx
revalidatePath("/");
```

목적에 따라 `revalidatePath`를 사용할 수 있는 두 가지 방법이 있습니다.

1. 라우트 핸들러 - 제3자 이벤트(예: 웹훅)에 대응하여 데이터를 재검증할 때
2. 서버 액션 - 사용자 상호작용(예: 폼 제출, 버튼 클릭) 후에 데이터를 재검증할 때

**`revalidatePath`** vs. **`router.refresh`**

`router.refresh`를 호출하면 라우터 캐시를 지우고, 데이터 캐시나 전체 라우트 캐시를 무효화하지 않은 채로 서버에서 라우트 세그먼트를 다시 렌더링합니다.

차이점은 `revalidatePath`는 데이터 캐시와 전체 라우트 캐시를 제거하는 반면, `router.refresh()`는 클라이언트 측 API이기 때문에 데이터 캐시와 전체 라우트 캐시를 변경하지 않는다는 점입니다.

### Dynamic Functions

`cookies`와 `headers` 같은 동적 함수들과 페이지의 `searchParams` prop은 런타임 시점의 들어오는 요청 정보에 의존합니다. 이들을 사용하면 라우트가 전체 라우트 캐시에서 제외됩니다. 다시 말해, 라우트가 동적으로 렌더링될 것입니다.

`cookies`
서버 액션에서 `cookies.set` 또는 `cookies.delete`를 사용하면 쿠키를 사용하는 라우트가 오래된 상태가 되는 것을 방지하기 위해(예: 인증 변경 사항을 반영) 라우터 캐시가 무효화됩니다.

### **Segment Config Options**

라우트 세그먼트 설정 옵션은 라우트 세그먼트의 기본값을 재정의하거나 `fetch` API를 사용할 수 없을 때(예: 데이터베이스 클라이언트나 제3자 라이브러리) 사용할 수 있습니다.

다음의 라우트 세그먼트 설정 옵션들은 데이터 캐시와 전체 라우트 캐시를 비활성화합니다:

- `const dynamic = 'force-dynamic'`
- `const revalidate = 0`

### `generateStaticParams`

동적 세그먼트(예: `app/blog/[slug]/page.js`)의 경우, `generateStaticParams`가 제공하는 경로들은 빌드 시점에 전체 라우트 캐시에 캐시됩니다. 요청 시점에, Next.js는 빌드 시점에 알려지지 않았던 경로들도 처음 방문될 때 캐시합니다.

라우트 세그먼트에서 `export const dynamicParams = false` 옵션을 사용하여 요청 시점의 캐싱을 비활성화할 수 있습니다. 이 설정 옵션을 사용하면 `generateStaticParams`가 제공한 경로만 서비스되며, 다른 라우트들은 404가 되거나 (catch-all 라우트의 경우) 매칭됩니다.

### React `cache` function

React `cache` 함수를 사용하면 함수의 반환 값을 메모이제이션할 수 있어, 같은 함수를 여러 번 호출하더라도 한 번만 실행되도록 할 수 있습니다.

`fetch` 요청은 자동으로 메모이제이션되기 때문에 React `cache`로 감쌀 필요가 없습니다. 하지만 `fetch` API가 적합하지 않은 사용 사례에서는 `cache`를 사용하여 데이터 요청을 수동으로 메모이제이션할 수 있습니다. 예를 들어, 일부 데이터베이스 클라이언트, CMS 클라이언트 또는 GraphQL 클라이언트가 이에 해당합니다.

```jsx
import { cache } from "react";
import db from "@/lib/db";

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id });
  return item;
});
```

---

# **Styling**

Next.js는 애플리케이션의 스타일링을 위한 다양한 방법을 지원합니다:

- **전역 CSS**: 전통적인 CSS에 익숙한 사람들에게는 사용하기 쉽고 친숙하지만, CSS 번들이 커질 수 있고 애플리케이션이 커질수록 스타일 관리가 어려워질 수 있습니다.
- **CSS 모듈**: 이름 충돌을 피하고 유지보수성을 향상시키기 위해 로컬로 범위가 지정된 CSS 클래스를 생성합니다.
- **Tailwind CSS**: 유틸리티 클래스를 조합하여 빠른 맞춤 디자인을 가능하게 하는 유틸리티 우선 CSS 프레임워크입니다.
- **Sass**: 변수, 중첩 규칙, 믹스인과 같은 기능으로 CSS를 확장하는 인기 있는 CSS 전처리기입니다.
- **CSS-in-JS**: CSS를 JavaScript 컴포넌트에 직접 포함시켜 동적이고 범위가 지정된 스타일링을 가능하게 합니다.

## 1. **CSS Modules and Global Styles**

Next.js는 다음을 포함한 다양한 유형의 스타일시트를 지원합니다:

- CSS 모듈
- 전역 스타일
- 외부 스타일시트

### **CSS 모듈**

Next.js는 `.module.css` 확장자를 사용하여 CSS 모듈을 기본적으로 지원합니다. CSS 모듈은 자동으로 고유한 클래스 이름을 생성하여 CSS를 로컬로 범위화합니다. 이를 통해 다른 파일에서 같은 클래스 이름을 사용해도 충돌을 걱정할 필요가 없습니다. 이러한 특성으로 인해 CSS 모듈은 컴포넌트 레벨의 CSS를 포함시키는 이상적인 방법입니다.

**(예시)** CSS 모듈은 app디렉토리 내의 모든 파일에서 import 할 수 있습니다.

```jsx
import styles from "./styles.module.css";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode,
}) {
  return <section className={styles.dashboard}>{children}</section>;
}
```

```jsx
.dashboard {
  padding: 24px;
}
```

CSS 모듈은 `.module.css`와 `.module.sass` 확장자를 가진 파일에서만 활성화됩니다.

프로덕션 환경에서는 모든 CSS 모듈 파일들이 자동으로 **여러 개의 축소되고 코드 분할된** `.css` 파일들로 연결됩니다. 이러한 `.css` 파일들은 애플리케이션의 핫 실행 경로를 나타내며, 애플리케이션 렌더링에 필요한 최소한의 CSS만 로드되도록 보장합니다.

### **Global Styles**

전역 스타일은 `app` 디렉토리 내의 모든 레이아웃, 페이지, 또는 컴포넌트에서 import 할 수 있습니다.

[Good to know]

- `app router` 방식:
  - 전역 스타일을 어느 컴포넌트나 페이지에서든 임포트 가능
  - 더 유연한 스타일 적용 가능
- `pages router` 디렉토리 방식:
  - 전역 스타일은 오직 `_app.js` 파일에서만 임포트 가능
  - 더 제한적인 스타일 적용 방식

### **External Stylesheets**

외부 패키지에서 게시된 스타일시트는 `app` 디렉토리 내 어디에서나 import할 수 있으며, 이는 컴포넌트와 함께 위치한 파일들도 포함합니다.

```jsx
import "bootstrap/dist/css/bootstrap.css";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode,
}) {
  return (
    <html lang="en">
      <body className="container">{children}</body>
    </html>
  );
}
```

### **Ordering and Merging**

Next.js는 프로덕션 빌드 중에 스타일시트를 자동으로 병합하여 CSS를 최적화합니다. CSS 순서는 애플리케이션 코드에서 스타일시트를 임포트하는 순서에 따라 결정됩니다.

예를 들어, `<BaseButton>`이 `<Page>`에서 먼저 임포트되기 때문에 `base-button.module.css`가 `page.module.css` 이전에 순서가 정해집니다:

```jsx
import styles from "./base-button.module.css";

export function BaseButton() {
  return <button className={styles.primary} />;
}
```

```jsx
import { BaseButton } from "./base-button";
import styles from "./page.module.css";

export function Page() {
  return <BaseButton className={styles.primary} />;
}
```

예측 가능한 순서를 유지하기 위해 다음을 권장합니다.

- CSS 파일은 단일 JS/TS 파일에서만 임포트하세요.
  - 전역 클래스 이름을 사용하는 경우, 적용하고자 하는 순서대로 같은 파일에서 전역 스타일을 임포트하세요.
- 전역 스타일보다 CSS 모듈을 선호하세요.
  - CSS 모듈에 일관된 이름 규칙을 사용하세요. 예를 들어, `<name>.tsx` 대신 `<name>.module.css`를 사용하세요.
- 공유 스타일은 별도의 공유 컴포넌트로 추출하세요.
- Tailwind를 사용하는 경우, 파일 상단에서 스타일시트를 임포트하세요. 가급적 루트 레이아웃에서 임포트하는 것이 좋습니다.

[Good to know]

CSS 순서는 개발 모드에서 다르게 동작하므로, 프로덕션 빌드에서의 최종 CSS 순서를 확인하기 위해 항상 프리뷰 배포를 확인하세요.

**개발 모드(Development Mode):**

- 실시간 개발 환경에서는 CSS가 파일별로 개별적으로 로드됩니다
- Hot Module Replacement(HMR)을 지원하기 위해 CSS 순서가 동적으로 변할 수 있습니다
- 개발 중에는 성능보다 개발 편의성에 초점을 맞추기 때문입니다

**프로덕션 빌드(Production Build):**

- CSS 파일들이 최적화를 위해 자동으로 병합(청크화)됩니다
- 임포트 순서에 따라 최종 CSS 순서가 결정됩니다
- 성능 최적화를 위해 CSS가 압축되고 최적화됩니다

### 추가 기능

Next.js는 스타일 추가 작업의 개발 경험을 향상시키기 위한 추가 기능들을 포함합니다:

- `next dev`로 로컬에서 실행할 때, 로컬 스타일시트(전역 또는 CSS 모듈 모두)는 Fast Refresh를 활용하여 수정사항이 저장되면 즉시 반영됩니다.
- `next build`로 프로덕션 빌드할 때, CSS 파일들은 스타일을 가져오는 데 필요한 네트워크 요청 수를 줄이기 위해 더 적은 수의 축소된 `.css` 파일들로 번들링됩니다.
- JavaScript를 비활성화해도 프로덕션 빌드(`next start`)에서는 스타일이 계속 로드됩니다. 하지만 Fast Refresh를 사용하기 위해서는 `next dev` 에서 JavaScript가 여전히 필요합니다.

---

## 3. **CSS-in-JS**

**warning :** 런타임 JavaScript가 필요한 CSS-in-JS 라이브러리들은 현재 서버 컴포넌트에서 지원되지 않습니다. 서버 컴포넌트나 스트리밍과 같은 최신 React 기능들과 함께 CSS-in-JS를 사용하려면 동시 렌더링을 포함한 최신 버전의 React를 라이브러리가 지원해야 합니다.
