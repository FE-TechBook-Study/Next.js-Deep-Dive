# defaults.js

default.js 파일은 Parallel Routes에서 전체 페이지가 새로 고쳐졌을 때, Next.js가 슬롯의 활성 상태를 복구할 수 없는 경우, 대체(fallback)를 렌더링하는 데 사용된다.

소프트 네비게이션(클라이언트 사이드 탐색) 중에는 Next.js가 각 슬롯의 활성 상태(서브페이지)를 추적한다.

하지만, 하드 네비게이션(전체 페이지 새로고침)의 경우, Next.js는 그 활성 상태를 복구할 수 없다.

이 경우, 현재 URL과 일치하지 않는 서브페이지에 대해서는 default.js 파일이 렌더링될 수 있다.

![image.png](attachment:5cb9a637-d710-41d9-b879-96f83a3c59be:image.png)

위와 같은 폴더 구조를 고려해보자.

`@team` 슬롯에는 settings 페이지가 있지만, `@analytics` 에는 존재하지 않는다.

`/settings`로 이동할 경우, `@team` 슬롯은 settings 페이지를 렌더링하고, 동시에 `@analytics` 슬롯은 현재 활성 상태의 페이지를 유지한다.

페이지가 새로고침되면, Next.js는 `@analytics` 를 위한 `default.js` 를 렌더링한다. 만약 `default.js` 가 없다면, 대신 404 페이지가 표시된다.

추가적으로, `children` 은 암시적 슬롯이기 때문에, 부모 페이지의 활성 상태를 Next.js가 복구하지 못할 경우에 대비하여 `children` 를 위한 `default.js` 파일을 만들어 대체 콘텐츠를 렌더링하도록 해야 한다.

### 1. **소프트 네비게이션**일 때 (`Link` 컴포넌트 클릭 등)

- `/settings`로 이동하면:
  - `@team` → `settings/page.js` 렌더링됨
  - `@analytics` → **기존에 열려있던 페이지 그대로 유지됨**
    👉 Next.js는 내부 상태로 각 슬롯의 “현재 페이지”를 기억하고 있기 때문.

---

### 2. **하드 네비게이션**일 때 (ex: 브라우저 새로고침, URL 직접 입력)

- `/settings`로 새로고침하면:
  - `@team` → 당연히 `settings/page.js` 렌더링됨
  - `@analytics` → Next.js는 “어떤 페이지를 보여줘야 할지 모름”
    👉 기존 활성 페이지 상태를 잃어버렸기 때문.

### 이때 필요한 것이 default.js

→ `@analytics/default.js`

> "어떤 서브페이지가 활성 상태였는지 모르겠으니까, 기본적으로 보여줄 fallback 페이지를 노출한다."

## props

### params (optional)

이 값은 루트 세그먼트부터 슬롯의 서브페이지까지의 동적 라우트 파라미터를 포함하는 객체이다.

| Example                                    | URL          | params                              |
| ------------------------------------------ | ------------ | ----------------------------------- |
| `app/@sidebar/[artist]/default.js`         | `/zack`      | `{ artist: 'zack' }`                |
| `app/@sidebar/[artist]/[album]/default.js` | `/zack/next` | `{ artist: 'zack', album: 'next' }` |

# defaults.js

default.js 파일은 Parallel Routes에서 전체 페이지가 새로 고쳐졌을 때, Next.js가 슬롯의 활성 상태를 복구할 수 없는 경우, 대체(fallback)를 렌더링하는 데 사용된다.

소프트 네비게이션(클라이언트 사이드 탐색) 중에는 Next.js가 각 슬롯의 활성 상태(서브페이지)를 추적한다.

하지만, 하드 네비게이션(전체 페이지 새로고침)의 경우, Next.js는 그 활성 상태를 복구할 수 없다.

이 경우, 현재 URL과 일치하지 않는 서브페이지에 대해서는 default.js 파일이 렌더링될 수 있다.

![image.png](attachment:5cb9a637-d710-41d9-b879-96f83a3c59be:image.png)

위와 같은 폴더 구조를 고려해보자.

`@team` 슬롯에는 settings 페이지가 있지만, `@analytics` 에는 존재하지 않는다.

`/settings`로 이동할 경우, `@team` 슬롯은 settings 페이지를 렌더링하고, 동시에 `@analytics` 슬롯은 현재 활성 상태의 페이지를 유지한다.

페이지가 새로고침되면, Next.js는 `@analytics` 를 위한 `default.js` 를 렌더링한다. 만약 `default.js` 가 없다면, 대신 404 페이지가 표시된다.

추가적으로, `children` 은 암시적 슬롯이기 때문에, 부모 페이지의 활성 상태를 Next.js가 복구하지 못할 경우에 대비하여 `children` 를 위한 `default.js` 파일을 만들어 대체 콘텐츠를 렌더링하도록 해야 한다.

### 1. **소프트 네비게이션**일 때 (`Link` 컴포넌트 클릭 등)

- `/settings`로 이동하면:
  - `@team` → `settings/page.js` 렌더링됨
  - `@analytics` → **기존에 열려있던 페이지 그대로 유지됨**
    👉 Next.js는 내부 상태로 각 슬롯의 “현재 페이지”를 기억하고 있기 때문.

---

### 2. **하드 네비게이션**일 때 (ex: 브라우저 새로고침, URL 직접 입력)

- `/settings`로 새로고침하면:
  - `@team` → 당연히 `settings/page.js` 렌더링됨
  - `@analytics` → Next.js는 “어떤 페이지를 보여줘야 할지 모름”
    👉 기존 활성 페이지 상태를 잃어버렸기 때문.

### 이때 필요한 것이 default.js

→ `@analytics/default.js`

> "어떤 서브페이지가 활성 상태였는지 모르겠으니까, 기본적으로 보여줄 fallback 페이지를 노출한다."

## props

### params (optional)

이 값은 루트 세그먼트부터 슬롯의 서브페이지까지의 동적 라우트 파라미터를 포함하는 객체이다.

| Example                                    | URL          | params                              |
| ------------------------------------------ | ------------ | ----------------------------------- |
| `app/@sidebar/[artist]/default.js`         | `/zack`      | `{ artist: 'zack' }`                |
| `app/@sidebar/[artist]/[album]/default.js` | `/zack/next` | `{ artist: 'zack', album: 'next' }` |

# Error.js

`error.js` 파일은 특정 라우트 세그먼트에 대한 오류 UI Boundary를 정의한다.

이는 서버 컴포넌트나 클라이언트 컴포넌트에서 발생하는 예기치 못한 오류를 포착하고, 대체 UI를 표시하는 데 유용하다.

## 예시

### **app/dashboard/error.tsx**

```tsx
"use client"; // Error components must be Client Components
```

에러 컴포넌트는 반드시 클라이언트 컴포넌트여야 한다.

```tsx
export default function Error({
error,
reset,
}: {
error: Error & { digest?: string }
reset: () => void
}) {
```

→ Error라는 컴포넌트를 export.
error: Error 타입 객체이며, 선택적으로 digest 속성을 가질 수 있음

digest: 서버 컴포넌트에서 발생한 오류의 해시 값이며, 서버 로그에서 동일한 오류를 식별하는 데 활용할 수 있다.
reset: 오류 상태를 초기화하는 함수

```tsx
useEffect(() => {
  // Log the error to an error reporting service
  console.error(error);
}, [error]);
```

→ 컴포넌트가 마운트되거나 error가 변경될 때마다 콘솔에 error를 출력한다. (실제로는 오류 추적 서비스로 전송할 수도 있음)

## 알아두면 좋은 점

- `error.js`는 반드시 클라이언트 컴포넌트여야 한다.
- 프로덕션 빌드에서는 서버 컴포넌트에서 발생한 오류의 구체적인 정보가 제거된다. (민감 정보 보호 목적)
- 같은 세그먼트 안에 있는 `layout.js`에서 발생한 오류는 해당 세그먼트의 `error.js`가 처리하지 못한다.
  → 왜냐하면 `error.js`는 `layout.js` 내부에 중첩되어 있기 때문.
- 특정 레이아웃에서 발생하는 오류를 처리하고 싶다면, 해당 레이아웃의 **부모 세그먼트**에 `error.js` 파일을 배치해야 한다.
- 루트 `layout.js`나 `template`에서 발생하는 오류를 처리하려면, **`app/global-error.js`** 라는 변형 파일을 사용해야 한다.

## global-error.js

이 컴포넌트는 루트 오류 처리 전용이며, `<html>` 과 `<body>` 를 반드시 직접 정의해야 한다.

오류 메시지를 표시하고, 버튼 클릭 시 오류 복구를 시도한다.

## not-found.js

`not-found.js` 파일은 특정 라우트 세그먼트 안에서 `notFound()` 함수가 호출되었을 때 표시할 UI를 정의하는 데 사용된다.

# instrumentation.js

모니터링 및 로깅 도구를 애플리케이션에 통합하는 데 사용된다.

이 파일을 통해 애플리케이션의 성능과 동작을 추적하고, 프로덕션 환경에서의 문제를 디버깅할 수 있다.

현재 실험적 기능이므로, 사용하려면 다음과 같이 명시적으로 활성화해야한다.

```tsx
module.exports = {
  experimental: {
    instrumentationHook: true,
  },
};
```

# Layout.js

여러 라우트에서 공유되는 UI이다.

즉, 페이지 간에 공통으로 유지되어야 하는 구조를 레이아웃으로 분리해서 재사용할 수 있다.

## 루트 레이아웃(Root Layout)

루트 레이아웃은 **앱 디렉토리(app 디렉토리)의 최상단에 위치한 레이아웃**으로, 전체 애플리케이션에서 사용될 **`<html>`과 `<body>` 태그, 그리고 전역적으로 공유되는 UI**를 정의한다.

```tsx
// app/layout.tsx
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

### children (필수)

- 레이아웃 컴포넌트는 반드시 `children`이라는 prop을 받아야 하며, 이 안에는 **이 레이아웃이 감싸는 라우트 세그먼트의 콘텐츠**가 포함된다.
- 이 children은 주로 하위의 페이지 컴포넌트나 또 다른 레이아웃 컴포넌트일 수 있으며, 경우에 따라 Loading 컴포넌트나 Error 컴포넌트일 수도 있다.

### params (선택)

- 라우트 경로에서 동적으로 추출된 파라미터 객체를 의미한다.
- 예를 들어, 아래 URL에 대한 layout 파일을 보면:

| 레이아웃 경로                     | URL            | params                    |
| --------------------------------- | -------------- | ------------------------- |
| `app/dashboard/[team]/layout.js`  | `/dashboard/1` | `{ team: '1' }`           |
| `app/shop/[tag]/[item]/layout.js` | `/shop/1/2`    | `{ tag: '1', item: '2' }` |
| `app/blog/[...slug]/layout.js`    | `/blog/1/2`    | `{ slug: ['1', '2'] }`    |

```tsx
// app/shop/[tag]/[item]/layout.tsx
export default function ShopLayout({
  children,
  params,
}: {
  children: React.ReactNode;
  params: {
    tag: string;
    item: string;
  };
}) {
  // 예: /shop/shoes/nike-air-max-97
  // params: { tag: 'shoes', item: 'nike-air-max-97' }
  return <section>{children}</section>;
}
```

→ 위 예제에서는 URL 경로에서 추출된 tag와 item 값을 params를 통해 사용할 수 있다.

## 알아두면 좋은 점 (Good to know)

### 레이아웃은 searchParams를 받지 않는다

- 일반 페이지 컴포넌트와는 달리, 레이아웃 컴포넌트는 `searchParams` prop을 받지 않는다.
- 이유는, **레이아웃은 탐색 중에 다시 렌더링되지 않기 때문**인데,
  이로 인해 탐색 시점에 URL의 쿼리 파라미터(`?q=...`)가 바뀌어도 레이아웃이 그걸 반영하지 못해 **stale한 값**을 가질 수 있기 때문이다.

### 클라이언트 사이드 네비게이션 시 렌더링 최적화

- 클라이언트 측 탐색을 할 때, Next.js는 **공통 레이아웃보다 하위의 페이지 컴포넌트만 다시 렌더링**한다.
- 예를 들어 `/dashboard/settings`에서 `/dashboard/analytics`로 이동하면:
  - `/dashboard/layout.tsx`: 두 경로 모두에서 공통으로 사용되므로 리**렌더링되지 않음**
  - `/dashboard/analytics/page.tsx`: 서버에서 **새롭게 렌더링됨**

→ 이 방식 덕분에 **데이터 패칭과 렌더링 비용이 최소화되고, 탐색 성능이 향상**된다.

---

### 그렇기 때문에 레이아웃에서는 searchParams를 믿으면 안 됨

- 레이아웃은 다시 렌더링되지 않기 때문에, 쿼리 파라미터가 변경되어도 레이아웃 내에서는 반영되지 않는다.
- 이럴 땐, 페이지 컴포넌트의 `searchParams` prop을 사용하거나, 클라이언트 컴포넌트에서 `useSearchParams()` 훅을 사용하는 것이 안전하다.

## 여러 개의 루트 레이아웃을 사용하는 경우 (Route Groups)

- **Route Group**을 활용하면 여러 개의 루트 레이아웃을 만들 수 있다.
- 예:
  - `/cart` → `app/(shop)/layout.js` 사용
  - `/blog` → `app/(marketing)/layout.js` 사용
- 이처럼 다른 루트 레이아웃을 사용하는 경로로 이동하는 경우, **전체 페이지가 새로 로드된다**.
  (이때는 클라이언트 측 탐색이 아니라 브라우저의 하드 리프레시처럼 작동함)

# loading.js

Suspense 기반의 즉각적인 로딩 상태(UI)를 생성하기 위한 파일이다.

이 파일은 기본적으로 서버 컴포넌트로 작동한다.

하지만 `use client` 지시어를 사용하면 클라이언트 컴포넌트로도 사용할 수 있다.

loading.js 컴포넌트는 어떤 파라미터도 받지 않는다.

params, searchParams 등도 사용 불가능하다.

로딩 UI를 디자인할 때는 **React Developer Tools**를 활용하여**`Suspense` 경계를 수동으로 토글해보는 것이 도움이 될 수 있다.**

→ 이는 특정 구간이 로딩 상태일 때 어떻게 보일지 직접 테스트하거나 디버깅할 때 유용하다.
