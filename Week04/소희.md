# 데이터 가져오기, 캐싱, 및 재검증 (Fetching, Caching, Revalidating)

## 데이터를 가져오는 네 가지 방법

1. 서버에서 fetch를 사용하여 가져오기
2. 서버에서 서드파티 라이브러리를 사용하여 가져오기
3. 클라이언트에서 Route Handler를 통해 가져오기
4. 클라이언트에서 서드파티 라이브러리를 사용하여 가져오기

# 1. Fetching Data on the Server with fetch

Next.js는 기본 fetch Web API를 확장하여 각 요청의 캐싱 및 재검증 동작을 구성할 수 있도록 지원한다.

또한, React는 fetch를 확장하여 React component 트리를 렌더링하는 동안 요청을 자동으로 메모이제이션(재사용)한다.

서버 컴포넌트, 라우트 핸들러, 서버 액션에서 fetch와 async/await를 사용할 수 있다.

```tsx
// app/page.tsx

async function getData() {
  const res = await fetch("https://api.example.com/...");

  // 반환값은 직렬화되지 않음
  // Date, Map, Set 등을 그대로 반환할 수 있음

  if (!res.ok) {
    // 가장 가까운 `error.js` 에러 바운더리를 활성화함
    throw new Error("Failed to fetch data");
  }

  return res.json();
}

export default async function Page() {
  const data = await getData();

  return <main></main>;
}
```

# 2. Caching Data

캐싱은 데이터를 저장하여 매 요청마다 원본 데이터 소스에서 다시 가져오는 부담을 줄이는 기능이다.

## Next.js의 기본 캐싱 동작

- 기본적으로, 서버의 Data Cache에 fetch 응답을 자동으로 캐싱한다.
- 즉, 빌드 타임 또는 요청 타임에 데이터를 가져와 캐싱하고, 이후 요청에서도 캐싱된 데이터를 재사용할 수 있다.

```tsx
// 기본적으로 `force-cache` 설정이 적용됨
fetch("https://...", { cache: "force-cache" });
```

### 캐싱되지 않는 경우 (예외)

- 서버 액션 내부에서 사용된 경우
- POST 메서드를 사용하는 라우트 핸들러 내부에서 사용된 경우

### 데이터 캐시 (Data Cache) 란?

- 데이터 캐시는 영구적인 HTTP 캐시이다.
- 사용자의 플랫폼에 따라 자동으로 확장되며, 여러 지역에서 공유될 수 있다.
  - Vercel을 사용하는 경우, 글로벌 캐싱 네트워크에서 데이터가 공유될 수 있음

# 3. Data Revalidating

재검증은 캐시된 데이터를 삭제하고 최신 데이터를 다시 가져오는 과정이다.

데이터가 변경될 때 최신 정보를 표시하기 위해 필요하다.

재검증 방법에는 두 가지 방법이 있다.

1. 시간 기반 재검증
   - 일정 시간이 지나면 자동으로 데이터를 다시 가져오는 방식
   - 변경이 자주 발생하지 않는 데이터에 적합
2. 온디맨드 재검증
   - 특정 이벤트(예: 폼 제출) 발생 시 수동으로 데이터 갱신
   - 콘텐츠가 변경되자마자 최신 상태를 반영해야 하는 경우에 적합

## 시간 기반 재검증

fetch 요청시 next.revalidate 옵션을 설정하면 해당 시간(초) 이후 데이터를 다시 가져오도록 설정할 수 있다.

```tsx
fetch("https://...", { next: { revalidate: 3600 } }); // 1시간마다 재검증
```

혹은 페이지 전체에 대해 설정할 수 도 있다.

```tsx
// app/layout.ts | app/page.ts

export const revalidate = 3600; // 1시간마다 재검증
```

- 정적으로 렌더링된 경로에서 여러 개의 fetch 요청을 할 경우, 가장 짧은 재검증 시간이 전체 요청에 적용된다.
- 동적으로 렌더링된 경로에서는 각 fetch 요청이 개별적으로 재검증된다.

## 온디맨드 재검증

- 특정 데이터 변겅 시, 해당 데이터만 다시 가져오도록 할 수 있다.
- `revalidateTag` 또는 `revalidatePath` 를 사용하여 특정 데이터를 재검증할 수 있다.

```tsx
// app/page.tsx

export default async function Page() {
  const res = await fetch("https://...", { next: { tags: ["collection"] } });
  const data = await res.json();
  // ...
}
```

collection 태그를 가진 데이터를 이제 서버 액션에서 수동으로 재검증할 수 있다.

```tsx
// app/actions.ts

"use server";

import { revalidateTag } from "next/cache";

export default async function action() {
  revalidateTag("collection");
}
```

- revalidateTag는 하나의 태그를 가진 모든 fetch 요청을 한 번에 재검증할 수 있다.
- Headless CMS에서 데이터를 업데이트한 후, 변경 사항을 즉시 반영할 때 매우 유용하다.

# 4. Opting out of Caching (캐싱 비활성화)

특정 요청에서 캐싱을 사용하지 않으려면 다음 옵션을 설정하면 된다.

```tsx
fetch("https://...", { cache: "no-store" });
```

또는 다음 경우에도 자동으로 캐싱이 비활성화된다.

1. `fetch` 요청에 `cache: 'no-store'` 옵션이 추가된 경우.
2. 개별 `fetch` 요청에 `revalidate: 0` 옵션이 설정된 경우.
3. `POST` 메서드를 사용하는 **Router Handler(라우트 핸들러)** 내부에서 `fetch` 요청이 실행된 경우.
4. `headers` 또는 `cookies`를 사용한 후 `fetch` 요청이 실행된 경우.
5. 해당 경로 세그먼트(route segment)에서 `const dynamic = 'force-dynamic'` 옵션이 설정된 경우.
6. `fetchCache` 경로 세그먼트 옵션이 기본적으로 캐싱을 건너뛰도록 구성된 경우.
7. `Authorization` 또는 `Cookie` 헤더를 사용하는 `fetch` 요청이 있고, **그 위에(상위 컴포넌트에서) 캐싱되지 않은 요청이 존재하는 경우**.

## 개별 fetch 요청에서 캐싱 비활성화

개별 fetch 요청에서 캐싱을 비활성화하려면 `cache: 'no-store'` 로 설정하면 된다.

이렇게 하면 매 요청마다 새로운 데이터를 가져오게 되고, 이전 요청 결과가 캐시에 저장되지 않는다.

```tsx
fetch("https://...", { cache: "no-store" });
```

## 여러 개의 fetch 요청을 처리할 때

layout이나 page에서 여러 개의 fetch 요청이 있을 경우, Segment Config Options을 사용하여 전체 세그먼트의 캐싱 동작을 설정할 수 있다.

그러나, Next.js에서는 각 fetch 요청별로 개별적인 캐싱 옵션을 설정하는 것을 권장한다.

더 정밀한 캐싱 제어가 가능하기 때문이다.

# 5. Fetching Data on the Server with third-party libraries

fetch 가 아닌 다른 방법으로 데이터를 가져오는 경우, 캐싱 설정 방법이다.

데이터베이스, CMS, ORM 클라이언트 등 fetch를 직접 사용하지 않는 서드파티 라이브러리를 사용할 경우, Route Segment Config Option과 React cach 함수를 활용하여 캐싱 및 재검증 동작을 설정할 수 있다.

정적 경로의 경우 fetch 응답이 캐싱되나, 동적 경로는 매 요청마다 새롭게 데이터를 가져온다.

unstable_cache API를 사용할 수도 있다.

```tsx
import { cache } from "react";

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id });
  return item;
});
// 동일한 id로 여러 번 함수가 호출되어도, 하나의 데이터베이스 쿼리만 실행
```

```tsx
// app/item/[id]/layout.tsx
import { getItem } from "@/utils/get-item";

export const revalidate = 3600; // 1시간마다 캐시 재검증

export default async function Layout({
  params: { id },
}: {
  params: { id: string };
}) {
  const item = await getItem(id);
  return <div>{item.name}</div>;
}
```

# 6. Fetching Data on the Client with Route Handlers

클라이언트 컴포넌트에서 데이터를 가져올 때 Route handler를 사용할 수 도 있다.

라우트 핸들러는 서버에서 실행되며, 클라이언트가 요청을 보내 데이터를 가져올 수 있도록 한다.

✔ 클라이언트에서 서버 데이터를 안전하게 가져올 수 있음

✔ API 토큰 같은 민감한 정보를 직접 클라이언트에 노출하지 않음
