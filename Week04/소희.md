# 데이터 가져오기, 캐싱, 및 재검증 (Fetching, Caching, Revalidating)

## 데이터를 가져오는 네 가지 방법

1. 서버에서 fetch를 사용하여 가져오기
2. 서버에서 서드파티 라이브러리를 사용하여 가져오기
3. 클라이언트에서 Route Handler를 통해 가져오기
4. 클라이언트에서 서드파티 라이브러리를 사용하여 가져오기

# 1. Fetching Data on the Server with fetch

Next.js는 기본 fetch Web API를 확장하여 각 요청의 캐싱 및 재검증 동작을 구성할 수 있도록 지원한다.

또한, React는 fetch를 확장하여 React component 트리를 렌더링하는 동안 요청을 자동으로 메모이제이션(재사용)한다.

서버 컴포넌트, 라우트 핸들러, 서버 액션에서 fetch와 async/await를 사용할 수 있다.

```tsx
// app/page.tsx

async function getData() {
  const res = await fetch("https://api.example.com/...");

  // 반환값은 직렬화되지 않음
  // Date, Map, Set 등을 그대로 반환할 수 있음

  if (!res.ok) {
    // 가장 가까운 `error.js` 에러 바운더리를 활성화함
    throw new Error("Failed to fetch data");
  }

  return res.json();
}

export default async function Page() {
  const data = await getData();

  return <main></main>;
}
```

# 2. Caching Data

캐싱은 데이터를 저장하여 매 요청마다 원본 데이터 소스에서 다시 가져오는 부담을 줄이는 기능이다.

## Next.js의 기본 캐싱 동작

- 기본적으로, 서버의 Data Cache에 fetch 응답을 자동으로 캐싱한다.
- 즉, 빌드 타임 또는 요청 타임에 데이터를 가져와 캐싱하고, 이후 요청에서도 캐싱된 데이터를 재사용할 수 있다.

```tsx
// 기본적으로 `force-cache` 설정이 적용됨
fetch("https://...", { cache: "force-cache" });
```

### 캐싱되지 않는 경우 (예외)

- 서버 액션 내부에서 사용된 경우
- POST 메서드를 사용하는 라우트 핸들러 내부에서 사용된 경우

### 데이터 캐시 (Data Cache) 란?

- 데이터 캐시는 영구적인 HTTP 캐시이다.
- 사용자의 플랫폼에 따라 자동으로 확장되며, 여러 지역에서 공유될 수 있다.
  - Vercel을 사용하는 경우, 글로벌 캐싱 네트워크에서 데이터가 공유될 수 있음

# 3. Data Revalidating

재검증은 캐시된 데이터를 삭제하고 최신 데이터를 다시 가져오는 과정이다.

데이터가 변경될 때 최신 정보를 표시하기 위해 필요하다.

재검증 방법에는 두 가지 방법이 있다.

1. 시간 기반 재검증
   - 일정 시간이 지나면 자동으로 데이터를 다시 가져오는 방식
   - 변경이 자주 발생하지 않는 데이터에 적합
2. 온디맨드 재검증
   - 특정 이벤트(예: 폼 제출) 발생 시 수동으로 데이터 갱신
   - 콘텐츠가 변경되자마자 최신 상태를 반영해야 하는 경우에 적합

## 시간 기반 재검증

fetch 요청시 next.revalidate 옵션을 설정하면 해당 시간(초) 이후 데이터를 다시 가져오도록 설정할 수 있다.

```tsx
fetch("https://...", { next: { revalidate: 3600 } }); // 1시간마다 재검증
```

혹은 페이지 전체에 대해 설정할 수 도 있다.

```tsx
// app/layout.ts | app/page.ts

export const revalidate = 3600; // 1시간마다 재검증
```

- 정적으로 렌더링된 경로에서 여러 개의 fetch 요청을 할 경우, 가장 짧은 재검증 시간이 전체 요청에 적용된다.
- 동적으로 렌더링된 경로에서는 각 fetch 요청이 개별적으로 재검증된다.

## 온디맨드 재검증

- 특정 데이터 변겅 시, 해당 데이터만 다시 가져오도록 할 수 있다.
- `revalidateTag` 또는 `revalidatePath` 를 사용하여 특정 데이터를 재검증할 수 있다.

```tsx
// app/page.tsx

export default async function Page() {
  const res = await fetch("https://...", { next: { tags: ["collection"] } });
  const data = await res.json();
  // ...
}
```

collection 태그를 가진 데이터를 이제 서버 액션에서 수동으로 재검증할 수 있다.

```tsx
// app/actions.ts

"use server";

import { revalidateTag } from "next/cache";

export default async function action() {
  revalidateTag("collection");
}
```

- revalidateTag는 하나의 태그를 가진 모든 fetch 요청을 한 번에 재검증할 수 있다.
- Headless CMS에서 데이터를 업데이트한 후, 변경 사항을 즉시 반영할 때 매우 유용하다.

# 4. Opting out of Caching (캐싱 비활성화)

특정 요청에서 캐싱을 사용하지 않으려면 다음 옵션을 설정하면 된다.

```tsx
fetch("https://...", { cache: "no-store" });
```

또는 다음 경우에도 자동으로 캐싱이 비활성화된다.

1. `fetch` 요청에 `cache: 'no-store'` 옵션이 추가된 경우.
2. 개별 `fetch` 요청에 `revalidate: 0` 옵션이 설정된 경우.
3. `POST` 메서드를 사용하는 **Router Handler(라우트 핸들러)** 내부에서 `fetch` 요청이 실행된 경우.
4. `headers` 또는 `cookies`를 사용한 후 `fetch` 요청이 실행된 경우.
5. 해당 경로 세그먼트(route segment)에서 `const dynamic = 'force-dynamic'` 옵션이 설정된 경우.
6. `fetchCache` 경로 세그먼트 옵션이 기본적으로 캐싱을 건너뛰도록 구성된 경우.
7. `Authorization` 또는 `Cookie` 헤더를 사용하는 `fetch` 요청이 있고, **그 위에(상위 컴포넌트에서) 캐싱되지 않은 요청이 존재하는 경우**.

## 개별 fetch 요청에서 캐싱 비활성화

개별 fetch 요청에서 캐싱을 비활성화하려면 `cache: 'no-store'` 로 설정하면 된다.

이렇게 하면 매 요청마다 새로운 데이터를 가져오게 되고, 이전 요청 결과가 캐시에 저장되지 않는다.

```tsx
fetch("https://...", { cache: "no-store" });
```

## 여러 개의 fetch 요청을 처리할 때

layout이나 page에서 여러 개의 fetch 요청이 있을 경우, Segment Config Options을 사용하여 전체 세그먼트의 캐싱 동작을 설정할 수 있다.

그러나, Next.js에서는 각 fetch 요청별로 개별적인 캐싱 옵션을 설정하는 것을 권장한다.

더 정밀한 캐싱 제어가 가능하기 때문이다.

# 5. Fetching Data on the Server with third-party libraries

fetch 가 아닌 다른 방법으로 데이터를 가져오는 경우, 캐싱 설정 방법이다.

데이터베이스, CMS, ORM 클라이언트 등 fetch를 직접 사용하지 않는 서드파티 라이브러리를 사용할 경우, Route Segment Config Option과 React cach 함수를 활용하여 캐싱 및 재검증 동작을 설정할 수 있다.

정적 경로의 경우 fetch 응답이 캐싱되나, 동적 경로는 매 요청마다 새롭게 데이터를 가져온다.

unstable_cache API를 사용할 수도 있다.

```tsx
import { cache } from "react";

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id });
  return item;
});
// 동일한 id로 여러 번 함수가 호출되어도, 하나의 데이터베이스 쿼리만 실행
```

```tsx
// app/item/[id]/layout.tsx
import { getItem } from "@/utils/get-item";

export const revalidate = 3600; // 1시간마다 캐시 재검증

export default async function Layout({
  params: { id },
}: {
  params: { id: string };
}) {
  const item = await getItem(id);
  return <div>{item.name}</div>;
}
```

# 6. Fetching Data on the Client with Route Handlers

클라이언트 컴포넌트에서 데이터를 가져올 때 Route handler를 사용할 수 도 있다.

라우트 핸들러는 서버에서 실행되며, 클라이언트가 요청을 보내 데이터를 가져올 수 있도록 한다.

✔ 클라이언트에서 서버 데이터를 안전하게 가져올 수 있음

✔ API 토큰 같은 민감한 정보를 직접 클라이언트에 노출하지 않음

# Server Actions and Mutations

서버 액션은 서버에서 실행되는 비동기 함수이다.

서버 컴포넌트와 클라이언트 컴포넌트 모두에서 사용 가능하며,

주로 폼 제출이나 데이터 변형(mutation)을 처리하는 데 활용된다.

# 서버 액션 컨벤션

`use server` 지시어를 사용하여 서버 액션을 정의한다.

이 지시어를 async 함수의 최상단에 추가하면 해당 함수가 서버 액션이 된다.

또한, 파일 최상단에 선언하면 해당 파일 내 모든 함수가 서버 액션이 된다.

## 서버 컴포넌트에서 사용

서버 컴포넌트에서는 인라인 함수 레벨 또는 모듈 레벨에서 `use server` 지시어를 사용할 수 있다.

```jsx
// app/page.tsx

// 서버 컴포넌트 (Server Component)
export default function Page() {
  // 서버 액션 (Server Action)
  async function create() {
    'use server' // 이 함수는 서버에서 실행됨

    // 서버 측에서 실행될 코드 작성 가능
  }

  return (
    // ...
  )
}
```

## 클라이언트 컴포넌트에서 사용

클라이언트 컴포넌트에서는 모듈 수준에서 선언된 서버 액션만 불러올 수 있다.

서버 액션을 호출하려면, `use server` 지시어가 있는 별도의 파일에서 서버 액션을 정의한 후 클라이언트 컴포넌트에서 이를 import 하여 사용해야 한다.

```jsx
// app/actions.ts
"use server";

export async function create() {
  // 서버에서 실행되는 함수
}

// app/ui/button.tsx
import { create } from "@/app/actions";

export function Button() {
  return <button onClick={() => create()}>클릭 시 서버 액션 실행</button>;
}
```

<aside>
🌟

왜 use server를 사용해야 할까?

- Next.js 14 에서는 서버 액션을 사용하여 직접 서버에서 데이터를 변경할 수 있다.
- 예전에는 API Routes를 따로 만들어야 했지만, 이제는 서버 액션을 직접 호출하면 된다.
- 즉, 서버와 클라이언트간의 API 호출을 줄여 코드가 단순해짐.
</aside>

# 서버 액션의 동작 방식 (Behavior)

서버 액션은 `<form>` 요소의 action 속성을 사용하여 호출될 수 있다.

서버 컴포넌트는 기본적으로 점진적 향상을 지원하므로, 자바스크립트가 아직 로드되지 않았거나 비활성화된 경우에도 폼이 제출된다.

클라이언트 컴포넌트에서 서버 액션을 호출하는 경우, 자바스크립트가 아직 로드되지 않았을 때 제출 요청이 queue에 저장되며, 클라이언트 하이드레이션이 우선된다.

하이드레이션이 완료된 후에는, 폼을 제출해도 브라우저가 새로고침하지 않는다.

서버 액션은 폼 요소에 한정되지 않으며, 이벤트 핸들러, useEffect, 서드파티 라이브러리, 버튼 같은 다른 폼 요소에도 호출될 수 있다.

서버 액션은 Next.js의 캐싱 및 revalidation 아키텍처와 통합된다.

즉, 서버 액션이 호출되면 Next.js는 단 한번의 서버 요청으로 업데이트된 UI와 새로운 데이터를 반환할 수 있다.

서버 액션은 내부적으로 POST 메서드를 사용하며, 이 HTTP 메서드만이 서버 액션을 홏루할 수 있다.

서버 액션의 인자와 반환 값은 React에서 직렬화할 수 있는 값이어야 한다.

[직렬화 가능한 인자와 값의 목륵은 문서를 참조하자.](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values)

서버 액션은 함수이다.

따라서, 애플리케이션 내 어디서든 재사용될 수 있다.

서버 액션은 사용된 페이지 또는 레이아웃의 런타임을 상속한다.

서버 액션은 사용된 페이지 또는 레이아웃의 라우트 세그먼트 구성(Route Segment Config)을 상속한다.

여기에는 maxDuration과 같은 설정이 포함된다.

# 예시

## Forms

React는 form 요소를 확장하여 action 속성을 통해 서버 액션을 호출할 수 있도록 한다.

폼에서 서버 액션이 호출되면, action 속성은 자동으로 [FormData](https://developer.mozilla.org/ko/docs/Web/API/FormData/FormData) 객체를 전달받는다.

useState를 사용하여 입력값을 관리할 필요 없이, 네이티브 FormData 메서드를 사용하여 데이터를 추출할 수 있다.

```tsx
// app/invoices/page.tsx

export default function Page() {
  async function createInvoice(formData: FormData) {
    "use server";

    const rawFormData = {
      customerId: formData.get("customerId"),
      amount: formData.get("amount"),
      status: formData.get("status"),
    };

    // 데이터 변형
    // 캐시 리벨리데이트
  }

  return <form action={createInvoice}>...</form>;
}
```

# 나의 생각..

<aside>
🌟

라우트트 핸들러에서 동일하게 처리할 수 있는거 같은데, 왜 서버 액션이 생겨났을까?

</aside>

- GPT o1의 대답
  서버 액션은 “직접 API 라우트를 만들 필요 없이, 서버 로직을 UI 가까이에서 작성하고, 서버 컴포넌트와 함께 싱크를 맞추고, 간편하게 로딩·에러 상태까지 다루자”라는 철학을 담고 있습니다.
  하지만 이미 TanStack Query 같은 라이브러리로 낙관적 업데이트와 API 호출 로직 분리를 잘 구축해놓았다면, 서버 액션의 이점이 크게 체감되지 않을 수도 있습니다. 그리고 관심사 분리 차원에서도 “컴포넌트 로직과 API 로직을 더 강력히 분리하고 싶다”는 쪽이라면 기존 방법이 더 맞을 수 있습니다.
  정리하자면,
  - **“Next.js 서버 컴포넌트와 함께 빠르게 UI-서버를 연결하고, 코드 양을 줄이고 싶다.”** → 서버 액션이 도움이 될 수 있음.
  - **“이미 성숙한 API 레이어와 캐싱 라이브러리를 쓰고 있어, 서버 액션이 굳이 필요 없고 관심사 분리도 중요하다.”** → 기존 TanStack Query 등 접근이 더 익숙하고 좋을 수 있음.
  둘 중 어느 것이 “더 옳다”라기보다는 **프로젝트와 팀의 성향, 규모, 기존 기술 스택** 등에 따라 적절한 판단을 내리면 될 것입니다.
