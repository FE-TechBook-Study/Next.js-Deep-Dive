# Rendering

렌더링은 작성한 코드를 사용자 인터페이스로 변환하는 과정이다. React와 Next.js를 사용하면 애플리케이션의 일부를 서버에서 렌더링하고, 일부를 클라이언트에서 렌더링하는 하이브리드 웹 애플리케이션을 만들 수 있다.

이 섹션에서는 이러한 렌더링 환경, 전략 및 런타임 간의 차이점을 이해하는 데 도움을 줄 것이다.

# 기본 개념

우선, 아래 세 가지 웹의 기본 개념을 이해하는 것이 도움이 된다.

1. 환경(environment): 애플리케이션 코드가 실행될 수 있는 두 가지 환경이 있다.
   - server
   - client
2. 요청-응답 생명주기(request-response lifecycle): 사용자가 애플리케이션을 방문하거나 상호작용할 때 발생하는 프로세스.
3. 네트워크 경계(network boundary): 서버 코드와 클라이언트 코드가 분리되는 지점.

# 렌더링 환경

웹 애플리케이션이 렌더링될 수 있는 환경은 클라이언트와 서버 두 가지다.

## 클라이언트와 서버 환경

- 클라이언트
  - 사용자의 기기에 있는 브라우저를 의미하며, 브라우저는 서버에 애플리케이션 코드 요청을 보내고, 서버의 응답을 받아 사용자 인터페이스로 변환한다.
- 서버
  - 데이터 센터의 컴퓨터를 의미하며, 애플리케이션 코드를 저장하고 있으며 클라이언트의 요청을 받아 적절한 응답을 제공한다.

![image.png](attachment:646127dd-ad27-4956-85a3-0eee951f10fb:image.png)

과거에는 서버와 클라이언트에서 각각 다른 언어를 사용해야 했다.

예를 들어,

- 서버 : PHP, Java, Python
- 클라이언트 : JavaScript

그러나 React를 사용하면 JavaScript 하나의 언어만으로 서버와 클라이언트에서 동일한 프레임워크(예를 들어, Next.js)를 사용할 수 있다.

이러한 유연성 덕분에 개발자는 서버와 클라이언트 간의 문맥 전환 없이 코드를 작성할 수 있다.

그러나 각 환경마다 수행할 수 있는 작업과 제약 사항이 다르다.

예를들어,

- 데이터 가져오기 (Data Fetching)
- 사용자 상태 관리 (User State Management)

등의 작업은 특정 환경에서 더 적합하게 실행될 수 있다.

이러한 차이를 이해하는 것이 React와 Next.js를 효과적으로 활용하는 핵심이다.

## 요청-응답 생명주기

모든 웹사이트는 기본적으로 동일한 요청-응답 생명주기를 따른다.

1. 사용자 액션
   - 사용자가 웹 애플리케이션과 상호작용한다.
   - 예: 링크 클릭, 폼 제출, URL 입력 등
2. HTTP Request
   - 클라이언트가 서버에 HTTP 요청을 보낸다.
   - 요청에는 필요한 리소스 정보, 요청 방식 (GET, POST 등), 추가 데이터가 포함된다.
3. 서버 처리
   - 서버가 요청을 처리하고 적절한 응답을 생성한다.
   - 이 과정에서 라우팅, 데이터 가져오기 등이 수행된다.
4. HTTP Response
   - 서버는 클라이언트에 HTTP 응답을 보낸다.
   - 응답에는 상태 코드와 요청한 리소스 (HTML, CSS, JavaScript 등) 가 포함된다.
5. 클라이언트 렌더링
   - 클라이언트가 받은 리소스를 해석하여 UI를 렌더링한다.
6. 사용자 액션 반복
   - UI가 렌더링되면, 사용자는 다시 상호작용할 수 있으며, 위 과정이 반복된다.

하이브리드 웹 애플리케이션을 구축할 때 이 생명주기에서 어느 부분을 서버에서 처리하고, 어느 부분을 클라이언트에서 처리할 것인지 결정하는 것이 중요하다.

즉, 네트워크 경게를 어디에 두는가가 중요한 역할을 한다.

# 네트워크 경계 (Network Boundary)

웹 개발에서 네트워크 경계는 개념적으로 환경을 나누는 선이다.

예를 들어,

- 클라이언트와 서버의 경계
- 서버와 데이터베이스의 경계

React에서는 클라이언트-서버 네트워크 경계를 자유롭게 설정할 수 있다.

이 과정에서 내부적으로 모듈 그래프(Module Graph)가 두 부분으로 나뉜다.

- 서버 모듈 그래프: 서버에서 렌더링되는 컴포넌트들.
- 클라이언트 모듈 그래프: 클라이언트에서 렌더링되는 컴포넌트들.

이 모듈 그래프를 통해 애플리케이션이 어떻게 동작하는지 시각적으로 이해할 수 있다.

React에서는 `use client` 와 `use server` 지시어를 사용하여 네트워크 경계를 정의할 수 있다.

- use client: 해당 모듈이 클라이언트에서 실행됨을 명시.
- use server: 해당 모듈이 서버에서 실행됨을 명시.

# 하이브리드 애플리케이션 구축

React와 Next.js 환경에서는 애플리케이션의 코드 흐름을 단방향(unidirectional) 흐름으로 생각하는 것이 중요하다.

즉, 응답 과정에서 코드는 서버에서 클라이언트로 흐른다.

만약 클라이언트에서 서버의 데이터를 가져와야 한다면,

기존 요청을 재사용하지 않고 새로운 요청을 서버로 보내야한다.

이러한 모델은 컴포넌트를 어디에서 렌더링할지 쉽게 결정할 수 있도록 해준다.

즉, 먼저 서버에서 실행할 작업을 정의하고, 그 결과를 클라이언트에 전달하여 UI를 구성하는 방식이 된다.

이 개념은 서버 컴포넌트와 클라이언트 컴포넌트가 하나의 컴포넌트 트리에서 어떻게 조합되는지를 살펴보면서 더욱 명확해질 것이다.

---

# Server Component

React 서버 컴포넌트는 UI를 서버에서 렌더링하고 선택적으로 캐시할 수 있게 해준다. Next.js에서는 렌더링 작업을 경로 세그먼트별로 분할하여 스트리밍과 부분 렌더링을 가능하게 하며, 세 가지 서버 렌더링 전략을 제공한다.

1. 정적 렌더링 (Static Rendering)
2. 동적 렌더링 (Dynamic Rendering)
3. 스트리밍 (Streaming)

이 페이지에서는 서버 컴포넌트의 작동 방식, 사용 시기, 그리고 다양한 서버 렌더링 전략에 대해 설명한다.

# 서버 렌더링의 이점

서버에서 렌더링 작업을 수행하면 다음과 같은 이점들이 있다.

- **Data Fetching**
  - 서버 컴포넌트를 사용하면 데이터 소스와 가까운 서버에서 데이터를 가져올 수 있다. 이렇게 하면 렌더링에 필요한 데이터를 가져오는 시간이 단축되고, 클라이언트에서의 요청 수를 줄여 성능이 향상도니다.
- **Security**
  - 서버 컴포넌트를 사용하면 토큰이나 API 키와 같은 민감한 데이터와 로직을 서버에 유지할 수 있어, 클라이언트에 노출될 위험이 없다.
- **Caching**
  - 서버에서 렌더링된 결과를 캐시하여 이후의 요청이나 다른 사용자들이 재사용할 수 있다. 이렇게 하면 렌더링과 데이터 패칭 작업이 줄어들어 성능이 향상되고 비용이 절감된다.
- **Performance**
  - 서버 컴포넌트를 사용하면 클라이언트 측 JavaScript의 양이 줄여 성능을 최적화할 수 있다. 인터넷 속도가 느리거나 성능이 낮은 장치를 사용하는 사용자들에게 유리하다.
- **Initial Page Load and [First Contentful Paint (FCP)](https://web.dev/fcp/)**
  - 서버에서 HTML을 생성하여 사용자가 페이지를 즉시 볼 수 있게 한다. 이렇게 하면 클라이언트가 JavaScript를 다운로드, 파싱, 실행할 때까지 기다릴 필요가 없다.
- **Search Engine Optimization and Social Network Shareability**
  - 렌더링된 HTML은 검색 엔진 봇이 페이지를 인덱싱하고, 소셜 네트워크 봇이 페이지의 미리보기를 생성하는 데 사용될 수 있다.
- **Streaming**
  - 서버 컴포넌트를 사용하면 렌더링 작업을 청크로 분할하여 준비되는 대로 클라이언트에 스트리밍할 수 있다. 이렇게 하면 사용자가 페이지의 일부를 더 빨리 볼 수 있다.

# Next.js에서 서버 컴포넌트 사용하기

기본적으로 Next.js는 서버 컴포넌트를 사용한다. 이를 통해 추가적인 설정 없이 자동으로 서버 렌더링을 구현할 수 있으며, 필요에 따라 클라이언트 컴포넌트를 선택적으로 사용할 수 있다.

# 서버 컴포넌트 렌더링 방식

서버에서 Next.js는 React의 API를 사용하여 렌더링을 조작한다. 렌더링 작업은 개별 경로 세그먼트와 Suspense 경계에 따라 청크로 분할된다.

각 청크는 두 단계로 렌더링된다.

1. React는 서버 컴포넌트를 React 서버 컴포넌트 페이로드 (RSC 페이로드)라는 특별한 데이터 형색으로 렌더링한다.
2. Next.js는 RSC 페이로드와 클라이언트 컴포넌트 JavaScript 지침을 사용하여 서버에서 HTML을 렌더링한다.

그런 다음, 클라이언트에서는:

- HTML을 사용하여 초기 페이지 로드 시 빠른 비상호작용 미리보기를 즉시 표시한다.
- RSC 페이로드를 사용하여 클라이언트와 서버 컴포넌트 트리를 조정하고 DOM을 업데이트한다.
- JavaScript 지침을 사용하여 클라이언트 컴포넌트를 하이드레이션하고 애플리케이션을 상호작용 가능하게 만든다.

<aside>
🌟

React Server Component Payload (RSC)는 무엇인가?
RSC 페이로드는 렌더링된 React 서버 컴포넌트 트리의 압축된 이진 표현이다. React는 클라이언트에서 이를 사용하여 브라우저의 DOM을 업데이틀한다. RSC 페이로드에는 다음이 포함된다.

- 서버 컴포넌트의 렌더링 결과
- 클라이언트 컴포넌트가 렌더링될 위치에 대한 플레이스 홀더와 해당 JavaScript 파일에 대한 참조
- 서버 컴포넌트에서 클라이언트 컴포넌트로 전달된 모든 props
</aside>

# 서버 렌더링 전략들

서버 렌더링에는 정적, 동적, 스트리밍 (Static, Dynamic, Streaming)의 세 가지 하위 범주가 있다.

## Static Rendering (Default)

정적 렌더링에서는 경로가 빌드 시점 또는 데이터 재검증 후 백그라운드에서 렌더링된다. 결과는 캐시되어 CDN에 푸시될 수 있다. 이러한 최적화는 렌더링 작업의 결과를 사용자와 서버 요청 간에 공유할 수 있게 해준다.

정적 렌더링은 경로의 데이터가 사용자별로 개인화되지 않고 빌드 시점에 알 수 있는 정적인 블로그 게시글 혹은 상품 페이지 등에 유용하다.

## Dynamic Rendering

동적 렌더링에서는 각 사용자의 요청 시점에 경로가 렌더링된다.

동적 렌더링은 사용자별로 개인화된 데이터나 요청 시점에만 알 수 있는 정보(쿠키 또는 URL의 searchparams 등)를 포함하는 경로에 유용하다.

대부분의 웹사이트는 완전히 정적이거나 완전히 동적인 경로로 구성되지 않고, 그 중간 어딘가에 위치한다. 예를 들어, 전자상거래 페이지는 일정 간격으로 재검증되는 캐시된 제품 데이터를 사용하면서도, 개인화된 고객 데이터를 포함할 수 있다.

Next.js에서는 캐시된 데이터와 캐시되지 않은 데이터를 모두 사용하는 동적으로 렌더링된 경로를 가질 수 있다. 이는 RSC 페이로드와 데이터가 별도로 캐시되기 때문에 가능하다. 이를 통해 모든 데이터를 요청 시 가져오는 성능 영향을 걱정하지 않고 동적 렌더링을 선택할 수 있다.

렌더링 중에 동적 함수나 캐시되지 않은 데이터 요청이 발견되면, Next.js는 전체 경로를 동적으로 렌더링하도록 전환한다.

![image.png](attachment:58f6ed23-656c-4939-9cd6-7bee51bb221a:image.png)

위 표에서 알 수 있듯이, 경로가 완전히 정적으로 렌더링되려면 모든 데이터가 캐시되어야 한다. 그러나 캐시된 데이터 패칭과 캐시되지 않은 데이터 패칭을 모두 사용하는 동적으로 렌더링된 경로를 가질 수 있다.

### Dynamic Functions

동적 함수는 사용자의 쿠키, 현재 요청 헤더 또는 URL SearchParams와 같이 요청 시에만 알수 있는 정보에 의존한다.

Next.js에서는 이러한 동적 함수는 다음과 같다

- [\*\*`cookies()`](https://nextjs.org/docs/14/app/api-reference/functions/cookies) and [`headers()`](https://nextjs.org/docs/14/app/api-reference/functions/headers)\*\*:
  - 서버 컴포넌트에서 이를 사용하면 전체 경로가 요청 시 동적으로 렌더링된다.
- [**`searchParams`**](https://nextjs.org/docs/14/app/api-reference/file-conventions/page#searchparams-optional):
  - page 에서 이 prop을 사용하면 해당 페이지는 요청 시 동적으로 렌더링된다.

이러한 함수들 중 하나를 사용하면 전체 경로가 요청 시 동적으로 렌더링된다.

## Streaming

![image.png](attachment:796fe37a-4127-4325-8ddf-50f9a6f3c681:image.png)

스트리밍을 통해 서버에서 UI를 점진적으로 렌더링할 수 있다. 작업은 청크로 분할되어 준비되는 대로 클라이언트에 스트리밍된다. 이를 통해 사용자는 전체 페이지가 서버에서 렌더링될 때까지 기다리지 않고도 페이지의 일부를 즉시 볼 수 있다.

스트리밍은 Next.js의 앱 라우터에 기본적으로 내장되어 있다. 이는 초기 페이지 로딩 성능을 향상시키며, 렌더링을 지연시키는 느린 데이터 페칭에 의존하는 UI에도 유용하다.

예를 들어, 제품 페이지의 리뷰 섹션 등이 이에 해당된다.

`loading.js` 와 React의 `Susepnse` 를 사용하요 경로 세그먼트와 UI 컴포넌트를 스트리밍할 수 이싿.

---

# Client Components

클라이언트 컴포넌트를 사용하면 서버에서 미리 렌더링된 인터랙티브한 UI를 작성하고, 브라우저에서 클라이언트 JavaScript를 실행할 수 있다.

# 클라이언트 렌더링의 이점

- 상호작용성: 클라이언트 컴포넌트는 state, effects, event listener를 사용할 수 있어, 사용자에게 즉각적인 피드백을 제공하고 UI를 업데이트할 수 있다.
- 브라우저 API 접근: geolocation이나 localStorage와 같은 브라우저 API에 접근할 수 있다.

# Next.js에서 클라이언트 컴포넌트 사용하기

클라이언트 컴포넌트를 사용하려면, 파일 상단의 import 문 위에 React의 `use client` 지시어를 추가하면 된다.

`use client` 는 서버 컴포넌트와 클라이언트 컴포넌트 모듈 간의 경계를 선언하는 데 사용된다. 즉, 파일에 `use client` 를 정의하면, 해당 파일에 import 된 모든 모듈과 자식 컴포넌트는 클라이언트 번들의 일부로 간주된다.

![image.png](attachment:a419a32a-c2bf-47e5-9a12-fdd963255566:image.png)

만약 중첩된 컴포넌트(toggle.js)에서 onClick이나 useState를 사용할 때 `use client` 지시어가 정의되어 있지 않으면 오류가 발생한다.

이는 기본적으로 앱 라우터의 모든 컴포넌트가 이러한 API를 사용할 수 없는 서버 컴포넌트이기 때문이다. toggle.js에서 `use client` 지시어를 정의함으로써, React에게 이러한 API를 사용할 수 있는 클라이언트 경계임을 알려줄 수 있다.

React 컴포넌트 트리에서 여러 `use client` 진입점을 정의할 수 있다. 이를 통해 애플리케이션을 여러 클라이언트 번들로 분할할 수 있다. 그러나 클라이언트에서 렌더링해야 하는 모든 컴포넌트 `use client` 를 정의할 필요는 없다. 한 번 경계를 정의하면, 그 안에 Import 된 모든 자식 컴포넌트와 모듈이 클라이언트 번들의 일부로 간주되기 때문이다.

<aside>
🌟

**루트 레이아웃에 `use client` 선언 시, 하위 세그먼트에 해당하는 모든 컴포넌트들은 클라이언트 컴포넌트인가?**

→ 루트 레이아웃에 `"use client"` 지시어를 선언하면, 해당 레이아웃 컴포넌트와 그 내부에 포함된 모든 컴포넌트가 클라이언트 컴포넌트로 간주된다. 이는 클라이언트 번들의 크기를 증가시켜 성능 저하를 유발할 수 있으므로, 루트 레이아웃을 클라이언트 컴포넌트로 설정하는 것은 권장되지 않는다.

따라서, 루트 레이아웃은 서버 컴포넌트로 유지하고, 클라이언트 측 기능이 필요한 경우에는 해당 기능을 별도의 클라이언트 컴포넌트로 분리하여 사용하는 것이 좋다. 이렇게 하면 클라이언트 번들의 크기를 최소화하고 애플리케이션의 성능을 최적화할 수 있다.

**루트 레이아웃을 서버 컴포넌트로 유지하면서 클라이언트 측 기능을 구현하려면 어떻게 해야 할까?**
→ 루트 레이아웃은 서버 컴포넌트로 유지하면서도 클라이언트 측 기능이 필요한 부분은 클라이언트 컴포넌트로 분리하여 구현할 수 있다. 이를 통해 클라이언트 번들의 크기를 최소화하고 애플리케이션의 성능을 최적화할 수 있다.

</aside>

# 클라이언트 컴포넌트 렌더링 방식

Next.js에서 클라이언트 컴포넌트는 요청이 전체 페이지 로드(애플리케이션 첫 방문이나 브라우저 새로고침에 의한 페이지 리로드)인지, 아니면 후속 탐색인지에 따라 다르게 렌더링된다.

## 전체 페이지 로드(Full Page Load):

초기 페이지 로드를 최적화하기 위해, Next.js는 React의 API를 활용하여 클라이언트 및 서버 컴포넌트 모두에 대해 정적 HTML 미리보기를 서버에서 렌더링한다.

초기 페이지 로드를 최적화하기 위해, Next.js는 React의 API를 활용하여 클라이언트 및 서버 커뫂넌트 모두에 대해 정적 HTML 미리보기를 서버에서 렌더링한다. 즉, 사용자가 처음으로 애플리케이션을 방문하면, 클라이언트 컴포넌트의 JavaScript 번들을 다운로드, 파싱, 실행할 필요 없이 페이지의 내용을 즉시 볼 수 있다.

서버에서는 다음과 같은 과정이 진행된다.

1. React는 서버 컴포넌트를 클라이언트 컴포넌트에 대한 참조를 포함한 특별한 데이터 형식인 React 서버 컴포넌트 페이로드 (RSC 페이로드)로 렌더링한다.
2. Next.js는 RSC 페이로드와 클라이언트 컴포넌트 JavaScript 지시사항을 사용하여 서버에서 해당 경로에 대한 HTML을 렌더링한다.

그런다 음, 클라이언트에서는

1. HTML을 사용하여 경로의 빠른 비상호작용 초기 미리보기를 즉시 표시한다.
2. React 서버 컴포넌트 페이로드를 사용하여 클라이언트와 서버 컴포넌트 트리를 조정하고 DOM을 업데이트한다.
3. JavaScript 지시사항을 사용하여 클라이언트 컴포넌트를 하이드레이션하고 UI를 상호작용 가능하게 만든다.

- **서버 컴포넌트와 클라이언트 컴포넌트 렌더링 방식 차이**
    <aside>
    🌟
    
    **서버 컴포넌트와 클라이언트 컴포넌트 렌더링 방식 차이 조사**
    
    ---
    
    ### 주요 차이점 요약
    
    - **렌더링 위치:**
        - *서버 컴포넌트:* 서버에서 실행되어 RSC 페이로드를 생성하고 HTML을 구성.
        - *클라이언트 컴포넌트:* 클라이언트에서 실행되며, 초기 로드는 서버에서 렌더링한 HTML을 사용하지만 후속 탐색 시 전적으로 클라이언트에서 렌더링됨.
    - **하이드레이션 필요성:**
        - *서버 컴포넌트:* 결과만 전달되므로 클라이언트에서 별도의 하이드레이션 과정을 거치지 않음.
        - *클라이언트 컴포넌트:* 초기 HTML 미리보기를 하이드레이션하여 인터랙티브하게 만듦.
    - **데이터 전달 및 업데이트:**
        - *서버 컴포넌트:* 압축된 RSC 페이로드를 통해 DOM 업데이트를 위한 데이터가 전달됨.
        - *클라이언트 컴포넌트:* 클라이언트 번들이 다운로드되어 실행되며, 그 결과로 인터랙티브한 UI가 구성됨.
    - **성능 최적화:**
        - *서버 컴포넌트:* 불필요한 클라이언트 사이드 JavaScript를 줄여 초기 로드 시간을 개선하고, 네트워크 부하를 낮춤.
        - *클라이언트 컴포넌트:* 사용자 인터랙션 및 동적 기능을 제공하지만, 그만큼 번들 크기와 하이드레이션 오버헤드가 발생할 수 있음.
    
    ---
    
    ### 결론
    
    서버 컴포넌트는 서버에서 렌더링되어 결과만 전달되므로, 클라이언트에 부담을 주지 않고 빠른 초기 로드를 가능하게 합니다. 반면, 클라이언트 컴포넌트는 인터랙티브한 기능을 제공하기 위해 클라이언트에서 실행되어야 하므로, 하이드레이션 및 번들 실행 과정을 거칩니다. 이 두 방식은 각기 다른 용도와 성능 최적화 전략을 제공하며, Next.js는 상황에 맞게 이들을 조합하여 사용자가 빠르고 효율적인 웹 경험을 할 수 있도록 지원합니다.
    
    </aside>

### 하이드레이션이란? \*Hydration

하이드레이션은 이벤트 리스너를 DOM에 연결하여 정적 HTML을 상호작용 가능하게 만드는 과정이다. 백그라운드에서는 React의 `hydrateRoot` API를 사용하여 수행된다.

## 후속 탐색(Subsequent Navigations)

후속 탐색에서는 클라이언트 컴포넌트가 서버에서 렌더링된 HTML 없이 전적으로 클라이언트에서 렌더링된다.

이는 클라이언트 컴포넌트의 JavaScript 번들이 다운로드되고 파싱된다는 것을 의미한다. 번들이 준비되면, React는 RSC 페이로드를 사용하여 클라이언트 컴포넌트와 서버 컴포넌트 트리를 조정(reconcile)하여 DOM을 업데이트한다.

- **클라이언트에서만 렌더링되는데 어떻게 RSC 페이로드를 사용하는가?**
    <aside>
    🌟
    
    **클라이언트에서만 렌더링되는데 어떻게 RSC 페이로드를 사용하는가?**
    
    후속 탐색에서 "클라이언트에서만 렌더링된다"는 것은, 사용자가 페이지를 처음 방문한 이후의 네비게이션에서는 이미 서버에서 완성된 HTML을 그대로 받아오는 것이 아니라, 클라이언트가 JavaScript 번들을 이용해 화면을 업데이트한다는 의미입니다. 그렇지만 이때도 서버는 새로운 경로에 해당하는 데이터를 RSC 페이로드라는 형태로 보내게 됩니다.
    
    즉, 후속 탐색 시에는 다음과 같은 과정이 진행됩니다:
    
    1. 클라이언트는 사용자가 새로운 경로로 이동할 때 서버에 해당 경로에 필요한 데이터를 요청합니다.
    2. 서버는 이 요청에 대해 해당 경로의 서버 컴포넌트 결과물을 RSC 페이로드로 생성하여 응답합니다.
    3. 클라이언트는 미리 다운로드된 클라이언트 컴포넌트 JavaScript 번들을 이용해, 이 RSC 페이로드를 기반으로 기존 컴포넌트 트리와 새 데이터를 "조정(reconcile)"합니다.
    4. 이 과정을 통해 DOM이 업데이트되어 새로운 페이지가 화면에 렌더링됩니다.
    
    즉, 후속 탐색에서는 전체 HTML을 서버가 직접 전송하는 대신, 필요한 데이터(서버 컴포넌트의 결과)를 RSC 페이로드 형태로 받아 클라이언트가 자체적으로 렌더링 및 업데이트를 수행하는 것입니다. 이렇게 하면 클라이언트는 이미 다운로드된 번들을 활용하여 효율적으로 페이지 전환을 처리할 수 있습니다.
    
    </aside>

# 서버 환경으로 돌아가기

때때로 `use client` 로 경계를 선언한 후에도 서버 환경으로 돌아가고 싶을 수가 있다.

예를 들어, 클라이언트 번들의 크기를 줄이거나 서버에서 데이터를 가져오거나, 서버에서만 사용 가능한 API를 사용하고자 할 수 있다.

## 이론적으로 클라이언트 컴포넌트 안에 중첩되어 있더라도, 클라이언트 컴포넌트와 서버 컴포넌트, 그리고 서버 액션을 번갈아(interleaving) 사용함으로써 코드를 서버에 유지할 수 있다.

# Composition Pattern

# 언제 서버 혹은 클라이언트 컴포넌트를 사용해야 할까?

| 수행하려는 작업                                                                 | 서버 컴포넌트 | 클라이언트 컴포넌트 |
| ------------------------------------------------------------------------------- | ------------- | ------------------- |
| 데이터를 가져오기                                                               | ✔️            |                     |
| 백엔드 리소스에 직접 접근하기                                                   | ✔️            |                     |
| 액세스 토큰, API 키 등 민감한 정보를 서버에 유지하기                            | ✔️            |                     |
| 큰 의존성을 서버에 유지하거나 클라이언트 측 JavaScript를 줄이기                 | ✔️            |                     |
| 상호작용 및 이벤트 리스너 추가하기 (`onClick()`, `onChange()` 등)               |               | ✔️                  |
| 상태 및 생명주기 효과 사용하기 (`useState()`, `useReducer()`, `useEffect()` 등) |               | ✔️                  |
| 브라우저 전용 API 사용하기                                                      |               | ✔️                  |
| 상태, 효과 또는 브라우저 전용 API에 의존하는 커스텀 훅 사용하기                 |               | ✔️                  |
| React 클래스 컴포넌트 사용하기                                                  |               | ✔️                  |

# 서버 컴포넌트 패턴

클라이언트 사이드 렌더링을 선택하기 전, 서버에서 데이터를 가져오거나 데이터베이스 또는 백엔드 서비스에 접근하는 등의 작업을 수행할 수 있다.

다음은 서버 컴포넌트를 사용할 대의 일반적인 패턴들이다.

## 1. 컴포넌트 간의 데이터 공유하기

서버에서 데이터를 가져올 때, 여러 컴포넌트에서 동일한 데이터를 공유해야 하는 경우가 있을 수 있다. 예를 들어, 레이아웃과 페이지가 동일한 데이터에 의존하는 경우이다.

React Context를 사용하거나 데이터를 props로 전달하는 대신, `fetch` 또는 React의 `cache` 함수를 사용하여 필요한 컴포넌트에서 동일한 데이터를 가져올 수 있다. 이를 통해 동일한 데이터에 대한 중복 요청을 걱정할 필요가 없다. 이는 React가 `fetch` 를 확장하여 데이터 요청을 자동으로 메모이제이션하고, `fetch` 를 사용할 수 없는 경우 `cache` 함수를 사용할 수 있기 때문이다.

## 2. 서버 전용 코드를 클라이언트 환경에서 제외하기

자바스크립트 모듈은 서버 및 클라이언트 컴포넌트 모듈 간에 공유될 수 있으므로, 서버에서만 실행되도록 의도된 코드가 클라이언트로 유입될 수 있다.

```tsx
// lib/data.ts
export async function getData() {
  const res = await fetch("https://external-service.com/data", {
    headers: {
      authorization: process.env.API_KEY,
    },
  });
  return res.json();
}
```

처음에는 `getData` 함수가 서버와 클라이언트 모두에서 작동하는 것처럼 보인다. 그러나 이 함수는 `API_KEY`를 포함하고 있으며, 이는 서버에서만 실행되도록 작성되었다.

환경 변수 `API_KEY`는 `NEXT_PUBLIC`로 접두어가 붙지 않았기 때문에, 서버에서만 접근할 수 있는 비공개 변수이다. 환경 변수가 클라이언트로 유출되는 것을 방지하기 위해, Next.js는 비공개 환경 변수를 빈 문자열로 대체한다.

결과적으로, `getData()`를 클라이언트에서 가져와 실행하더라도 예상대로 작동하지 않는다. 변수를 공개하면 클라이언트에서 함수가 작동하겠지만, 민감한 정보를 클라이언트에 노출하고 싶지 않을 수 있다.

이러한 의도치 않은 클라이언트에서의 서버 코드 사용을 방지하기 위해, `server-only` 패키지를 사용하여 다른 개발자가 이러한 모듈을 클라이언트 컴포넌트에 실수로 가져오지 않도록 빌드 시 오류를 발생시킬 수 있다.

```bash
npm install server-only
```

```jsx
// lib/data.js
import "server-only";

export async function getData() {
  const res = await fetch("https://external-service.com/data", {
    headers: {
      authorization: process.env.API_KEY,
    },
  });
  return res.json();
}
```

이제, 클라이언트 컴포넌트에서 `getData()`를 가져오면, 이 모듈은 서버에서만 사용할 수 있다는 빌드 시 오류가 발생한다.

`client-only` 패키지는 `window` 객체에 접근하는 코드와 같이 클라이언트 전용 코드를 포함하는 모듈을 표시하는 데 사용할 수 있다.

## 3. 서드 파티 패키지 및 프로바이더 사용하기

서버 컴포넌트는 새로운 React 기능이므로, 생태계의 서드파티 패키지 및 프로바이더는 `useState` , `createContenxt` 와 같은 클라이언트 전용 기능을 사용하는 컴포넌트에 `use client` 지시어를 추가하기 시작했다.

오늘날, 클라이언트 전용 기능을 사용하는 npm 패키지의 많은 컴포넌트는 아직 지시어를 가지고 있지 않다.

이러한 서드파티 컴포넌트는 클라이언트 컴포넌트 내에서 예상대로 작동하지만, 서버 컴포넌트 내에서는 작동하지 않는다.

예를 들어, `use state` 를 사용하는 Carousel 컴포넌트르 가진 가상의 `acme-carousel` 패키지를 설치했다고 보자.

이 컴포넌트는 아직 `use client` 지시어를 가지고 있지 않는다.

Carousel 컴포넌트를 클라이언트 컴포넌트 내에서 사용하면 예상대로 동작하지만, 이를 서버 컴포넌트에서 바로 사용하게 된다면, `{/* Error: useState can not be used within Server Components */}` 와 같은 에러를 마주하게 될 것이다.

```tsx
import { Carousel } from "acme-carousel";

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* Error: `useState` can not be used within Server Components */}
      <Carousel />
    </div>
  );
}
```

이는 Carousel 컴포너트가 클라이언트 전용 기능을 사용하고 있다는 것은 Next.js에서 인식하지 못하게 때문에, 이러한 컴포넌트를 서버 컴포넌트 내에서 직접 사용할 경우 오류가 발생할 수 있다. 이를 해결하기 위해, 해당 서드파티 컴포넌트를 클라이언트 컴포넌트로 감싸야 한다.

1. 먼저 클라이언트 컴포넌트로 감싸는 파일을 생성한다.

   ```tsx
   // app/carousel.tsx
   "use client";

   import { Carousel } from "acme-carousel";

   export default Carousel;
   ```

2. 서버 컴포넌트 내에서 이 감싼 컴포넌트를 사용할수 있다.

   ```tsx
   // app/page.tsx
   import Carousel from "./carousel";

   export default function Page() {
     return (
       <div>
         <p>View pictures</p>
         {/* Carousel은 클라이언트 컴포넌트이므로 정상적으로 동작합니다 */}
         <Carousel />
       </div>
     );
   }
   ```

대부분의 서드파티 컴포넌트는 클라이언트 컴포넌트 내에서 사용되므로 별도의 처리가 필요하지 않을 수 있다. 그러나 React의 상태와 컨텍스트를 사용하는 Provider와 같은 경우에는 애플리케이션의 루트에서 사용되기 때문에 별도의 처리가 필요할 수 있다.

### Context Providers 사용하기

React의 Context Provider는 전역적인 상태를 관리하기 위해 애플리케이션의 루트에 배치되는 경우가 많다.

그러나 서버 컴포넌트에서는 React의 컨텍스트를 지원하지 않으므로, 이를 직접 사용하려고 하면 오류가 발생한다.

이 문제를 해결하기 위해, 컨텍스트를 생성하고 이를 클라이언트 컴포넌트 내에서 Provider로 감싸야 한다.

예를 들어, 테마를 관리하는 `ThemeContext` 를 생성하고 이를 Provider로 사용하는 방법은 다음과 같다.

```tsx
// app/theme-provider.tsx
"use client";

import { createContext } from "react";

export const ThemeContext = createContext({});

export default function ThemeProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>;
}
```

그런 다음, 서버 컴포넌트인 루트 레이아웃에서 이 클라이언트 컴포넌트를 사용한다.

```tsx
// app/layout.tsx
import ThemeProvider from "./theme-provider";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  );
}
```

이렇게 하면 애플리케이션의 다른 클라이언트 컴포넌트에서 `ThemeContext` 를 사용할 수 있다. Provider는 가능한 한 트리의 깊은 곳에 렌더링하는 것이 좋다.

예를 들어, `ThemeProvider`가 `{children}`만을 감싸고 `<html>` 전체를 감싸지 않는 방식을 사용하면, Next.js가 서버 컴포넌트의 정적 부분을 최적화하는 데 도움이 된다.

이러한 접근 방식은 불필요한 클라이언트 측 JavaScript 번들 크기를 줄이고, 초기 로딩 시간을 단축하며, 전반적인 애플리케이션 성능을 향상시킨다.

또한, Provider를 트리의 깊은 곳에 배치하면, 상태나 컨텍스트가 필요한 컴포넌트에만 적용되어 불필요한 상태 관리로 인한 성능 저하를 방지할 수 있다.

이러한 전략은 Next.js의 자동 정적 최적화 기능과 결합되어 더욱 효율적인 애플리케이션을 구축하는 데 기여한다.

### 라이브러리 개발자를 위한 조언

마찬가지로, 다른 개발자들이 사용할 패키지를 만드는 라이브러리 개발자들은 패키지의 클라이언트 진입점을 표시하기 위해 `use client` 지시어를 사용할 수 있다.

이를 통해 패키지 사용자가 래핑 경계를 만들 필요 없이 패키지 컴포넌트를 직접 서버 컴포넌트에 가져올 수 있다.

패키지의 `use client` 지시어를 컴포넌트 트리의 더 깊은 곳에 사용하여, 가져온 모듈이 서버 컴포넌트 모듈 그래프의 일부가 되도록 최적화할 수 있다.

# 클라이언트 컴포넌트

## 1. 클라이언트 컴포넌트를 트리 하위로 이동시키기

클라이언트 자바스크립트 번들 크기를 줄이기 위해, 클라이언트 컴포넌트를 컴포넌트 트리의 하위로 이동시키는 것이 좋다.

예를 들어, 정적인 요소(로고,링크 등)와 상태를 사용하는 인터랙티브 검색 창이 포함된 레이아웃이 있다고 가정해보자.

전체 레이아웃을 클라이언트 컴포넌트로 만드는 대신, 상효작용 로직을 클라이언트 컴포넌트로 이동시키고, (Searchbar 등) 레이아웃은 서버 컴포넌트 유지하는 것이 좋다.

이렇게 하면 레이아웃의 모든 컴포넌트 자바스크립트를 클라이언트로 전송할 필요가 없다.

```tsx
// SearchBar is a Client Component
import SearchBar from "./searchbar";
// Logo is a Server Component
import Logo from "./logo";

// Layout is a Server Component by default
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  );
}
```

## 2. 서버에서 클라이언트 컴포넌트로 props 전달하기 (직렬화)

서버 컴포넌트에서 데이터를 가져온 후, 이를 클라이언트 컴포넌트로 props로 전덜하고자 할 수 있다. 이때, 서버에서 클라이언트 컴포넌트로 전달되는 props는 React에서 직렬화할 수 있어야 한다.

직렬화란 데이터 구조나 객체 상태를 저장하거나 전송하기 위해 일련의 바이트나 문자열로 변환하는 과정을 말한다.

이 과정에서 함수나 Date 객체와 같은 일부 데이터 타입은 직렬화 할 수 없기 때문에, 이러한 데이터를 직접 클라이언트 컴포넌트로 전달할 수 없다.

따라서, 클라이언트 컴포넌트가 직렬화할 수 없는 데이터에 의존하는 경우, 해당 데이터를 클라이언트 측에서 직접 가져오거나, 서버의 라우트 핸들러를 통해 데이터를 제공받는 방식을 고려해야 한다.

# 서버 컴포넌트와 클라이언트 컴포넌트 교차 사용하기

서버 컴포넌트와 클라이언트 컴포넌트를 혼합하여 사용할 때, UI를 컴포넌트 트리로 시각화하는 것이 도움이 될 수 있다.

루트 레이아웃은 서버 컴포넌트로 시작하며, `use client` 지시문을 추가하여 특정 하위 트리를 클라이언트에서 렌더링하도록 지정할 수 있다.

이러한 클라이언트 하위 트리 내에서도 서버 컴포넌트를 중첩하거나 서버 액션을 호출할 수 있지만, 다음 사항을 유의해야 한다:

- **요청-응답 라이프사이클 동안**:
  - 코드는 서버에서 클라이언트로 이동한다.
  - 클라이언트에서 서버의 데이터나 리소스에 접근해야 한다면, 새로운 서버 요청을 수행하게 되며, 서버와 클라이언트 간을 오가는 방식은 아니다.
- **새로운 서버 요청 시**:
  - 모든 서버 컴포넌트는 먼저 렌더링되며, 클라이언트 컴포넌트 내부에 중첩된 서버 컴포넌트도 포함된다. 렌더링 결과(RSC 페이로드)는 클라이언트 컴포넌트의 위치에 대한 참조를 포함하게 된다. 이후 클라이언트에서 React는 RSC 페이로드를 사용하여 서버와 클라이언트 컴포넌트를 단일 트리로 통합한다.
- **클라이언트 컴포넌트는 서버 컴포넌트 이후에 렌더링되므로**, 클라이언트 컴포넌트 모듈에서 서버 컴포넌트를 임포트할 수 없다. 대신, 서버 컴포넌트를 클라이언트 컴포넌트의 props로 전달할 수 있다.

## **지원되지 않는 패턴: 클라이언트 컴포넌트에서 서버 컴포넌트 임포트하기**

클라이언트 컴포넌트에서 서버 컴포넌트를 임포트할 수 없다:

```tsx
"use client";

// 서버 컴포넌트를 클라이언트 컴포넌트로 임포트할 수 없다.
import ServerComponent from "./Server-Component";

export default function ClientComponent({
  children,
}: {
  children: React.ReactNode;
}) {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      <ServerComponent />
    </>
  );
}
```

## **지원되는 패턴: 서버 컴포넌트를 클라이언트 컴포넌트의 props로 전달하기**

서버 컴포넌트를 클라이언트 컴포넌트의 props로 전달할 수 있다.

일반적인 패턴은 React의 `children` prop을 사용하여 클라이언트 컴포넌트에 "슬롯"을 만드는 것이다.

아래 예시에서 `<ClientComponent>`는 `children` prop을 받다:

```tsx
"use client";

import { useState } from "react";

export default function ClientComponent({
  children,
}: {
  children: React.ReactNode;
}) {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      {children}
    </>
  );
}
```

`<ClientComponent>`는 `children`이 결국 서버 컴포넌트의 결과로 채워질 것이라는 것을 알지 못한다. `<ClientComponent>`의 유일한 책임은 `children`이 최종적으로 배치될 위치를 결정하는 것이다.

상위 서버 컴포넌트에서 `<ClientComponent>`와 `<ServerComponent>`를 모두 임포트하고, `<ServerComponent>`를 `<ClientComponent>`의 자식으로 전달할 수다:

```tsx
import ClientComponent from "./client-component";
import ServerComponent from "./server-component";

// Next.js의 페이지는 기본적으로 서버 컴포넌트이다.
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  );
}
```

이 접근 방식으로 `<ClientComponent>`와 `<ServerComponent>`는 분리되어 독립적으로 렌더링될 수 있다. 이 경우, 자식인 `<ServerComponent>`는 클라이언트 컴포넌트가 렌더링되기 훨씬 전에 서버에서 렌더링될 수 있다.

**알아두면 좋은 점:**

- "내용 올리기(lifting content up)" 패턴은 부모 컴포넌트가 리렌더링될 때 중첩된 자식 컴포넌트의 리렌더링을 피하기 위해 사용된다.
- `children` prop에 제한되지 않는다. JSX를 전달하기 위해 어떤 prop이든 사용할 수 있다.

---

# Edge and Node.js Runtimes

Next.js에서는 서버에서 코드를 실행하기 위한두 가지 런타임을 제공한다

1. Node.js 런타임 (기본값): 모든 Node.js API와 호환되는 패키지에 접근할 수 있다.
2. Edge 런타임: Web API를 기반으로 하며, 더 제한된 API 세트를 제공한다.

**런타임 차이점**

| 특성                         | Node.js     | Edge           |
| ---------------------------- | ----------- | -------------- |
| 콜드 부트 시간               | 보통        | 낮음           |
| HTTP 스트리밍 지원           | 예          | 예             |
| I/O 지원                     | 모든 I/O    | `fetch`만 지원 |
| 확장성                       | 보통        | 매우 높음      |
| 보안                         | 보통        | 높음           |
| 지연 시간                    | 보통        | 매우 낮음      |
| npm 패키지 호환성            | 모든 패키지 | 일부 패키지    |
| 정적 렌더링 지원             | 예          | 아니요         |
| 동적 렌더링 지원             | 예          | 예             |
| `fetch`를 통한 데이터 재검증 | 예          | 예             |

- **콜드 부트 시간**: 서버리스 함수가 처음 호출될 때 초기화되는 데 걸리는 시간. Node.js 런타임은 일반적으로 초기화 시간이 더 길지만, Edge 런타임은 즉각적인 초기화를 제공한다.
- **HTTP 스트리밍 지원**: 두 런타임 모두 HTTP 스트리밍을 지원하여, 클라이언트에게 데이터를 점진적으로 전송할 수 있다.
- **I/O 지원**: Node.js 런타임은 파일 시스템 접근 등 모든 종류의 I/O 작업을 지원한다. 반면, Edge 런타임은 `fetch`를 통한 네트워크 요청만을 지원하며, 파일 시스템 접근은 제한된다.
- **확장성**: Edge 런타임은 전 세계에 분산된 엣지 서버에서 코드를 실행하므로, 높은 확장성을 제공한다. Node.js 런타임은 확장성이 제한적일 수 있다.
- **보안**: Edge 런타임은 제한된 실행 환경으로 인해 보안성이 높다. Node.js 런타임은 더 많은 권한을 가지므로, 보안 취약점에 노출될 가능성이 있다.
- **지연 시간**: Edge 런타임은 사용자와 가까운 위치에서 코드를 실행하므로, 지연 시간이 매우 낮다. Node.js 런타임은 서버의 위치에 따라 지연 시간이 증가할 수 있다.
- **npm 패키지 호환성**: Node.js 런타임은 모든 npm 패키지를 지원하지만, Edge 런타임은 제한된 API로 인해 일부 패키지만 지원한다.
- **정적 렌더링 지원**: Node.js 런타임은 정적 페이지 생성을 지원하지만, Edge 런타임은 이를 지원하지 않는다.
- **동적 렌더링 지원**: 두 런타임 모두 동적 콘텐츠 생성을 지원한다.
- **`fetch`를 통한 데이터 재검증**: 두 런타임 모두 `fetch`를 사용하여 데이터를 가져오고 재검증할 수 있다.

# Edge 런타임

edge 런타임은 작은 크기의 단순한 함수로 낮은 지연 시간의 동적이고 개인화된 콘텐츠를 제공할 때 이상적이다.

그러나 리소스 사용을 최소화하여 속도를 높이기 때문에, 일부 Node.js API를 지원하지 않아 특정 npm 패키지가 작동하지 않을 수 있다. 예를 들어, 파일 시스템(`fs` ) 모듈을 사용하는 패키지는 Edge 런타임에서 지원되지 않는다.

또한, Vercel에서 edge 런타임으로 실행되는 코드는 1mb에서 4mb 사이의 크기 제한이 있다. 이러한 이유로, 이러한 API나 패키지를 사용해야 하는 경우 Node.js 런타임을 사용하는 것이 좋다.

# Node.js 런타임

Node.js 런타임을 사용하면 모든 Node.js API와 이를 사용하는 npm 패키지에 접근할 수 있다. 그러나 Edge 런타임을 사용하는 경로보다 시작 속도가 느릴 수 있다. Next.js 애플리케이션을 Node.js 서버에 배포하려면 인프라를 관리, 확장 및 구성해야 한다. 대안으로, Vercel과 같은 서버리스 플랫폼에 배포하여 이러한 작업을 대신 처리하도록 할 수 있다.

# Serverless Node.js

서버리스 환경은 Edge 런타임보다 복잡한 계산 작업을 처리해야할 때 적합하다. 예를 들어, Vercel의 서버리스 함수는 전체 코드 크기가 50MB로, 가져온 패키지, 폰트 및 파일을 포함한다. 그러나 Edge 런타임을 사용하는 경로에 비해 서버리스 함수는 요청을 처리하기 전에 수백 밀리초의 부팅 시간이 필요할 수 있다. 사이트 트래픽 양에 따라 이러한 부팅 시간이 빈번하게 발생할 수 있다.

# 런타임 설정 예시

Next.js 애플리케이션에서 개별 경로 세그먼트에 대해 런타임을 지정할 수 있다. 이를 위해 `runtime` 이라는 변수를 선언하고 내보낸다. 변수는 문자열이어야 하며, `node.js` or `edge` 값을 가질수 있다.

```tsx
// app/layout.tsx
export const runtime = "edge"; // 'nodejs' (기본값) | 'edge'
```

레이아웃 수준에서 런타임을 정의하면 해당 레이아웃 아래의 모든 경로가 Edge 런타임에 서 실행된다.

세그먼트 런타임이 설정되지 않은 경우 기본적으로 `nodejs` 런타임이 사용된다.
