# Rendering

렌더링은 작성한 코드를 사용자 인터페이스로 변환하는 과정이다. React와 Next.js를 사용하면 애플리케이션의 일부를 서버에서 렌더링하고, 일부를 클라이언트에서 렌더링하는 하이브리드 웹 애플리케이션을 만들 수 있다.

이 섹션에서는 이러한 렌더링 환경, 전략 및 런타임 간의 차이점을 이해하는 데 도움을 줄 것이다.

# 기본 개념

우선, 아래 세 가지 웹의 기본 개념을 이해하는 것이 도움이 된다.

1. 환경(environment): 애플리케이션 코드가 실행될 수 있는 두 가지 환경이 있다.
   - server
   - client
2. 요청-응답 생명주기(request-response lifecycle): 사용자가 애플리케이션을 방문하거나 상호작용할 때 발생하는 프로세스.
3. 네트워크 경계(network boundary): 서버 코드와 클라이언트 코드가 분리되는 지점.

# 렌더링 환경

웹 애플리케이션이 렌더링될 수 있는 환경은 클라이언트와 서버 두 가지다.

## 클라이언트와 서버 환경

- 클라이언트
  - 사용자의 기기에 있는 브라우저를 의미하며, 브라우저는 서버에 애플리케이션 코드 요청을 보내고, 서버의 응답을 받아 사용자 인터페이스로 변환한다.
- 서버
  - 데이터 센터의 컴퓨터를 의미하며, 애플리케이션 코드를 저장하고 있으며 클라이언트의 요청을 받아 적절한 응답을 제공한다.

![image.png](attachment:646127dd-ad27-4956-85a3-0eee951f10fb:image.png)

과거에는 서버와 클라이언트에서 각각 다른 언어를 사용해야 했다.

예를 들어,

- 서버 : PHP, Java, Python
- 클라이언트 : JavaScript

그러나 React를 사용하면 JavaScript 하나의 언어만으로 서버와 클라이언트에서 동일한 프레임워크(예를 들어, Next.js)를 사용할 수 있다.

이러한 유연성 덕분에 개발자는 서버와 클라이언트 간의 문맥 전환 없이 코드를 작성할 수 있다.

그러나 각 환경마다 수행할 수 있는 작업과 제약 사항이 다르다.

예를들어,

- 데이터 가져오기 (Data Fetching)
- 사용자 상태 관리 (User State Management)

등의 작업은 특정 환경에서 더 적합하게 실행될 수 있다.

이러한 차이를 이해하는 것이 React와 Next.js를 효과적으로 활용하는 핵심이다.

## 요청-응답 생명주기

모든 웹사이트는 기본적으로 동일한 요청-응답 생명주기를 따른다.

1. 사용자 액션
   - 사용자가 웹 애플리케이션과 상호작용한다.
   - 예: 링크 클릭, 폼 제출, URL 입력 등
2. HTTP Request
   - 클라이언트가 서버에 HTTP 요청을 보낸다.
   - 요청에는 필요한 리소스 정보, 요청 방식 (GET, POST 등), 추가 데이터가 포함된다.
3. 서버 처리
   - 서버가 요청을 처리하고 적절한 응답을 생성한다.
   - 이 과정에서 라우팅, 데이터 가져오기 등이 수행된다.
4. HTTP Response
   - 서버는 클라이언트에 HTTP 응답을 보낸다.
   - 응답에는 상태 코드와 요청한 리소스 (HTML, CSS, JavaScript 등) 가 포함된다.
5. 클라이언트 렌더링
   - 클라이언트가 받은 리소스를 해석하여 UI를 렌더링한다.
6. 사용자 액션 반복
   - UI가 렌더링되면, 사용자는 다시 상호작용할 수 있으며, 위 과정이 반복된다.

하이브리드 웹 애플리케이션을 구축할 때 이 생명주기에서 어느 부분을 서버에서 처리하고, 어느 부분을 클라이언트에서 처리할 것인지 결정하는 것이 중요하다.

즉, 네트워크 경게를 어디에 두는가가 중요한 역할을 한다.

# 네트워크 경계 (Network Boundary)

웹 개발에서 네트워크 경계는 개념적으로 환경을 나누는 선이다.

예를 들어,

- 클라이언트와 서버의 경계
- 서버와 데이터베이스의 경계

React에서는 클라이언트-서버 네트워크 경계를 자유롭게 설정할 수 있다.

이 과정에서 내부적으로 모듈 그래프(Module Graph)가 두 부분으로 나뉜다.

- 서버 모듈 그래프: 서버에서 렌더링되는 컴포넌트들.
- 클라이언트 모듈 그래프: 클라이언트에서 렌더링되는 컴포넌트들.

이 모듈 그래프를 통해 애플리케이션이 어떻게 동작하는지 시각적으로 이해할 수 있다.

React에서는 `use client` 와 `use server` 지시어를 사용하여 네트워크 경계를 정의할 수 있다.

- use client: 해당 모듈이 클라이언트에서 실행됨을 명시.
- use server: 해당 모듈이 서버에서 실행됨을 명시.

# 하이브리드 애플리케이션 구축

React와 Next.js 환경에서는 애플리케이션의 코드 흐름을 단방향(unidirectional) 흐름으로 생각하는 것이 중요하다.

즉, 응답 과정에서 코드는 서버에서 클라이언트로 흐른다.

만약 클라이언트에서 서버의 데이터를 가져와야 한다면,

기존 요청을 재사용하지 않고 새로운 요청을 서버로 보내야한다.

이러한 모델은 컴포넌트를 어디에서 렌더링할지 쉽게 결정할 수 있도록 해준다.

즉, 먼저 서버에서 실행할 작업을 정의하고, 그 결과를 클라이언트에 전달하여 UI를 구성하는 방식이 된다.

이 개념은 서버 컴포넌트와 클라이언트 컴포넌트가 하나의 컴포넌트 트리에서 어떻게 조합되는지를 살펴보면서 더욱 명확해질 것이다.

---

# Server Component

React 서버 컴포넌트는 UI를 서버에서 렌더링하고 선택적으로 캐시할 수 있게 해준다. Next.js에서는 렌더링 작업을 경로 세그먼트별로 분할하여 스트리밍과 부분 렌더링을 가능하게 하며, 세 가지 서버 렌더링 전략을 제공한다.

1. 정적 렌더링 (Static Rendering)
2. 동적 렌더링 (Dynamic Rendering)
3. 스트리밍 (Streaming)

이 페이지에서는 서버 컴포넌트의 작동 방식, 사용 시기, 그리고 다양한 서버 렌더링 전략에 대해 설명한다.

# 서버 렌더링의 이점

서버에서 렌더링 작업을 수행하면 다음과 같은 이점들이 있다.

- **Data Fetching**
  - 서버 컴포넌트를 사용하면 데이터 소스와 가까운 서버에서 데이터를 가져올 수 있다. 이렇게 하면 렌더링에 필요한 데이터를 가져오는 시간이 단축되고, 클라이언트에서의 요청 수를 줄여 성능이 향상도니다.
- **Security**
  - 서버 컴포넌트를 사용하면 토큰이나 API 키와 같은 민감한 데이터와 로직을 서버에 유지할 수 있어, 클라이언트에 노출될 위험이 없다.
- **Caching**
  - 서버에서 렌더링된 결과를 캐시하여 이후의 요청이나 다른 사용자들이 재사용할 수 있다. 이렇게 하면 렌더링과 데이터 패칭 작업이 줄어들어 성능이 향상되고 비용이 절감된다.
- **Performance**
  - 서버 컴포넌트를 사용하면 클라이언트 측 JavaScript의 양이 줄여 성능을 최적화할 수 있다. 인터넷 속도가 느리거나 성능이 낮은 장치를 사용하는 사용자들에게 유리하다.
- **Initial Page Load and [First Contentful Paint (FCP)](https://web.dev/fcp/)**
  - 서버에서 HTML을 생성하여 사용자가 페이지를 즉시 볼 수 있게 한다. 이렇게 하면 클라이언트가 JavaScript를 다운로드, 파싱, 실행할 때까지 기다릴 필요가 없다.
- **Search Engine Optimization and Social Network Shareability**
  - 렌더링된 HTML은 검색 엔진 봇이 페이지를 인덱싱하고, 소셜 네트워크 봇이 페이지의 미리보기를 생성하는 데 사용될 수 있다.
- **Streaming**
  - 서버 컴포넌트를 사용하면 렌더링 작업을 청크로 분할하여 준비되는 대로 클라이언트에 스트리밍할 수 있다. 이렇게 하면 사용자가 페이지의 일부를 더 빨리 볼 수 있다.

# Next.js에서 서버 컴포넌트 사용하기

기본적으로 Next.js는 서버 컴포넌트를 사용한다. 이를 통해 추가적인 설정 없이 자동으로 서버 렌더링을 구현할 수 있으며, 필요에 따라 클라이언트 컴포넌트를 선택적으로 사용할 수 있다.

# 서버 컴포넌트 렌더링 방식

서버에서 Next.js는 React의 API를 사용하여 렌더링을 조작한다. 렌더링 작업은 개별 경로 세그먼트와 Suspense 경계에 따라 청크로 분할된다.

각 청크는 두 단계로 렌더링된다.

1. React는 서버 컴포넌트를 React 서버 컴포넌트 페이로드 (RSC 페이로드)라는 특별한 데이터 형색으로 렌더링한다.
2. Next.js는 RSC 페이로드와 클라이언트 컴포넌트 JavaScript 지침을 사용하여 서버에서 HTML을 렌더링한다.

그런 다음, 클라이언트에서는:

- HTML을 사용하여 초기 페이지 로드 시 빠른 비상호작용 미리보기를 즉시 표시한다.
- RSC 페이로드를 사용하여 클라이언트와 서버 컴포넌트 트리를 조정하고 DOM을 업데이트한다.
- JavaScript 지침을 사용하여 클라이언트 컴포넌트를 하이드레이션하고 애플리케이션을 상호작용 가능하게 만든다.

<aside>
🌟

React Server Component Payload (RSC)는 무엇인가?
RSC 페이로드는 렌더링된 React 서버 컴포넌트 트리의 압축된 이진 표현이다. React는 클라이언트에서 이를 사용하여 브라우저의 DOM을 업데이틀한다. RSC 페이로드에는 다음이 포함된다.

- 서버 컴포넌트의 렌더링 결과
- 클라이언트 컴포넌트가 렌더링될 위치에 대한 플레이스 홀더와 해당 JavaScript 파일에 대한 참조
- 서버 컴포넌트에서 클라이언트 컴포넌트로 전달된 모든 props
</aside>

# 서버 렌더링 전략들

서버 렌더링에는 정적, 동적, 스트리밍 (Static, Dynamic, Streaming)의 세 가지 하위 범주가 있다.

## Static Rendering (Default)

정적 렌더링에서는 경로가 빌드 시점 또는 데이터 재검증 후 백그라운드에서 렌더링된다. 결과는 캐시되어 CDN에 푸시될 수 있다. 이러한 최적화는 렌더링 작업의 결과를 사용자와 서버 요청 간에 공유할 수 있게 해준다.

정적 렌더링은 경로의 데이터가 사용자별로 개인화되지 않고 빌드 시점에 알 수 있는 정적인 블로그 게시글 혹은 상품 페이지 등에 유용하다.

## Dynamic Rendering

동적 렌더링에서는 각 사용자의 요청 시점에 경로가 렌더링된다.

동적 렌더링은 사용자별로 개인화된 데이터나 요청 시점에만 알 수 있는 정보(쿠키 또는 URL의 searchparams 등)를 포함하는 경로에 유용하다.

대부분의 웹사이트는 완전히 정적이거나 완전히 동적인 경로로 구성되지 않고, 그 중간 어딘가에 위치한다. 예를 들어, 전자상거래 페이지는 일정 간격으로 재검증되는 캐시된 제품 데이터를 사용하면서도, 개인화된 고객 데이터를 포함할 수 있다.

Next.js에서는 캐시된 데이터와 캐시되지 않은 데이터를 모두 사용하는 동적으로 렌더링된 경로를 가질 수 있다. 이는 RSC 페이로드와 데이터가 별도로 캐시되기 때문에 가능하다. 이를 통해 모든 데이터를 요청 시 가져오는 성능 영향을 걱정하지 않고 동적 렌더링을 선택할 수 있다.

렌더링 중에 동적 함수나 캐시되지 않은 데이터 요청이 발견되면, Next.js는 전체 경로를 동적으로 렌더링하도록 전환한다.

![image.png](attachment:58f6ed23-656c-4939-9cd6-7bee51bb221a:image.png)

위 표에서 알 수 있듯이, 경로가 완전히 정적으로 렌더링되려면 모든 데이터가 캐시되어야 한다. 그러나 캐시된 데이터 패칭과 캐시되지 않은 데이터 패칭을 모두 사용하는 동적으로 렌더링된 경로를 가질 수 있다.

### Dynamic Functions

동적 함수는 사용자의 쿠키, 현재 요청 헤더 또는 URL SearchParams와 같이 요청 시에만 알수 있는 정보에 의존한다.

Next.js에서는 이러한 동적 함수는 다음과 같다

- [\*\*`cookies()`](https://nextjs.org/docs/14/app/api-reference/functions/cookies) and [`headers()`](https://nextjs.org/docs/14/app/api-reference/functions/headers)\*\*:
  - 서버 컴포넌트에서 이를 사용하면 전체 경로가 요청 시 동적으로 렌더링된다.
- [**`searchParams`**](https://nextjs.org/docs/14/app/api-reference/file-conventions/page#searchparams-optional):
  - page 에서 이 prop을 사용하면 해당 페이지는 요청 시 동적으로 렌더링된다.

이러한 함수들 중 하나를 사용하면 전체 경로가 요청 시 동적으로 렌더링된다.

## Streaming

![image.png](attachment:796fe37a-4127-4325-8ddf-50f9a6f3c681:image.png)

스트리밍을 통해 서버에서 UI를 점진적으로 렌더링할 수 있다. 작업은 청크로 분할되어 준비되는 대로 클라이언트에 스트리밍된다. 이를 통해 사용자는 전체 페이지가 서버에서 렌더링될 때까지 기다리지 않고도 페이지의 일부를 즉시 볼 수 있다.

스트리밍은 Next.js의 앱 라우터에 기본적으로 내장되어 있다. 이는 초기 페이지 로딩 성능을 향상시키며, 렌더링을 지연시키는 느린 데이터 페칭에 의존하는 UI에도 유용하다.

예를 들어, 제품 페이지의 리뷰 섹션 등이 이에 해당된다.

`loading.js` 와 React의 `Susepnse` 를 사용하요 경로 세그먼트와 UI 컴포넌트를 스트리밍할 수 이싿.
