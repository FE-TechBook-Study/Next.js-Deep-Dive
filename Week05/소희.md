# Rendering

렌더링은 작성한 코드를 사용자 인터페이스로 변환하는 과정이다. React와 Next.js를 사용하면 애플리케이션의 일부를 서버에서 렌더링하고, 일부를 클라이언트에서 렌더링하는 하이브리드 웹 애플리케이션을 만들 수 있다.

이 섹션에서는 이러한 렌더링 환경, 전략 및 런타임 간의 차이점을 이해하는 데 도움을 줄 것이다.

# 기본 개념

우선, 아래 세 가지 웹의 기본 개념을 이해하는 것이 도움이 된다.

1. 환경(environment): 애플리케이션 코드가 실행될 수 있는 두 가지 환경이 있다.
   - server
   - client
2. 요청-응답 생명주기(request-response lifecycle): 사용자가 애플리케이션을 방문하거나 상호작용할 때 발생하는 프로세스.
3. 네트워크 경계(network boundary): 서버 코드와 클라이언트 코드가 분리되는 지점.

# 렌더링 환경

웹 애플리케이션이 렌더링될 수 있는 환경은 클라이언트와 서버 두 가지다.

## 클라이언트와 서버 환경

- 클라이언트
  - 사용자의 기기에 있는 브라우저를 의미하며, 브라우저는 서버에 애플리케이션 코드 요청을 보내고, 서버의 응답을 받아 사용자 인터페이스로 변환한다.
- 서버
  - 데이터 센터의 컴퓨터를 의미하며, 애플리케이션 코드를 저장하고 있으며 클라이언트의 요청을 받아 적절한 응답을 제공한다.

![image.png](attachment:646127dd-ad27-4956-85a3-0eee951f10fb:image.png)

과거에는 서버와 클라이언트에서 각각 다른 언어를 사용해야 했다.

예를 들어,

- 서버 : PHP, Java, Python
- 클라이언트 : JavaScript

그러나 React를 사용하면 JavaScript 하나의 언어만으로 서버와 클라이언트에서 동일한 프레임워크(예를 들어, Next.js)를 사용할 수 있다.

이러한 유연성 덕분에 개발자는 서버와 클라이언트 간의 문맥 전환 없이 코드를 작성할 수 있다.

그러나 각 환경마다 수행할 수 있는 작업과 제약 사항이 다르다.

예를들어,

- 데이터 가져오기 (Data Fetching)
- 사용자 상태 관리 (User State Management)

등의 작업은 특정 환경에서 더 적합하게 실행될 수 있다.

이러한 차이를 이해하는 것이 React와 Next.js를 효과적으로 활용하는 핵심이다.

## 요청-응답 생명주기

모든 웹사이트는 기본적으로 동일한 요청-응답 생명주기를 따른다.

1. 사용자 액션
   - 사용자가 웹 애플리케이션과 상호작용한다.
   - 예: 링크 클릭, 폼 제출, URL 입력 등
2. HTTP Request
   - 클라이언트가 서버에 HTTP 요청을 보낸다.
   - 요청에는 필요한 리소스 정보, 요청 방식 (GET, POST 등), 추가 데이터가 포함된다.
3. 서버 처리
   - 서버가 요청을 처리하고 적절한 응답을 생성한다.
   - 이 과정에서 라우팅, 데이터 가져오기 등이 수행된다.
4. HTTP Response
   - 서버는 클라이언트에 HTTP 응답을 보낸다.
   - 응답에는 상태 코드와 요청한 리소스 (HTML, CSS, JavaScript 등) 가 포함된다.
5. 클라이언트 렌더링
   - 클라이언트가 받은 리소스를 해석하여 UI를 렌더링한다.
6. 사용자 액션 반복
   - UI가 렌더링되면, 사용자는 다시 상호작용할 수 있으며, 위 과정이 반복된다.

하이브리드 웹 애플리케이션을 구축할 때 이 생명주기에서 어느 부분을 서버에서 처리하고, 어느 부분을 클라이언트에서 처리할 것인지 결정하는 것이 중요하다.

즉, 네트워크 경게를 어디에 두는가가 중요한 역할을 한다.

# 네트워크 경계 (Network Boundary)

웹 개발에서 네트워크 경계는 개념적으로 환경을 나누는 선이다.

예를 들어,

- 클라이언트와 서버의 경계
- 서버와 데이터베이스의 경계

React에서는 클라이언트-서버 네트워크 경계를 자유롭게 설정할 수 있다.

이 과정에서 내부적으로 모듈 그래프(Module Graph)가 두 부분으로 나뉜다.

- 서버 모듈 그래프: 서버에서 렌더링되는 컴포넌트들.
- 클라이언트 모듈 그래프: 클라이언트에서 렌더링되는 컴포넌트들.

이 모듈 그래프를 통해 애플리케이션이 어떻게 동작하는지 시각적으로 이해할 수 있다.

React에서는 `use client` 와 `use server` 지시어를 사용하여 네트워크 경계를 정의할 수 있다.

- use client: 해당 모듈이 클라이언트에서 실행됨을 명시.
- use server: 해당 모듈이 서버에서 실행됨을 명시.

# 하이브리드 애플리케이션 구축

React와 Next.js 환경에서는 애플리케이션의 코드 흐름을 단방향(unidirectional) 흐름으로 생각하는 것이 중요하다.

즉, 응답 과정에서 코드는 서버에서 클라이언트로 흐른다.

만약 클라이언트에서 서버의 데이터를 가져와야 한다면,

기존 요청을 재사용하지 않고 새로운 요청을 서버로 보내야한다.

이러한 모델은 컴포넌트를 어디에서 렌더링할지 쉽게 결정할 수 있도록 해준다.

즉, 먼저 서버에서 실행할 작업을 정의하고, 그 결과를 클라이언트에 전달하여 UI를 구성하는 방식이 된다.

이 개념은 서버 컴포넌트와 클라이언트 컴포넌트가 하나의 컴포넌트 트리에서 어떻게 조합되는지를 살펴보면서 더욱 명확해질 것이다.

---

# Server Component

React 서버 컴포넌트는 UI를 서버에서 렌더링하고 선택적으로 캐시할 수 있게 해준다. Next.js에서는 렌더링 작업을 경로 세그먼트별로 분할하여 스트리밍과 부분 렌더링을 가능하게 하며, 세 가지 서버 렌더링 전략을 제공한다.

1. 정적 렌더링 (Static Rendering)
2. 동적 렌더링 (Dynamic Rendering)
3. 스트리밍 (Streaming)

이 페이지에서는 서버 컴포넌트의 작동 방식, 사용 시기, 그리고 다양한 서버 렌더링 전략에 대해 설명한다.

# 서버 렌더링의 이점

서버에서 렌더링 작업을 수행하면 다음과 같은 이점들이 있다.

- **Data Fetching**
  - 서버 컴포넌트를 사용하면 데이터 소스와 가까운 서버에서 데이터를 가져올 수 있다. 이렇게 하면 렌더링에 필요한 데이터를 가져오는 시간이 단축되고, 클라이언트에서의 요청 수를 줄여 성능이 향상도니다.
- **Security**
  - 서버 컴포넌트를 사용하면 토큰이나 API 키와 같은 민감한 데이터와 로직을 서버에 유지할 수 있어, 클라이언트에 노출될 위험이 없다.
- **Caching**
  - 서버에서 렌더링된 결과를 캐시하여 이후의 요청이나 다른 사용자들이 재사용할 수 있다. 이렇게 하면 렌더링과 데이터 패칭 작업이 줄어들어 성능이 향상되고 비용이 절감된다.
- **Performance**
  - 서버 컴포넌트를 사용하면 클라이언트 측 JavaScript의 양이 줄여 성능을 최적화할 수 있다. 인터넷 속도가 느리거나 성능이 낮은 장치를 사용하는 사용자들에게 유리하다.
- **Initial Page Load and [First Contentful Paint (FCP)](https://web.dev/fcp/)**
  - 서버에서 HTML을 생성하여 사용자가 페이지를 즉시 볼 수 있게 한다. 이렇게 하면 클라이언트가 JavaScript를 다운로드, 파싱, 실행할 때까지 기다릴 필요가 없다.
- **Search Engine Optimization and Social Network Shareability**
  - 렌더링된 HTML은 검색 엔진 봇이 페이지를 인덱싱하고, 소셜 네트워크 봇이 페이지의 미리보기를 생성하는 데 사용될 수 있다.
- **Streaming**
  - 서버 컴포넌트를 사용하면 렌더링 작업을 청크로 분할하여 준비되는 대로 클라이언트에 스트리밍할 수 있다. 이렇게 하면 사용자가 페이지의 일부를 더 빨리 볼 수 있다.

# Next.js에서 서버 컴포넌트 사용하기

기본적으로 Next.js는 서버 컴포넌트를 사용한다. 이를 통해 추가적인 설정 없이 자동으로 서버 렌더링을 구현할 수 있으며, 필요에 따라 클라이언트 컴포넌트를 선택적으로 사용할 수 있다.

# 서버 컴포넌트 렌더링 방식

서버에서 Next.js는 React의 API를 사용하여 렌더링을 조작한다. 렌더링 작업은 개별 경로 세그먼트와 Suspense 경계에 따라 청크로 분할된다.

각 청크는 두 단계로 렌더링된다.

1. React는 서버 컴포넌트를 React 서버 컴포넌트 페이로드 (RSC 페이로드)라는 특별한 데이터 형색으로 렌더링한다.
2. Next.js는 RSC 페이로드와 클라이언트 컴포넌트 JavaScript 지침을 사용하여 서버에서 HTML을 렌더링한다.

그런 다음, 클라이언트에서는:

- HTML을 사용하여 초기 페이지 로드 시 빠른 비상호작용 미리보기를 즉시 표시한다.
- RSC 페이로드를 사용하여 클라이언트와 서버 컴포넌트 트리를 조정하고 DOM을 업데이트한다.
- JavaScript 지침을 사용하여 클라이언트 컴포넌트를 하이드레이션하고 애플리케이션을 상호작용 가능하게 만든다.

<aside>
🌟

React Server Component Payload (RSC)는 무엇인가?
RSC 페이로드는 렌더링된 React 서버 컴포넌트 트리의 압축된 이진 표현이다. React는 클라이언트에서 이를 사용하여 브라우저의 DOM을 업데이틀한다. RSC 페이로드에는 다음이 포함된다.

- 서버 컴포넌트의 렌더링 결과
- 클라이언트 컴포넌트가 렌더링될 위치에 대한 플레이스 홀더와 해당 JavaScript 파일에 대한 참조
- 서버 컴포넌트에서 클라이언트 컴포넌트로 전달된 모든 props
</aside>

# 서버 렌더링 전략들

서버 렌더링에는 정적, 동적, 스트리밍 (Static, Dynamic, Streaming)의 세 가지 하위 범주가 있다.

## Static Rendering (Default)

정적 렌더링에서는 경로가 빌드 시점 또는 데이터 재검증 후 백그라운드에서 렌더링된다. 결과는 캐시되어 CDN에 푸시될 수 있다. 이러한 최적화는 렌더링 작업의 결과를 사용자와 서버 요청 간에 공유할 수 있게 해준다.

정적 렌더링은 경로의 데이터가 사용자별로 개인화되지 않고 빌드 시점에 알 수 있는 정적인 블로그 게시글 혹은 상품 페이지 등에 유용하다.

## Dynamic Rendering

동적 렌더링에서는 각 사용자의 요청 시점에 경로가 렌더링된다.

동적 렌더링은 사용자별로 개인화된 데이터나 요청 시점에만 알 수 있는 정보(쿠키 또는 URL의 searchparams 등)를 포함하는 경로에 유용하다.

대부분의 웹사이트는 완전히 정적이거나 완전히 동적인 경로로 구성되지 않고, 그 중간 어딘가에 위치한다. 예를 들어, 전자상거래 페이지는 일정 간격으로 재검증되는 캐시된 제품 데이터를 사용하면서도, 개인화된 고객 데이터를 포함할 수 있다.

Next.js에서는 캐시된 데이터와 캐시되지 않은 데이터를 모두 사용하는 동적으로 렌더링된 경로를 가질 수 있다. 이는 RSC 페이로드와 데이터가 별도로 캐시되기 때문에 가능하다. 이를 통해 모든 데이터를 요청 시 가져오는 성능 영향을 걱정하지 않고 동적 렌더링을 선택할 수 있다.

렌더링 중에 동적 함수나 캐시되지 않은 데이터 요청이 발견되면, Next.js는 전체 경로를 동적으로 렌더링하도록 전환한다.

![image.png](attachment:58f6ed23-656c-4939-9cd6-7bee51bb221a:image.png)

위 표에서 알 수 있듯이, 경로가 완전히 정적으로 렌더링되려면 모든 데이터가 캐시되어야 한다. 그러나 캐시된 데이터 패칭과 캐시되지 않은 데이터 패칭을 모두 사용하는 동적으로 렌더링된 경로를 가질 수 있다.

### Dynamic Functions

동적 함수는 사용자의 쿠키, 현재 요청 헤더 또는 URL SearchParams와 같이 요청 시에만 알수 있는 정보에 의존한다.

Next.js에서는 이러한 동적 함수는 다음과 같다

- [\*\*`cookies()`](https://nextjs.org/docs/14/app/api-reference/functions/cookies) and [`headers()`](https://nextjs.org/docs/14/app/api-reference/functions/headers)\*\*:
  - 서버 컴포넌트에서 이를 사용하면 전체 경로가 요청 시 동적으로 렌더링된다.
- [**`searchParams`**](https://nextjs.org/docs/14/app/api-reference/file-conventions/page#searchparams-optional):
  - page 에서 이 prop을 사용하면 해당 페이지는 요청 시 동적으로 렌더링된다.

이러한 함수들 중 하나를 사용하면 전체 경로가 요청 시 동적으로 렌더링된다.

## Streaming

![image.png](attachment:796fe37a-4127-4325-8ddf-50f9a6f3c681:image.png)

스트리밍을 통해 서버에서 UI를 점진적으로 렌더링할 수 있다. 작업은 청크로 분할되어 준비되는 대로 클라이언트에 스트리밍된다. 이를 통해 사용자는 전체 페이지가 서버에서 렌더링될 때까지 기다리지 않고도 페이지의 일부를 즉시 볼 수 있다.

스트리밍은 Next.js의 앱 라우터에 기본적으로 내장되어 있다. 이는 초기 페이지 로딩 성능을 향상시키며, 렌더링을 지연시키는 느린 데이터 페칭에 의존하는 UI에도 유용하다.

예를 들어, 제품 페이지의 리뷰 섹션 등이 이에 해당된다.

`loading.js` 와 React의 `Susepnse` 를 사용하요 경로 세그먼트와 UI 컴포넌트를 스트리밍할 수 이싿.

---

# Client Components

클라이언트 컴포넌트를 사용하면 서버에서 미리 렌더링된 인터랙티브한 UI를 작성하고, 브라우저에서 클라이언트 JavaScript를 실행할 수 있다.

# 클라이언트 렌더링의 이점

- 상호작용성: 클라이언트 컴포넌트는 state, effects, event listener를 사용할 수 있어, 사용자에게 즉각적인 피드백을 제공하고 UI를 업데이트할 수 있다.
- 브라우저 API 접근: geolocation이나 localStorage와 같은 브라우저 API에 접근할 수 있다.

# Next.js에서 클라이언트 컴포넌트 사용하기

클라이언트 컴포넌트를 사용하려면, 파일 상단의 import 문 위에 React의 `use client` 지시어를 추가하면 된다.

`use client` 는 서버 컴포넌트와 클라이언트 컴포넌트 모듈 간의 경계를 선언하는 데 사용된다. 즉, 파일에 `use client` 를 정의하면, 해당 파일에 import 된 모든 모듈과 자식 컴포넌트는 클라이언트 번들의 일부로 간주된다.

![image.png](attachment:a419a32a-c2bf-47e5-9a12-fdd963255566:image.png)

만약 중첩된 컴포넌트(toggle.js)에서 onClick이나 useState를 사용할 때 `use client` 지시어가 정의되어 있지 않으면 오류가 발생한다.

이는 기본적으로 앱 라우터의 모든 컴포넌트가 이러한 API를 사용할 수 없는 서버 컴포넌트이기 때문이다. toggle.js에서 `use client` 지시어를 정의함으로써, React에게 이러한 API를 사용할 수 있는 클라이언트 경계임을 알려줄 수 있다.

React 컴포넌트 트리에서 여러 `use client` 진입점을 정의할 수 있다. 이를 통해 애플리케이션을 여러 클라이언트 번들로 분할할 수 있다. 그러나 클라이언트에서 렌더링해야 하는 모든 컴포넌트 `use client` 를 정의할 필요는 없다. 한 번 경계를 정의하면, 그 안에 Import 된 모든 자식 컴포넌트와 모듈이 클라이언트 번들의 일부로 간주되기 때문이다.

<aside>
🌟

**루트 레이아웃에 `use client` 선언 시, 하위 세그먼트에 해당하는 모든 컴포넌트들은 클라이언트 컴포넌트인가?**

→ 루트 레이아웃에 `"use client"` 지시어를 선언하면, 해당 레이아웃 컴포넌트와 그 내부에 포함된 모든 컴포넌트가 클라이언트 컴포넌트로 간주된다. 이는 클라이언트 번들의 크기를 증가시켜 성능 저하를 유발할 수 있으므로, 루트 레이아웃을 클라이언트 컴포넌트로 설정하는 것은 권장되지 않는다.

따라서, 루트 레이아웃은 서버 컴포넌트로 유지하고, 클라이언트 측 기능이 필요한 경우에는 해당 기능을 별도의 클라이언트 컴포넌트로 분리하여 사용하는 것이 좋다. 이렇게 하면 클라이언트 번들의 크기를 최소화하고 애플리케이션의 성능을 최적화할 수 있다.

**루트 레이아웃을 서버 컴포넌트로 유지하면서 클라이언트 측 기능을 구현하려면 어떻게 해야 할까?**
→ 루트 레이아웃은 서버 컴포넌트로 유지하면서도 클라이언트 측 기능이 필요한 부분은 클라이언트 컴포넌트로 분리하여 구현할 수 있다. 이를 통해 클라이언트 번들의 크기를 최소화하고 애플리케이션의 성능을 최적화할 수 있다.

</aside>

# 클라이언트 컴포넌트 렌더링 방식

Next.js에서 클라이언트 컴포넌트는 요청이 전체 페이지 로드(애플리케이션 첫 방문이나 브라우저 새로고침에 의한 페이지 리로드)인지, 아니면 후속 탐색인지에 따라 다르게 렌더링된다.

## 전체 페이지 로드(Full Page Load):

초기 페이지 로드를 최적화하기 위해, Next.js는 React의 API를 활용하여 클라이언트 및 서버 컴포넌트 모두에 대해 정적 HTML 미리보기를 서버에서 렌더링한다.

초기 페이지 로드를 최적화하기 위해, Next.js는 React의 API를 활용하여 클라이언트 및 서버 커뫂넌트 모두에 대해 정적 HTML 미리보기를 서버에서 렌더링한다. 즉, 사용자가 처음으로 애플리케이션을 방문하면, 클라이언트 컴포넌트의 JavaScript 번들을 다운로드, 파싱, 실행할 필요 없이 페이지의 내용을 즉시 볼 수 있다.

서버에서는 다음과 같은 과정이 진행된다.

1. React는 서버 컴포넌트를 클라이언트 컴포넌트에 대한 참조를 포함한 특별한 데이터 형식인 React 서버 컴포넌트 페이로드 (RSC 페이로드)로 렌더링한다.
2. Next.js는 RSC 페이로드와 클라이언트 컴포넌트 JavaScript 지시사항을 사용하여 서버에서 해당 경로에 대한 HTML을 렌더링한다.

그런다 음, 클라이언트에서는

1. HTML을 사용하여 경로의 빠른 비상호작용 초기 미리보기를 즉시 표시한다.
2. React 서버 컴포넌트 페이로드를 사용하여 클라이언트와 서버 컴포넌트 트리를 조정하고 DOM을 업데이트한다.
3. JavaScript 지시사항을 사용하여 클라이언트 컴포넌트를 하이드레이션하고 UI를 상호작용 가능하게 만든다.

- **서버 컴포넌트와 클라이언트 컴포넌트 렌더링 방식 차이**
    <aside>
    🌟
    
    **서버 컴포넌트와 클라이언트 컴포넌트 렌더링 방식 차이 조사**
    
    ---
    
    ### 주요 차이점 요약
    
    - **렌더링 위치:**
        - *서버 컴포넌트:* 서버에서 실행되어 RSC 페이로드를 생성하고 HTML을 구성.
        - *클라이언트 컴포넌트:* 클라이언트에서 실행되며, 초기 로드는 서버에서 렌더링한 HTML을 사용하지만 후속 탐색 시 전적으로 클라이언트에서 렌더링됨.
    - **하이드레이션 필요성:**
        - *서버 컴포넌트:* 결과만 전달되므로 클라이언트에서 별도의 하이드레이션 과정을 거치지 않음.
        - *클라이언트 컴포넌트:* 초기 HTML 미리보기를 하이드레이션하여 인터랙티브하게 만듦.
    - **데이터 전달 및 업데이트:**
        - *서버 컴포넌트:* 압축된 RSC 페이로드를 통해 DOM 업데이트를 위한 데이터가 전달됨.
        - *클라이언트 컴포넌트:* 클라이언트 번들이 다운로드되어 실행되며, 그 결과로 인터랙티브한 UI가 구성됨.
    - **성능 최적화:**
        - *서버 컴포넌트:* 불필요한 클라이언트 사이드 JavaScript를 줄여 초기 로드 시간을 개선하고, 네트워크 부하를 낮춤.
        - *클라이언트 컴포넌트:* 사용자 인터랙션 및 동적 기능을 제공하지만, 그만큼 번들 크기와 하이드레이션 오버헤드가 발생할 수 있음.
    
    ---
    
    ### 결론
    
    서버 컴포넌트는 서버에서 렌더링되어 결과만 전달되므로, 클라이언트에 부담을 주지 않고 빠른 초기 로드를 가능하게 합니다. 반면, 클라이언트 컴포넌트는 인터랙티브한 기능을 제공하기 위해 클라이언트에서 실행되어야 하므로, 하이드레이션 및 번들 실행 과정을 거칩니다. 이 두 방식은 각기 다른 용도와 성능 최적화 전략을 제공하며, Next.js는 상황에 맞게 이들을 조합하여 사용자가 빠르고 효율적인 웹 경험을 할 수 있도록 지원합니다.
    
    </aside>

### 하이드레이션이란? \*Hydration

하이드레이션은 이벤트 리스너를 DOM에 연결하여 정적 HTML을 상호작용 가능하게 만드는 과정이다. 백그라운드에서는 React의 `hydrateRoot` API를 사용하여 수행된다.

## 후속 탐색(Subsequent Navigations)

후속 탐색에서는 클라이언트 컴포넌트가 서버에서 렌더링된 HTML 없이 전적으로 클라이언트에서 렌더링된다.

이는 클라이언트 컴포넌트의 JavaScript 번들이 다운로드되고 파싱된다는 것을 의미한다. 번들이 준비되면, React는 RSC 페이로드를 사용하여 클라이언트 컴포넌트와 서버 컴포넌트 트리를 조정(reconcile)하여 DOM을 업데이트한다.

- **클라이언트에서만 렌더링되는데 어떻게 RSC 페이로드를 사용하는가?**
    <aside>
    🌟
    
    **클라이언트에서만 렌더링되는데 어떻게 RSC 페이로드를 사용하는가?**
    
    후속 탐색에서 "클라이언트에서만 렌더링된다"는 것은, 사용자가 페이지를 처음 방문한 이후의 네비게이션에서는 이미 서버에서 완성된 HTML을 그대로 받아오는 것이 아니라, 클라이언트가 JavaScript 번들을 이용해 화면을 업데이트한다는 의미입니다. 그렇지만 이때도 서버는 새로운 경로에 해당하는 데이터를 RSC 페이로드라는 형태로 보내게 됩니다.
    
    즉, 후속 탐색 시에는 다음과 같은 과정이 진행됩니다:
    
    1. 클라이언트는 사용자가 새로운 경로로 이동할 때 서버에 해당 경로에 필요한 데이터를 요청합니다.
    2. 서버는 이 요청에 대해 해당 경로의 서버 컴포넌트 결과물을 RSC 페이로드로 생성하여 응답합니다.
    3. 클라이언트는 미리 다운로드된 클라이언트 컴포넌트 JavaScript 번들을 이용해, 이 RSC 페이로드를 기반으로 기존 컴포넌트 트리와 새 데이터를 "조정(reconcile)"합니다.
    4. 이 과정을 통해 DOM이 업데이트되어 새로운 페이지가 화면에 렌더링됩니다.
    
    즉, 후속 탐색에서는 전체 HTML을 서버가 직접 전송하는 대신, 필요한 데이터(서버 컴포넌트의 결과)를 RSC 페이로드 형태로 받아 클라이언트가 자체적으로 렌더링 및 업데이트를 수행하는 것입니다. 이렇게 하면 클라이언트는 이미 다운로드된 번들을 활용하여 효율적으로 페이지 전환을 처리할 수 있습니다.
    
    </aside>

# 서버 환경으로 돌아가기

때때로 `use client` 로 경계를 선언한 후에도 서버 환경으로 돌아가고 싶을 수가 있다.

예를 들어, 클라이언트 번들의 크기를 줄이거나 서버에서 데이터를 가져오거나, 서버에서만 사용 가능한 API를 사용하고자 할 수 있다.

이론적으로 클라이언트 컴포넌트 안에 중첩되어 있더라도, 클라이언트 컴포넌트와 서버 컴포넌트, 그리고 서버 액션을 번갈아(interleaving) 사용함으로써 코드를 서버에 유지할 수 있다.
