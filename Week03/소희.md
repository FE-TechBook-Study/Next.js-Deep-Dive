# 1. Project Organization and File Colocation

라우팅 폴더 및 파일 규칙 외에, Next.js는 프로젝트 파일을 구성하거나 배치하는 방식에 대해 특별한 의견을 제시하지 않는다.

이 파트는 프로젝트를 구성하는데 사용할 수 있는 기본 동작과 기능을 공유한다.

## 1.1 안전한 파일 배치 (기본 동작)

`app` 디렉토리안에, 중첩된 폴더 계층이 라우트 구조를 정의한다.

각 폴더들은 라우트 세그먼트를 나타내며, 이는 URL 경로의 해당 세그먼트에 매핑된다.

하지만, 라우트 세그먼트는 page.js 또는 route.js 파일이 추가되기 전까지 해당 라우트는 공개적으로 접근할 수 없다.

- 라우트가 공개적으로 접근 가능하려면 해당 세그먼트 이름의 폴더에 page.js or route.js 파일 존재해야함.
- 라우트가 공개되어도, page.js or route.js 파일이 반환하는 내용만 클라이언트에 전달됨.
  - 다른 파일명은 노출 안됨.

<aside>
🌟

알아두면 좋은 점

- pages 디렉토리와 app 디렉토리는 다르다. pages 디렉토리 내의 모든 파일은 라우트로 간주된다.
- 파일을 app 디렉토리 내에 배치할 수는 있으나, 그렇게 해야만 하는 것은 아니다. 원한다면, app 디렉토리 밖에 배치할 수도 있다.
</aside>

## 1.2 프로젝트 구조화 기능

### 1.2.1 비공개 폴더

폴더 이름 앞에 `_` 를 붙여 비공개 폴더 생성.

라우팅 시스템에서 제외되며, 해당 폴더와 하위 폴더들은 라우팅에서 제외된다.

- UI 로직과 라우팅 로직을 분리할 때
- 프로젝트 및 Next.js 생태계 전반에서 내부 파일을 일관되게 구성할 때
- 코드 에디터에서 파일을 정렬하거나 그룹화할 때
- 향후 Next.js 파일 컨벤션과 잠재적 네이밍 충돌 방지

<aside>
🌟

알아두면 좋은 점

- 프레임워크의 관례는 아니지만, 비공개 폴더 외부에 있는 파일도 동일한 밑줄(`_`) 패턴을 사용하여 "비공개"로 표시하는 것을 고려할 수 있다.
- URL 세그먼트가 밑줄로 시작해야 하는 경우, 폴더 이름에 URL 인코딩된 값인 `%5F`를 붙여 사용할 수 있다. `%5FfolderName`
</aside>

### 1.2.2 라우트 그룹

폴더 이름을 괄호로 감싸면 라우트 그룹을 생성할 수 있다.

구조적 목적으로만 사용되며, 라우트의 URL 경로에 포함되지 않음을 나타낸다.

- 사이트 섹션, 의도, 팀별로 라우트를 그룹화
- 동일한 세그먼트 레벨 내에서 중첩된 레이아웃 생성
  - 여러 중첩 레이아웃 생성
  - 공통 세그먼트 내 일부 라으트에 레이아웃 추가

### 1.2.3 `src` 디렉토리

Next.js는 애플리케이션 코드(`app` 을 포함해서)를 선택적으로 src 디렉토리 안에 저장하는 것을 지원한다.

이는 프로젝트 설정 파일(주로 루트에 위치)과 애플리케이션 코드를 분리한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/354d3a3a-777d-4d9b-b039-b0c49e0b028c/image.png)

### 1.2.4 module path aliases (모듈 경로 별칭)

Next.js는 모듈 경로에 대한 별칭을 정의할 수 있어, 깊이 중첩된 파일 간의 import를 읽고 유지 관리하기 쉽게 만든다.

## 프로젝트 구조화 전략

프로젝트 파일과 폴더를 구성하는 데 있어 정답은 없다.

중요한 점은 팀과 자신에게 적합한 전략을 선택하고 일관성을 유지하는 것이다.

1. app 디렉토리 외부에 프로젝트 파일 저장

   ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/d928a017-c496-4cfb-b795-029b8227d50e/image.png)

- 모든 코드를 프로젝트 루트에 공유 폴더로 저장하고, app 하위는 순전히 라우팅 목적으로만 사용

1. app 내부의 상위 폴더에 프로젝트 파일 저장

   ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/1e88fc21-2db1-45ca-8325-7ff52e55776a/image.png)

   - 모든 코드를 app 폴더 내부의 공유 폴더에 저장

2. 기능 또는 라우트 별로 프로젝트 파일 분리

   ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/61dff1a8-614f-478f-8d74-af3a902ffdcd/image.png)

   - 전역적으로 공유되는 코드는 루트 app 폴더에 저장하고, 더 구체적인 코드는 이를 사용하는 라우트 세그먼트로 나누어 저장

# 2. Dynamic Routes

동적 라우팅은 특정 경로 세그먼트 이름을 알 수 없을 때 사용한다. 동적 데이터로부터 생성된 경로를 생성하고, 요청 시점에 세그먼트를 채우거나 빌드 시점에 프리 렌더링할 수 있다.

## 2.1 컨벤션

동적 세그먼트는 폴더 이름을 대괄호로 감싸는 방식으로 생성할 수 있다.

- [id]
- [slug]

동적 세그먼트는 `layout` , `page`, `route`, 그리고 `generateMetadata` 함수에 props로 전달된다.

### 예시

블로그 프로젝트를 예로 들면, `app/blog/[slug]/page.js` 경로에서 `[slug]` 는 블로그 게시글의 동적 세그먼트 역할을 한다.

```jsx
export default function Page({ params }: { params: { slug: string } }) {
  return <div>My Post: {params.slug}</div>;
}
```

## 2.2 정적 매개변수(Static Params) 생성

`generateStaticParams` 함수는 동적 세그먼트와 함께 사용하여 빌드 시점에 정적 경로를 생성할 수 있다.

```jsx
// app/blog/[slug]/page.tsx

export async function generateStaticParams() {
  const posts = await fetch("https://.../posts").then((res) => res.json());

  return posts.map((post) => ({
    slug: post.slug,
  }));
}
```

`generateStaticParams` 함수의 장점은 fetch 요청을 통해 가져온 데이터를 자동으로 메모이제이션 해준다는 것이다. 동일한 인수에 대해서 `generateStaticParams`, layouts, pages에서 호출될 경우 한 번만 요청된다.

## 2.3 Catch-all Segments

`[...folderName]` 와 같이 대괄호 내부에 줄임표 (…)를 추가하면 특정 세그먼트 이후 모든 경로를 포착할 수 있다.

`app/shop/[...slug]/page.js` 는 아래와 같은 경로와 매칭된다.

- `/shop/clothes`
- `/shop/clothes/tops`
- `/shop/clothes/tops/t-shirts` 등

| **Route**                    | **Example URL** | **`params`**                |
| ---------------------------- | --------------- | --------------------------- |
| `app/shop/[...slug]/page.js` | `/shop/a`       | `{ slug: ['a'] }`           |
| `app/shop/[...slug]/page.js` | `/shop/a/b`     | `{ slug: ['a', 'b'] }`      |
| `app/shop/[...slug]/page.js` | `/shop/a/b/c`   | `{ slug: ['a', 'b', 'c'] }` |

## 2.4 Optional Catch-all Segments

Catch-All 세그먼트를 선택적으로 만들려면 대괄호를 한 번 더 감싸 `[[...folderName]]` 형태로 정의한다.

:`app/shop/[[...slug]]/page.js`는 다음과 같은 경로와 매칭된다.

- `/shop`
- `/shop/clothes`
- `/shop/clothes/tops`
- `/shop/clothes/tops/t-shirts`

### 차이점

- Catch-All: 매개변수가 필요. (`/shop` 은 매칭되지 않음)
- Optional Catch-All: 매개변수가 없어도 경로가 매칭. (`/shop` 포함)

| **Route**                      | **Example URL** | **`params`**                |
| ------------------------------ | --------------- | --------------------------- |
| `app/shop/[[...slug]]/page.js` | `/shop`         | `{}`                        |
| `app/shop/[[...slug]]/page.js` | `/shop/a`       | `{ slug: ['a'] }`           |
| `app/shop/[[...slug]]/page.js` | `/shop/a/b`     | `{ slug: ['a', 'b'] }`      |
| `app/shop/[[...slug]]/page.js` | `/shop/a/b/c`   | `{ slug: ['a', 'b', 'c'] }` |

## 2.5 TypeScript

설정한 라우트 세그먼트에 따라 params 타입을 정의한다.

| **Route**                           | **`params` Type Definition**             |
| ----------------------------------- | ---------------------------------------- |
| `app/blog/[slug]/page.js`           | `{ slug: string }`                       |
| `app/shop/[...slug]/page.js`        | `{ slug: string[] }`                     |
| `app/shop/[[...slug]]/page.js`      | `{ slug?: string[] }`                    |
| `app/[categoryId]/[itemId]/page.js` | `{ categoryId: string, itemId: string }` |

# 3. Parallel Routes (병렬 라우트)

동일한 레이아웃 내에서 하나 이상의 페이지를 동시에 또는 조건부로 렌더링할 수 있게 해준다.

대시보드나 소셜 사이트의 피드처럼 동적으로 변하는 섹션에서 유용하다.

예를 들어, 대시보드에서 parallel route를 사용하여 팀 페이지와 분석 페이지를 동시에 렌더링할 수 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/12b40496-a512-4020-9637-1c0cbf9512c3/image.png)

## 3.1 Slots

parallel route는 named slots을 사용하여 생성된다. 슬롯은 `@folder` 와 같은 규칙으로 정의된다.

예를 들어, 다음 파일 구조는 `@analytics` 와 `@team` 이라는 두 슬롯을 정의한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/e602ac17-a6ef-49f5-b418-369b917b84c2/image.png)

### parallel route 파일 시스템 구조

슬롯은 공유된 부모 레이아웃에 props로 전달된다.

위 예시의 경우, `app/layout.js` 안의 컴포넌트가 `@analytics` 와 `@team` 슬롯 props를 받고, `children` 과 함께 병렬적으로 같이 렌더링할 수 있다.

```tsx
export default function Layout({
  children,
  team,
  analytics,
}: {
  children: React.ReactNode;
  analytics: React.ReactNode;
  team: React.ReactNode;
}) {
  return (
    <>
      {children}
      {team}
      {analytics}
    </>
  );
}
```

슬롯은 라우트 세그먼트가 아니므로 URL 구조에 영향을 주지 않는다.

예를 들어, `/@analytics/views`의 URL은 `/views` 이다. 여기서 `@analytics` 는 슬롯이므로 URL에 포함되지 않는다.

<aside>
🌟

**알아두면 좋은 점**

`children` prop은 묵시적인 슬롯(implicit slot)으로, 폴더와 매핑할 필요가 없다.

따라서, `app/page.js` 는 `app/@children/page.js` 와 동일하다.

</aside>

## 3.2 Active state and navigation (활성 상태와 내비게이션)

기본적으로 Next.js는 각 슬롯의 활성 상태를 추적한다.

다만, 슬롯 내에서 렌더링된 콘텐츠는 탐색 유형에 따라 달라진다.

- 소프트 내비게이션:
  - 클라이언트 사이드에서 탐색 시, Next.js는 슬롯 내 서브 페이지를 변경하면서 부분적으로 렌더링한다. 이때, URL과 일치하지 않는 슬롯의 활성 서브페이지는 그대로 유지된다.
- 하드 내비게이션:
  - 전체 페이지가 새로고침되면, URL과 일치하지 않는 슬롯의 활성 상태를 Next.js가 파악할 수 없다.
  - 이 경우, 해당 슬롯의 `default.js` 파일을 렌더링하거나, `default.js` 가 없으면 404 페이지가 렌더링된다.
  - 일치하지 않는 라우트에 대해 404를 렌더링함으로써, Parallel route가 의도되지 않은 페이지에서 잘못 렌더링되는 것을 방지한다.

## 3.3 default.js

`default.js` 파일을 정의하여 초기 로드나 전체 새로고침 시 일치하지 않는 슬롯에 대한 폴백을 렌더링할 수 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/56fd26d3-3be4-46b1-85ae-28d8a8e0f978/image.png)

위의 예시에서, `@team` 슬롯에는 `/settings` 페이지가 있지만, `@analytics` 슬롯에는 없다.

- `/settings` 로 이동 시, `team` 슬롯은 `/settings` 페이지를 렌더링하고, `@analytics` 슬롯은 현재 활성 상태의 페이지를 유지한다.
- 새로고침 시, Next.js는 `@analytics` 슬롯에 대해 `default.js` 를 렌더링한다. 만약 `default.js` 가 없으면 404가 렌더링된다.
- children은 묵시적 슬롯이므로, 부모 페이지의 활성 상태를 복구할 수 없을 때 사용할 폴백을 제공하려면 `default.js` 파일을 생성해야 한다.

## 3.4 `useSelectedLayoutSegment(s)` 훅

`useSelectedLayoutSegment`와 `useSelectedLayoutSegments`는 **parallelRoutesKey** 매개변수를 받아 슬롯 내 활성 라우트 세그먼트를 읽을 수 있게 한다.

```tsx
// app/layout.tsx
"use client";

import { useSelectedLayoutSegment } from "next/navigation";

export default function Layout({ auth }: { auth: React.ReactNode }) {
  const loginSegment = useSelectedLayoutSegment("auth");
  // ...
}
```

유저가 `app/@auth/login` 로 이동시, `loginSegment` 는 “login” 문자열과 동일해질 것이다.

## 3.5 Examples

### 3.5.1 Conditonal Routes (조건부 라우트)

parallel route를 사용하여 특정 조건(예를 들어, 사용자 역할)에 따라 라우트를 조건부로 렌더링할 수 있다.

예를 들어, `/admin` 또는 `/user` 역할에 따라 대시보드 페이지를 다르게 렌더링한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/baf7f5e0-04ea-481e-a061-c29d0c78f4bc/image.png)

```tsx
import { checkUserRole } from "@/lib/auth";

export default function Layout({
  user,
  admin,
}: {
  user: React.ReactNode;
  admin: React.ReactNode;
}) {
  const role = checkUserRole();
  return <>{role === "admin" ? admin : user}</>;
}
```

### 3.5.2 Tab Groups

슬롯 내에 레이아웃을 추가하여 사용자가 슬롯을 독립적으로 탐색할 수 있도록 한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/30d8daf6-cd4b-4612-a34a-fcda238935e2/image.png)

```tsx
// app/@analytics/layout.tsx

import Link from "next/link";

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        {/* 탭 네비게이션 */}
        <Link href="/page-views">Page Views</Link>
        <Link href="/visitors">Visitors</Link>
      </nav>
      {/* 현재 활성화된 서브페이지 렌더링 */}
      <div>{children}</div>
    </>
  );
}
```

- Link 컴포넌트를 사용해 각 탭에 서브 페이지들을 연결한다.
- children은 현재 활성화된 페이지(서브 페이지)를 나타낸다.
  - 사용자가 page-views를 클릭하면 `app/@analytics/page-views/page.tsx` 콘텐츠가 렌더링된다.

**동작 방식**

사용자가 page-views로 이동하면

- URL: `/page-views`
- chidlren에는 `app/@anayltics/page-views/page.tsx` 렌더링
- nav는 그대로 유지되고, Page Views 탭이 활성화 됨.

슬롯(`@analytics` )의 서브 페이지 간 탐색을 가능하게 하면서도, 부모 레이아웃(layout.tsx) 구조를 유지한다.

탭이 단순히 페이지 전환만 처리한다면 병렬 라우트 대신 라우트 그룹으로 충분함.

탭 그룹이 다른 병렬 슬롯들과 독립적으로 렌더링될 필요가 없다면 parallel 라우트는 불필요한 복잡성을 초래할 수있음.

슬롯 간 상태를 독립적으로 유지하고, 조건부 렌더링 등 복잡한 처리가 필요하다면 parallel route가 적합함.

- ⭐️ 실습 (라우트그룹 vs paralel route 각 방식으로 탭 그룹 만들고, 상태 독립 관리 이해하기)
  아래는 탭 그룹을 예시로 **상태가 독립적으로 관리되는지 확인할 수 있는 실습 코드**를 제공합니다. 이 코드는 **라우트 그룹**과 **병렬 라우트**를 각각 구현한 뒤, 각 탭의 상태(예: 카운터)를 독립적으로 관리하는지를 비교할 수 있게 작성되었습니다.
  ***
  ## **1. 라우트 그룹으로 구현한 탭 그룹**
  ### 파일 구조
  ```
  plaintext
  복사편집
  app/
  ├── (tabs)/
  │   ├── page-views/
  │   │   └── page.tsx
  │   └── visitors/
  │       └── page.tsx
  └── layout.tsx

  ```
  ### 코드
  **`app/layout.tsx`**
  ```tsx
  typescript;
  복사편집;
  import Link from "next/link";

  export default function Layout({ children }: { children: React.ReactNode }) {
    return (
      <>
        <nav>
          <Link href="/page-views">Page Views</Link>
          <Link href="/visitors">Visitors</Link>
        </nav>
        <div>{children}</div>
      </>
    );
  }
  ```
  **`app/(tabs)/page-views/page.tsx`**
  ```tsx
  typescript;
  복사편집;
  ("use client");
  import { useState } from "react";

  export default function PageViews() {
    const [count, setCount] = useState(0);

    return (
      <div>
        <h1>Page Views</h1>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
  }
  ```
  **`app/(tabs)/visitors/page.tsx`**
  ```tsx
  typescript;
  복사편집;
  ("use client");
  import { useState } from "react";

  export default function Visitors() {
    const [count, setCount] = useState(0);

    return (
      <div>
        <h1>Visitors</h1>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
  }
  ```
  ### 동작 확인
  1. `/page-views`에서 카운터를 증가시키면, 상태가 증가합니다.
  2. `/visitors`로 이동하면 상태는 초기화됩니다.
     - **라우트 그룹은 상태를 유지하지 않습니다.**
     - 상태가 컴포넌트 단위로 새로 렌더링되기 때문입니다.
  ***
  ## **2. 병렬 라우트로 구현한 탭 그룹**
  ### 파일 구조
  ```
  plaintext
  복사편집
  app/
  ├── @tabs/
  │   ├── page-views/
  │   │   └── page.tsx
  │   ├── visitors/
  │   │   └── page.tsx
  │   └── default.js
  └── layout.tsx

  ```
  ### 코드
  **`app/layout.tsx`**
  ```tsx
  typescript;
  복사편집;
  export default function Layout({ tabs }: { tabs: React.ReactNode }) {
    return (
      <>
        <nav>
          <a href="/page-views">Page Views</a>
          <a href="/visitors">Visitors</a>
        </nav>
        <div>{tabs}</div>
      </>
    );
  }
  ```
  **`app/@tabs/page-views/page.tsx`**
  ```tsx
  typescript;
  복사편집;
  ("use client");
  import { useState } from "react";

  export default function PageViews() {
    const [count, setCount] = useState(0);

    return (
      <div>
        <h1>Page Views</h1>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
  }
  ```
  **`app/@tabs/visitors/page.tsx`**
  ```tsx
  typescript;
  복사편집;
  ("use client");
  import { useState } from "react";

  export default function Visitors() {
    const [count, setCount] = useState(0);

    return (
      <div>
        <h1>Visitors</h1>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
  }
  ```
  **`app/@tabs/default.js`**
  ```tsx
  typescript;
  복사편집;
  export default function Default() {
    return <h1>Select a Tab</h1>;
  }
  ```
  ### 동작 확인
  1. `/page-views`에서 카운터를 증가시키면 상태가 증가합니다.
  2. `/visitors`로 이동한 뒤, 다시 `/page-views`로 돌아오면 상태가 유지됩니다.
     - **병렬 라우트는 슬롯 간 상태를 독립적으로 유지합니다.**
     - 각 슬롯이 독립적으로 관리되기 때문입니다.
  ***
  ## **3. 라우트 그룹과 병렬 라우트의 차이 비교**
  | 특징                          | 라우트 그룹                           | 병렬 라우트                                     |
  | ----------------------------- | ------------------------------------- | ----------------------------------------------- |
  | 상태 초기화 여부              | 다른 탭으로 이동하면 상태가 초기화됨. | 다른 탭으로 이동해도 상태가 유지됨.             |
  | 독립 상태 유지                | 불가능.                               | 가능.                                           |
  | 각 탭의 독립적 관리 필요 여부 | 단순한 페이지 전환에 적합.            | 상태나 데이터를 개별적으로 관리해야 할 때 적합. |

### 3.5.3 Modals

intercepting routes와 함께 모달을 구현할 수 있다.

1. URL을 통해 모달 콘텐츠 공유 가능.
2. 페이지가 새로고침 되어도 문맥(Context)를 유지하며 모달이 닫히지 않음.
3. 뒤로가기 시 이전 경로로 이동하지 않고 모달을 닫을 수 있음.
4. 앞으로 가기 시 모달을 다시 열 수 있음.

사용자가 레이아웃에서 클라이언트 사이드 네비게시녀을 통해 로그인 모달을 열거나, 별도의 `/login` 페이지에 접근할 수 있는 UI 패턴을 고려한다.

- ⭐️ TODO: 실습

## 3.6 Loading and Error UI

parallel route는 각 슬롯을 독립적으로 스트리밍할 수 있으므로, 로드 중 또는 에러 상태를 슬롯별로 정의할 수 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/6b6bf943-54e3-483f-a199-ab22b3517295/image.png)

# 4. Intercepting Routes

인터셉팅 라우트는 애플리케이션의 다룬 부분에 있는 경로를 현재 레이아웃 내에서 로드할 수 있게 해준다.

사용자가 다른 context로 전환하지 않으면서 특정 경로의 콘텐츠를 표시하고 싶을 때 유용하다.

예를 들어,

- 사용자가 피드에서 사진 클릭 시 사진 모달이 표시되고, 피드 위에 오버레이 된다.
- 이때 Next.js는 사진 경로를 인터셉트하여 URL은 변경하지만, 기존 피드 위에 모달을 오버레이로 레넏링한다.

## 컨벤션

`(..)` 규칙을 사용한다. 경로 세그먼트에 대해서만 작동한다.

1. **(.)**: 같은 레벨의 세그먼트에 매칭.
2. **(..)**: 한 레벨 위의 세그먼트에 매칭.
3. **(..)(..)**: 두 레벨 위의 세그먼트에 매칭.
4. **(...)**: 애플리케이션 루트(`app` 디렉토리)부터 매칭.

<aside>
🌟

**알아두면 좋은 점**
인터셉팅 라우트는 레이아웃을 유지하면서도 특정 콘텐츠를 오버레이하는데 강력한 기능을 제공한다.

1. 로그인 모달: 상단 네비게이션 바에서 열리지만, `/login` 전용 페이지도 지원.
2. 장바구니 모달: 사이드바에서 열리지만, `/cart` 전용 페이지도 지원.
</aside>

# 5. Route Handlers

Route handlers는 주어진 경로에 대해 웹 요청(Request) 및 응답(Response) API를 사용하여 커스텀 요청 핸들러를 생성할 수있도로 한다.

## 5.1 Route.js 파일

Route handlers는 app 디렉토리 내에서만 사용할 수 있다. pages 디렉토리의 API Routes와 동등하며, 두 가지를 함께 사용할 필요는 없다.

<aside>
🌟

**Route handlers vs API Routes**

1. API Route는 하나의 파일에서 모든 메서드를 분기하지만, Route Handlers는 각 메서드를 함수로 명시함.
2. Route Handlers는 기본 캐싱(특히 GET)과 `NextRequest/NextResponse` 확장 기능을 지원.
3. 둘 다 서버 로직을 담당하지만, Route Handlers가 스트리밍 지원 등 더 확장성 있는 유틸 제공.
</aside>

### 컨벤션

- `route.js/ts` 로 파일을 정의한다.
- `page.js` 와 동일한 라우트 세그먼트 레벨에 `route.js` 파일이 존재할 수 없다.

## 5.2 지원되는 HTTP 메서드

- **GET**, **POST**, **PUT**, **PATCH**, **DELETE**, **HEAD**, **OPTIONS**
  - 지원되지 않는 메서드를 호출하면 **405 Method Not Allowed** 응답이 반환됨.

## 5.3 확장된 NextRequest 및 NextResponse API

기본 **Request** 및 **Response** 외에도 **NextRequest**와 **NextResponse**를 확장하여 제공한다. (Web API에 추가적인 편리한 메서드들을 확장한 것이라고 이해하면 됨.)

## 5.4 동작

### **캐싱**

**GET 메서드** 에서 Response 객체를 사용할 경우, Route Handlers는 기본적으로 캐싱된다.

```tsx
// app/items/route.ts
export async function GET() {
  const res = await fetch("https://data.mongodb-api.com/...", {
    headers: {
      "Content-Type": "application/json",
      "API-Key": process.env.DATA_API_KEY,
    },
  });
  const data = await res.json();

  return Response.json({ data });
}
```

- `Response.json()`은 TypeScript 5.2 이상에서만 사용 가능하다. 이전 버전에서는 `NextResponse.json()`을 사용하여 타이핑된 응답을 사용할 수 있다.

### 캐싱 비활성화

1. GET 메서드에서 `Request` 객체를 사용하는 경우.
2. 다른 HTTP 메서드를 사용하는 경우.
3. 쿠키, 헤더 같은 동적 기능을 사용하는 경우.
4. Segment Config Options 에서 동적 모드를 수동으로 지정하는 경우.

### POST 요청

POST 메서드는 Route Handler를 동적으로 평가하도록 만든다.

## 5.5 예시

### 1. 캐시된 데이터 재검증

`next.revalidate` 옵션을 사용한다.

```tsx
// app/items/route.ts
export async function GET() {
  const res = await fetch("https://data.mongodb-api.com/...", {
    next: { revalidate: 60 }, // 60초마다 재검증
  });
  const data = await res.json();

  return Response.json(data);
}
```

### 2. Dynamic Functions

**Cookies**

`next/headers` 에서 제공하는 `cookies` 를 사용해 쿠키를 읽거나 설정할 수 있다.

```tsx
// app/api/route.ts
import { cookies } from "next/headers";

export async function GET(request: Request) {
  const cookieStore = cookies();
  const token = cookieStore.get("token");

  return new Response("Hello, Next.js!", {
    status: 200,
    headers: { "Set-Cookie": `token=${token.value}` },
  });
}
```

**Headers**

`headers` 를 사용해 헤더를 읽을 수 있으며, 새로운 헤더를 설정하려면 `Response` 를 반환해야 한다.

```tsx
// app/api/route.ts
import { headers } from "next/headers";

export async function GET(request: Request) {
  const headersList = headers();
  const referer = headersList.get("referer");

  return new Response("Hello, Next.js!", {
    status: 200,
    headers: { referer: referer },
  });
}
```

### 3. Redirects

`redirect` 함수를 사용해 요청을 다른 경로로 리다이렉트 할 수 있다.

```tsx
// app/api/route.ts
import { redirect } from "next/navigation";

export async function GET(request: Request) {
  redirect("https://nextjs.org/");
}
```

### 4. Dynamic Route Segments (동적 라우트 세그먼트)

```tsx
// app/items/[slug]/route.ts
export async function GET(
  request: Request,
  { params }: { params: { slug: string } }
) {
  const slug = params.slug; // 'a', 'b', or 'c'
}
```

### 5. URL Query Parameters

`NextRequest` 객체의 메서드를 사용해 쿼리 파라미터를 쉽게 처리 할 수 있다.

```tsx
// app/api/search/route.ts
import { type NextRequest } from "next/server";

export function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const query = searchParams.get("query"); // URL: /api/search?query=hello
}
```

### 6. Streaming

```tsx
// app/api/chat/route.ts
import OpenAI from "openai";
import { OpenAIStream, StreamingTextResponse } from "ai";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(req: Request) {
  const { messages } = await req.json();
  const response = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    stream: true,
    messages,
  });

  const stream = OpenAIStream(response);

  return new StreamingTextResponse(stream);
}
```

### 7. Request Body

표준 Web API 메서드를 사용하는 `Request` body를 읽을 수 있다.

```tsx
export async function POST(request: Request) {
  const res = await request.json();
  return Response.json({ res });
}
```

### 8. Request Body FormData

request.formData를 통해, FormData를 읽을 수 있다.

formData는 모두 문자열이기 때문에, 요청을 검증하기 위해서 [**`zod-form-data`**](https://www.npmjs.com/package/zod-form-data) 를 사용하여 검증하고, number와 같은 원하는 포맷으로 데이터를 얻을 수 있다.

### 9. CORS

표준 Web API 메서드를 사용하여 특정 라우트 핸들러에 CORS 헤더를 설정할 수 있다.

- 만약 여러 라우트 핸들러에 CORS 헤더를 추가하고 싶다면, Middleware 혹은 next.config.js 파일을 사용할 수 있다.
-

```tsx
export const dynamic = "force-dynamic"; // defaults to auto

export async function GET(request: Request) {
  return new Response("Hello, Next.js!", {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
    },
  });
}
```

### 10. Webhooks

써드파티 서비스로부터 웹훅을 받기 위해 라우트 핸들러를 사용할 수 있다.

Page Router의 API Routes와 다르게, Route Handler에서는 bodyParser을 사용할 필요가 없다.

즉 추가 설정 없이 request 객체로부터 데이터를 가져올 수 있다.

### 11. Edge and Node.js Runtimes

Route Handler는 Edge와 Node.js 런타임 모두를 매끄럽게 지원하기 위해 동형(isomorphic) Web API를 제공한다. 여기에는 스트리밍 기능 지원도 포함된다.

또한 Pages와 Layouts와 동일한 라우트 세그먼트 설정 방식을 사용하므로, 일반적인 정적 재생성(SSR) Route hander와 같은 오랫동안 대기하던 기능도 지원할 수 있다.

런타임을 직접 지정하려면 runtime 세그먼트 설정 옵션을 사용할 수 있다.

```tsx
export const runtime = "edge"; // 기본값은 'nodejs'
```

### 12. Non-UI Responses

`sitemap.xml` , `robots.txt`, `app icons` , open graph images와 같은 UI가 없는 콘텐츠를 반환할 수 있다.

```tsx
export const dynamic = "force-dynamic"; // defaults to auto

export async function GET() {
  return new Response(
    `<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
 
<channel>
  <title>Next.js Documentation</title>
  <link>https://nextjs.org/docs</link>
  <description>The React Framework for the Web</description>
</channel>
 
</rss>`,
    {
      headers: {
        "Content-Type": "text/xml",
      },
    }
  );
}
```

### 13. Segment Config Options

Route handlers는 pages와 layouts과 똑같은 라우트 세그먼트 설정을 사용한다.

```tsx
export const dynamic = "auto";
export const dynamicParams = true;
export const revalidate = false;
export const fetchCache = "auto";
export const runtime = "nodejs";
export const preferredRegion = "auto";
```
