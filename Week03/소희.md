# 1. Project Organization and File Colocation

라우팅 폴더 및 파일 규칙 외에, Next.js는 프로젝트 파일을 구성하거나 배치하는 방식에 대해 특별한 의견을 제시하지 않는다.

이 파트는 프로젝트를 구성하는데 사용할 수 있는 기본 동작과 기능을 공유한다.

## 1.1 안전한 파일 배치 (기본 동작)

`app` 디렉토리안에, 중첩된 폴더 계층이 라우트 구조를 정의한다.

각 폴더들은 라우트 세그먼트를 나타내며, 이는 URL 경로의 해당 세그먼트에 매핑된다.

하지만, 라우트 세그먼트는 page.js 또는 route.js 파일이 추가되기 전까지 해당 라우트는 공개적으로 접근할 수 없다.

- 라우트가 공개적으로 접근 가능하려면 해당 세그먼트 이름의 폴더에 page.js or route.js 파일 존재해야함.
- 라우트가 공개되어도, page.js or route.js 파일이 반환하는 내용만 클라이언트에 전달됨.
  - 다른 파일명은 노출 안됨.

<aside>
🌟

알아두면 좋은 점

- pages 디렉토리와 app 디렉토리는 다르다. pages 디렉토리 내의 모든 파일은 라우트로 간주된다.
- 파일을 app 디렉토리 내에 배치할 수는 있으나, 그렇게 해야만 하는 것은 아니다. 원한다면, app 디렉토리 밖에 배치할 수도 있다.
</aside>

## 1.2 프로젝트 구조화 기능

### 1.2.1 비공개 폴더

폴더 이름 앞에 `_` 를 붙여 비공개 폴더 생성.

라우팅 시스템에서 제외되며, 해당 폴더와 하위 폴더들은 라우팅에서 제외된다.

- UI 로직과 라우팅 로직을 분리할 때
- 프로젝트 및 Next.js 생태계 전반에서 내부 파일을 일관되게 구성할 때
- 코드 에디터에서 파일을 정렬하거나 그룹화할 때
- 향후 Next.js 파일 컨벤션과 잠재적 네이밍 충돌 방지

<aside>
🌟

알아두면 좋은 점

- 프레임워크의 관례는 아니지만, 비공개 폴더 외부에 있는 파일도 동일한 밑줄(`_`) 패턴을 사용하여 "비공개"로 표시하는 것을 고려할 수 있다.
- URL 세그먼트가 밑줄로 시작해야 하는 경우, 폴더 이름에 URL 인코딩된 값인 `%5F`를 붙여 사용할 수 있다. `%5FfolderName`
</aside>

### 1.2.2 라우트 그룹

폴더 이름을 괄호로 감싸면 라우트 그룹을 생성할 수 있다.

구조적 목적으로만 사용되며, 라우트의 URL 경로에 포함되지 않음을 나타낸다.

- 사이트 섹션, 의도, 팀별로 라우트를 그룹화
- 동일한 세그먼트 레벨 내에서 중첩된 레이아웃 생성
  - 여러 중첩 레이아웃 생성
  - 공통 세그먼트 내 일부 라으트에 레이아웃 추가

### 1.2.3 `src` 디렉토리

Next.js는 애플리케이션 코드(`app` 을 포함해서)를 선택적으로 src 디렉토리 안에 저장하는 것을 지원한다.

이는 프로젝트 설정 파일(주로 루트에 위치)과 애플리케이션 코드를 분리한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/354d3a3a-777d-4d9b-b039-b0c49e0b028c/image.png)

### 1.2.4 module path aliases (모듈 경로 별칭)

Next.js는 모듈 경로에 대한 별칭을 정의할 수 있어, 깊이 중첩된 파일 간의 import를 읽고 유지 관리하기 쉽게 만든다.

## 프로젝트 구조화 전략

프로젝트 파일과 폴더를 구성하는 데 있어 정답은 없다.

중요한 점은 팀과 자신에게 적합한 전략을 선택하고 일관성을 유지하는 것이다.

1. app 디렉토리 외부에 프로젝트 파일 저장

   ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/d928a017-c496-4cfb-b795-029b8227d50e/image.png)

- 모든 코드를 프로젝트 루트에 공유 폴더로 저장하고, app 하위는 순전히 라우팅 목적으로만 사용

1. app 내부의 상위 폴더에 프로젝트 파일 저장

   ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/1e88fc21-2db1-45ca-8325-7ff52e55776a/image.png)

   - 모든 코드를 app 폴더 내부의 공유 폴더에 저장

2. 기능 또는 라우트 별로 프로젝트 파일 분리

   ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/61dff1a8-614f-478f-8d74-af3a902ffdcd/image.png)

   - 전역적으로 공유되는 코드는 루트 app 폴더에 저장하고, 더 구체적인 코드는 이를 사용하는 라우트 세그먼트로 나누어 저장

# 2. Dynamic Routes

동적 라우팅은 특정 경로 세그먼트 이름을 알 수 없을 때 사용한다. 동적 데이터로부터 생성된 경로를 생성하고, 요청 시점에 세그먼트를 채우거나 빌드 시점에 프리 렌더링할 수 있다.

## 2.1 컨벤션

동적 세그먼트는 폴더 이름을 대괄호로 감싸는 방식으로 생성할 수 있다.

- [id]
- [slug]

동적 세그먼트는 `layout` , `page`, `route`, 그리고 `generateMetadata` 함수에 props로 전달된다.

### 예시

블로그 프로젝트를 예로 들면, `app/blog/[slug]/page.js` 경로에서 `[slug]` 는 블로그 게시글의 동적 세그먼트 역할을 한다.

```jsx
export default function Page({ params }: { params: { slug: string } }) {
  return <div>My Post: {params.slug}</div>;
}
```

## 2.2 정적 매개변수(Static Params) 생성

`generateStaticParams` 함수는 동적 세그먼트와 함께 사용하여 빌드 시점에 정적 경로를 생성할 수 있다.

```jsx
// app/blog/[slug]/page.tsx

export async function generateStaticParams() {
  const posts = await fetch("https://.../posts").then((res) => res.json());

  return posts.map((post) => ({
    slug: post.slug,
  }));
}
```

`generateStaticParams` 함수의 장점은 fetch 요청을 통해 가져온 데이터를 자동으로 메모이제이션 해준다는 것이다. 동일한 인수에 대해서 `generateStaticParams`, layouts, pages에서 호출될 경우 한 번만 요청된다.

## 2.3 Catch-all Segments

`[...folderName]` 와 같이 대괄호 내부에 줄임표 (…)를 추가하면 특정 세그먼트 이후 모든 경로를 포착할 수 있다.

`app/shop/[...slug]/page.js` 는 아래와 같은 경로와 매칭된다.

- `/shop/clothes`
- `/shop/clothes/tops`
- `/shop/clothes/tops/t-shirts` 등

| **Route**                    | **Example URL** | **`params`**                |
| ---------------------------- | --------------- | --------------------------- |
| `app/shop/[...slug]/page.js` | `/shop/a`       | `{ slug: ['a'] }`           |
| `app/shop/[...slug]/page.js` | `/shop/a/b`     | `{ slug: ['a', 'b'] }`      |
| `app/shop/[...slug]/page.js` | `/shop/a/b/c`   | `{ slug: ['a', 'b', 'c'] }` |

## 2.4 Optional Catch-all Segments

Catch-All 세그먼트를 선택적으로 만들려면 대괄호를 한 번 더 감싸 `[[...folderName]]` 형태로 정의한다.

:`app/shop/[[...slug]]/page.js`는 다음과 같은 경로와 매칭된다.

- `/shop`
- `/shop/clothes`
- `/shop/clothes/tops`
- `/shop/clothes/tops/t-shirts`

### 차이점

- Catch-All: 매개변수가 필요. (`/shop` 은 매칭되지 않음)
- Optional Catch-All: 매개변수가 없어도 경로가 매칭. (`/shop` 포함)

| **Route**                      | **Example URL** | **`params`**                |
| ------------------------------ | --------------- | --------------------------- |
| `app/shop/[[...slug]]/page.js` | `/shop`         | `{}`                        |
| `app/shop/[[...slug]]/page.js` | `/shop/a`       | `{ slug: ['a'] }`           |
| `app/shop/[[...slug]]/page.js` | `/shop/a/b`     | `{ slug: ['a', 'b'] }`      |
| `app/shop/[[...slug]]/page.js` | `/shop/a/b/c`   | `{ slug: ['a', 'b', 'c'] }` |

## 2.5 TypeScript

설정한 라우트 세그먼트에 따라 params 타입을 정의한다.

| **Route**                           | **`params` Type Definition**             |
| ----------------------------------- | ---------------------------------------- |
| `app/blog/[slug]/page.js`           | `{ slug: string }`                       |
| `app/shop/[...slug]/page.js`        | `{ slug: string[] }`                     |
| `app/shop/[[...slug]]/page.js`      | `{ slug?: string[] }`                    |
| `app/[categoryId]/[itemId]/page.js` | `{ categoryId: string, itemId: string }` |

# 3. Parallel Routes (병렬 라우트)

동일한 레이아웃 내에서 하나 이상의 페이지를 동시에 또는 조건부로 렌더링할 수 있게 해준다.

대시보드나 소셜 사이트의 피드처럼 동적으로 변하는 섹션에서 유용하다.

예를 들어, 대시보드에서 parallel route를 사용하여 팀 페이지와 분석 페이지를 동시에 렌더링할 수 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/12b40496-a512-4020-9637-1c0cbf9512c3/image.png)

## 3.1 Slots

parallel route는 named slots을 사용하여 생성된다. 슬롯은 `@folder` 와 같은 규칙으로 정의된다.

예를 들어, 다음 파일 구조는 `@analytics` 와 `@team` 이라는 두 슬롯을 정의한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/e602ac17-a6ef-49f5-b418-369b917b84c2/image.png)

### parallel route 파일 시스템 구조

슬롯은 공유된 부모 레이아웃에 props로 전달된다.

위 예시의 경우, `app/layout.js` 안의 컴포넌트가 `@analytics` 와 `@team` 슬롯 props를 받고, `children` 과 함께 병렬적으로 같이 렌더링할 수 있다.

```tsx
export default function Layout({
  children,
  team,
  analytics,
}: {
  children: React.ReactNode;
  analytics: React.ReactNode;
  team: React.ReactNode;
}) {
  return (
    <>
      {children}
      {team}
      {analytics}
    </>
  );
}
```

슬롯은 라우트 세그먼트가 아니므로 URL 구조에 영향을 주지 않는다.

예를 들어, `/@analytics/views`의 URL은 `/views` 이다. 여기서 `@analytics` 는 슬롯이므로 URL에 포함되지 않는다.

<aside>
🌟

**알아두면 좋은 점**

`children` prop은 묵시적인 슬롯(implicit slot)으로, 폴더와 매핑할 필요가 없다.

따라서, `app/page.js` 는 `app/@children/page.js` 와 동일하다.

</aside>

## 3.2 Active state and navigation (활성 상태와 내비게이션)

기본적으로 Next.js는 각 슬롯의 활성 상태를 추적한다.

다만, 슬롯 내에서 렌더링된 콘텐츠는 탐색 유형에 따라 달라진다.

- 소프트 내비게이션:
  - 클라이언트 사이드에서 탐색 시, Next.js는 슬롯 내 서브 페이지를 변경하면서 부분적으로 렌더링한다. 이때, URL과 일치하지 않는 슬롯의 활성 서브페이지는 그대로 유지된다.
- 하드 내비게이션:
  - 전체 페이지가 새로고침되면, URL과 일치하지 않는 슬롯의 활성 상태를 Next.js가 파악할 수 없다.
  - 이 경우, 해당 슬롯의 `default.js` 파일을 렌더링하거나, `default.js` 가 없으면 404 페이지가 렌더링된다.
  - 일치하지 않는 라우트에 대해 404를 렌더링함으로써, Parallel route가 의도되지 않은 페이지에서 잘못 렌더링되는 것을 방지한다.

## 3.3 default.js

`default.js` 파일을 정의하여 초기 로드나 전체 새로고침 시 일치하지 않는 슬롯에 대한 폴백을 렌더링할 수 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/56fd26d3-3be4-46b1-85ae-28d8a8e0f978/image.png)

위의 예시에서, `@team` 슬롯에는 `/settings` 페이지가 있지만, `@analytics` 슬롯에는 없다.

- `/settings` 로 이동 시, `team` 슬롯은 `/settings` 페이지를 렌더링하고, `@analytics` 슬롯은 현재 활성 상태의 페이지를 유지한다.
- 새로고침 시, Next.js는 `@analytics` 슬롯에 대해 `default.js` 를 렌더링한다. 만약 `default.js` 가 없으면 404가 렌더링된다.
- children은 묵시적 슬롯이므로, 부모 페이지의 활성 상태를 복구할 수 없을 때 사용할 폴백을 제공하려면 `default.js` 파일을 생성해야 한다.

## 3.4 `useSelectedLayoutSegment(s)` 훅

`useSelectedLayoutSegment`와 `useSelectedLayoutSegments`는 **parallelRoutesKey** 매개변수를 받아 슬롯 내 활성 라우트 세그먼트를 읽을 수 있게 한다.

```tsx
// app/layout.tsx
"use client";

import { useSelectedLayoutSegment } from "next/navigation";

export default function Layout({ auth }: { auth: React.ReactNode }) {
  const loginSegment = useSelectedLayoutSegment("auth");
  // ...
}
```

유저가 `app/@auth/login` 로 이동시, `loginSegment` 는 “login” 문자열과 동일해질 것이다.

## 3.5 Examples

### 3.5.1 Conditonal Routes (조건부 라우트)

parallel route를 사용하여 특정 조건(예를 들어, 사용자 역할)에 따라 라우트를 조건부로 렌더링할 수 있다.

예를 들어, `/admin` 또는 `/user` 역할에 따라 대시보드 페이지를 다르게 렌더링한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/baf7f5e0-04ea-481e-a061-c29d0c78f4bc/image.png)

```tsx
import { checkUserRole } from "@/lib/auth";

export default function Layout({
  user,
  admin,
}: {
  user: React.ReactNode;
  admin: React.ReactNode;
}) {
  const role = checkUserRole();
  return <>{role === "admin" ? admin : user}</>;
}
```

### 3.5.2 Tab Groups

슬롯 내에 레이아웃을 추가하여 사용자가 슬롯을 독립적으로 탐색할 수 있도록 한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/30d8daf6-cd4b-4612-a34a-fcda238935e2/image.png)

```tsx
// app/@analytics/layout.tsx

import Link from "next/link";

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        {/* 탭 네비게이션 */}
        <Link href="/page-views">Page Views</Link>
        <Link href="/visitors">Visitors</Link>
      </nav>
      {/* 현재 활성화된 서브페이지 렌더링 */}
      <div>{children}</div>
    </>
  );
}
```

- Link 컴포넌트를 사용해 각 탭에 서브 페이지들을 연결한다.
- children은 현재 활성화된 페이지(서브 페이지)를 나타낸다.
  - 사용자가 page-views를 클릭하면 `app/@analytics/page-views/page.tsx` 콘텐츠가 렌더링된다.

**동작 방식**

사용자가 page-views로 이동하면

- URL: `/page-views`
- chidlren에는 `app/@anayltics/page-views/page.tsx` 렌더링
- nav는 그대로 유지되고, Page Views 탭이 활성화 됨.

슬롯(`@analytics` )의 서브 페이지 간 탐색을 가능하게 하면서도, 부모 레이아웃(layout.tsx) 구조를 유지한다.

탭이 단순히 페이지 전환만 처리한다면 병렬 라우트 대신 라우트 그룹으로 충분함.

탭 그룹이 다른 병렬 슬롯들과 독립적으로 렌더링될 필요가 없다면 parallel 라우트는 불필요한 복잡성을 초래할 수있음.

슬롯 간 상태를 독립적으로 유지하고, 조건부 렌더링 등 복잡한 처리가 필요하다면 parallel route가 적합함.

- ⭐️ 실습 (라우트그룹 vs paralel route 각 방식으로 탭 그룹 만들고, 상태 독립 관리 이해하기)
  아래는 탭 그룹을 예시로 **상태가 독립적으로 관리되는지 확인할 수 있는 실습 코드**를 제공합니다. 이 코드는 **라우트 그룹**과 **병렬 라우트**를 각각 구현한 뒤, 각 탭의 상태(예: 카운터)를 독립적으로 관리하는지를 비교할 수 있게 작성되었습니다.
  ***
  ## **1. 라우트 그룹으로 구현한 탭 그룹**
  ### 파일 구조
  ```
  plaintext
  복사편집
  app/
  ├── (tabs)/
  │   ├── page-views/
  │   │   └── page.tsx
  │   └── visitors/
  │       └── page.tsx
  └── layout.tsx

  ```
  ### 코드
  **`app/layout.tsx`**
  ```tsx
  typescript;
  복사편집;
  import Link from "next/link";

  export default function Layout({ children }: { children: React.ReactNode }) {
    return (
      <>
        <nav>
          <Link href="/page-views">Page Views</Link>
          <Link href="/visitors">Visitors</Link>
        </nav>
        <div>{children}</div>
      </>
    );
  }
  ```
  **`app/(tabs)/page-views/page.tsx`**
  ```tsx
  typescript;
  복사편집;
  ("use client");
  import { useState } from "react";

  export default function PageViews() {
    const [count, setCount] = useState(0);

    return (
      <div>
        <h1>Page Views</h1>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
  }
  ```
  **`app/(tabs)/visitors/page.tsx`**
  ```tsx
  typescript;
  복사편집;
  ("use client");
  import { useState } from "react";

  export default function Visitors() {
    const [count, setCount] = useState(0);

    return (
      <div>
        <h1>Visitors</h1>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
  }
  ```
  ### 동작 확인
  1. `/page-views`에서 카운터를 증가시키면, 상태가 증가합니다.
  2. `/visitors`로 이동하면 상태는 초기화됩니다.
     - **라우트 그룹은 상태를 유지하지 않습니다.**
     - 상태가 컴포넌트 단위로 새로 렌더링되기 때문입니다.
  ***
  ## **2. 병렬 라우트로 구현한 탭 그룹**
  ### 파일 구조
  ```
  plaintext
  복사편집
  app/
  ├── @tabs/
  │   ├── page-views/
  │   │   └── page.tsx
  │   ├── visitors/
  │   │   └── page.tsx
  │   └── default.js
  └── layout.tsx

  ```
  ### 코드
  **`app/layout.tsx`**
  ```tsx
  typescript;
  복사편집;
  export default function Layout({ tabs }: { tabs: React.ReactNode }) {
    return (
      <>
        <nav>
          <a href="/page-views">Page Views</a>
          <a href="/visitors">Visitors</a>
        </nav>
        <div>{tabs}</div>
      </>
    );
  }
  ```
  **`app/@tabs/page-views/page.tsx`**
  ```tsx
  typescript;
  복사편집;
  ("use client");
  import { useState } from "react";

  export default function PageViews() {
    const [count, setCount] = useState(0);

    return (
      <div>
        <h1>Page Views</h1>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
  }
  ```
  **`app/@tabs/visitors/page.tsx`**
  ```tsx
  typescript;
  복사편집;
  ("use client");
  import { useState } from "react";

  export default function Visitors() {
    const [count, setCount] = useState(0);

    return (
      <div>
        <h1>Visitors</h1>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
  }
  ```
  **`app/@tabs/default.js`**
  ```tsx
  typescript;
  복사편집;
  export default function Default() {
    return <h1>Select a Tab</h1>;
  }
  ```
  ### 동작 확인
  1. `/page-views`에서 카운터를 증가시키면 상태가 증가합니다.
  2. `/visitors`로 이동한 뒤, 다시 `/page-views`로 돌아오면 상태가 유지됩니다.
     - **병렬 라우트는 슬롯 간 상태를 독립적으로 유지합니다.**
     - 각 슬롯이 독립적으로 관리되기 때문입니다.
  ***
  ## **3. 라우트 그룹과 병렬 라우트의 차이 비교**
  | 특징                          | 라우트 그룹                           | 병렬 라우트                                     |
  | ----------------------------- | ------------------------------------- | ----------------------------------------------- |
  | 상태 초기화 여부              | 다른 탭으로 이동하면 상태가 초기화됨. | 다른 탭으로 이동해도 상태가 유지됨.             |
  | 독립 상태 유지                | 불가능.                               | 가능.                                           |
  | 각 탭의 독립적 관리 필요 여부 | 단순한 페이지 전환에 적합.            | 상태나 데이터를 개별적으로 관리해야 할 때 적합. |

### 3.5.3 Modals

intercepting routes와 함께 모달을 구현할 수 있다.

1. URL을 통해 모달 콘텐츠 공유 가능.
2. 페이지가 새로고침 되어도 문맥(Context)를 유지하며 모달이 닫히지 않음.
3. 뒤로가기 시 이전 경로로 이동하지 않고 모달을 닫을 수 있음.
4. 앞으로 가기 시 모달을 다시 열 수 있음.

사용자가 레이아웃에서 클라이언트 사이드 네비게시녀을 통해 로그인 모달을 열거나, 별도의 `/login` 페이지에 접근할 수 있는 UI 패턴을 고려한다.

- ⭐️ TODO: 실습

## 3.6 Loading and Error UI

parallel route는 각 슬롯을 독립적으로 스트리밍할 수 있으므로, 로드 중 또는 에러 상태를 슬롯별로 정의할 수 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a43c8b7f-e77d-47de-a59c-f74de1fb0eee/6b6bf943-54e3-483f-a199-ab22b3517295/image.png)

# 4. Intercepting Routes

인터셉팅 라우트는 애플리케이션의 다룬 부분에 있는 경로를 현재 레이아웃 내에서 로드할 수 있게 해준다.

사용자가 다른 context로 전환하지 않으면서 특정 경로의 콘텐츠를 표시하고 싶을 때 유용하다.

예를 들어,

- 사용자가 피드에서 사진 클릭 시 사진 모달이 표시되고, 피드 위에 오버레이 된다.
- 이때 Next.js는 사진 경로를 인터셉트하여 URL은 변경하지만, 기존 피드 위에 모달을 오버레이로 레넏링한다.

## 컨벤션

`(..)` 규칙을 사용한다. 경로 세그먼트에 대해서만 작동한다.

1. **(.)**: 같은 레벨의 세그먼트에 매칭.
2. **(..)**: 한 레벨 위의 세그먼트에 매칭.
3. **(..)(..)**: 두 레벨 위의 세그먼트에 매칭.
4. **(...)**: 애플리케이션 루트(`app` 디렉토리)부터 매칭.

<aside>
🌟

**알아두면 좋은 점**
인터셉팅 라우트는 레이아웃을 유지하면서도 특정 콘텐츠를 오버레이하는데 강력한 기능을 제공한다.

1. 로그인 모달: 상단 네비게이션 바에서 열리지만, `/login` 전용 페이지도 지원.
2. 장바구니 모달: 사이드바에서 열리지만, `/cart` 전용 페이지도 지원.
</aside>

# 5. Route Handlers

Route handlers는 주어진 경로에 대해 웹 요청(Request) 및 응답(Response) API를 사용하여 커스텀 요청 핸들러를 생성할 수있도로 한다.

## 5.1 Route.js 파일

Route handlers는 app 디렉토리 내에서만 사용할 수 있다. pages 디렉토리의 API Routes와 동등하며, 두 가지를 함께 사용할 필요는 없다.

<aside>
🌟

**Route handlers vs API Routes**

1. API Route는 하나의 파일에서 모든 메서드를 분기하지만, Route Handlers는 각 메서드를 함수로 명시함.
2. Route Handlers는 기본 캐싱(특히 GET)과 `NextRequest/NextResponse` 확장 기능을 지원.
3. 둘 다 서버 로직을 담당하지만, Route Handlers가 스트리밍 지원 등 더 확장성 있는 유틸 제공.
</aside>

### 컨벤션

- `route.js/ts` 로 파일을 정의한다.
- `page.js` 와 동일한 라우트 세그먼트 레벨에 `route.js` 파일이 존재할 수 없다.

## 5.2 지원되는 HTTP 메서드

- **GET**, **POST**, **PUT**, **PATCH**, **DELETE**, **HEAD**, **OPTIONS**
  - 지원되지 않는 메서드를 호출하면 **405 Method Not Allowed** 응답이 반환됨.

## 5.3 확장된 NextRequest 및 NextResponse API

기본 **Request** 및 **Response** 외에도 **NextRequest**와 **NextResponse**를 확장하여 제공한다. (Web API에 추가적인 편리한 메서드들을 확장한 것이라고 이해하면 됨.)

## 5.4 동작

### **캐싱**

**GET 메서드** 에서 Response 객체를 사용할 경우, Route Handlers는 기본적으로 캐싱된다.

```tsx
// app/items/route.ts
export async function GET() {
  const res = await fetch("https://data.mongodb-api.com/...", {
    headers: {
      "Content-Type": "application/json",
      "API-Key": process.env.DATA_API_KEY,
    },
  });
  const data = await res.json();

  return Response.json({ data });
}
```

- `Response.json()`은 TypeScript 5.2 이상에서만 사용 가능하다. 이전 버전에서는 `NextResponse.json()`을 사용하여 타이핑된 응답을 사용할 수 있다.

### 캐싱 비활성화

1. GET 메서드에서 `Request` 객체를 사용하는 경우.
2. 다른 HTTP 메서드를 사용하는 경우.
3. 쿠키, 헤더 같은 동적 기능을 사용하는 경우.
4. Segment Config Options 에서 동적 모드를 수동으로 지정하는 경우.

### POST 요청

POST 메서드는 Route Handler를 동적으로 평가하도록 만든다.

## 5.5 예시

### 1. 캐시된 데이터 재검증

`next.revalidate` 옵션을 사용한다.

```tsx
// app/items/route.ts
export async function GET() {
  const res = await fetch("https://data.mongodb-api.com/...", {
    next: { revalidate: 60 }, // 60초마다 재검증
  });
  const data = await res.json();

  return Response.json(data);
}
```

### 2. Dynamic Functions

**Cookies**

`next/headers` 에서 제공하는 `cookies` 를 사용해 쿠키를 읽거나 설정할 수 있다.

```tsx
// app/api/route.ts
import { cookies } from "next/headers";

export async function GET(request: Request) {
  const cookieStore = cookies();
  const token = cookieStore.get("token");

  return new Response("Hello, Next.js!", {
    status: 200,
    headers: { "Set-Cookie": `token=${token.value}` },
  });
}
```

**Headers**

`headers` 를 사용해 헤더를 읽을 수 있으며, 새로운 헤더를 설정하려면 `Response` 를 반환해야 한다.

```tsx
// app/api/route.ts
import { headers } from "next/headers";

export async function GET(request: Request) {
  const headersList = headers();
  const referer = headersList.get("referer");

  return new Response("Hello, Next.js!", {
    status: 200,
    headers: { referer: referer },
  });
}
```

### 3. Redirects

`redirect` 함수를 사용해 요청을 다른 경로로 리다이렉트 할 수 있다.

```tsx
// app/api/route.ts
import { redirect } from "next/navigation";

export async function GET(request: Request) {
  redirect("https://nextjs.org/");
}
```

### 4. Dynamic Route Segments (동적 라우트 세그먼트)

```tsx
// app/items/[slug]/route.ts
export async function GET(
  request: Request,
  { params }: { params: { slug: string } }
) {
  const slug = params.slug; // 'a', 'b', or 'c'
}
```

### 5. URL Query Parameters

`NextRequest` 객체의 메서드를 사용해 쿼리 파라미터를 쉽게 처리 할 수 있다.

```tsx
// app/api/search/route.ts
import { type NextRequest } from "next/server";

export function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const query = searchParams.get("query"); // URL: /api/search?query=hello
}
```

### 6. Streaming

```tsx
// app/api/chat/route.ts
import OpenAI from "openai";
import { OpenAIStream, StreamingTextResponse } from "ai";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(req: Request) {
  const { messages } = await req.json();
  const response = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    stream: true,
    messages,
  });

  const stream = OpenAIStream(response);

  return new StreamingTextResponse(stream);
}
```

### 7. Request Body

표준 Web API 메서드를 사용하는 `Request` body를 읽을 수 있다.

```tsx
export async function POST(request: Request) {
  const res = await request.json();
  return Response.json({ res });
}
```

### 8. Request Body FormData

request.formData를 통해, FormData를 읽을 수 있다.

formData는 모두 문자열이기 때문에, 요청을 검증하기 위해서 [**`zod-form-data`**](https://www.npmjs.com/package/zod-form-data) 를 사용하여 검증하고, number와 같은 원하는 포맷으로 데이터를 얻을 수 있다.

### 9. CORS

표준 Web API 메서드를 사용하여 특정 라우트 핸들러에 CORS 헤더를 설정할 수 있다.

- 만약 여러 라우트 핸들러에 CORS 헤더를 추가하고 싶다면, Middleware 혹은 next.config.js 파일을 사용할 수 있다.
-

```tsx
export const dynamic = "force-dynamic"; // defaults to auto

export async function GET(request: Request) {
  return new Response("Hello, Next.js!", {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
    },
  });
}
```

### 10. Webhooks

써드파티 서비스로부터 웹훅을 받기 위해 라우트 핸들러를 사용할 수 있다.

Page Router의 API Routes와 다르게, Route Handler에서는 bodyParser을 사용할 필요가 없다.

즉 추가 설정 없이 request 객체로부터 데이터를 가져올 수 있다.

### 11. Edge and Node.js Runtimes

Route Handler는 Edge와 Node.js 런타임 모두를 매끄럽게 지원하기 위해 동형(isomorphic) Web API를 제공한다. 여기에는 스트리밍 기능 지원도 포함된다.

또한 Pages와 Layouts와 동일한 라우트 세그먼트 설정 방식을 사용하므로, 일반적인 정적 재생성(SSR) Route hander와 같은 오랫동안 대기하던 기능도 지원할 수 있다.

런타임을 직접 지정하려면 runtime 세그먼트 설정 옵션을 사용할 수 있다.

```tsx
export const runtime = "edge"; // 기본값은 'nodejs'
```

### 12. Non-UI Responses

`sitemap.xml` , `robots.txt`, `app icons` , open graph images와 같은 UI가 없는 콘텐츠를 반환할 수 있다.

```tsx
export const dynamic = "force-dynamic"; // defaults to auto

export async function GET() {
  return new Response(
    `<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
 
<channel>
  <title>Next.js Documentation</title>
  <link>https://nextjs.org/docs</link>
  <description>The React Framework for the Web</description>
</channel>
 
</rss>`,
    {
      headers: {
        "Content-Type": "text/xml",
      },
    }
  );
}
```

### 13. Segment Config Options

Route handlers는 pages와 layouts과 똑같은 라우트 세그먼트 설정을 사용한다.

```tsx
export const dynamic = "auto";
export const dynamicParams = true;
export const revalidate = false;
export const fetchCache = "auto";
export const runtime = "nodejs";
export const preferredRegion = "auto";
```

# 6. Middleware

미들웨어를 사용하면 요청이 완료되기 전에 코드를 실행할 수 있다.

이렇게 해서 들어오는 요청을 기반으로, 응답을 수정하거나 재작성(rewriting), 리디렉션(redirecting), 요청 혹은 응답 헤더 수정, 또는 직접 응답을 반환하는 등의 작업을 수행할 수 있다.

미들웨어는 캐시된 콘텐츠가 전달되고 라우트가 매칭되기 전에 실행된다.

즉, 사용자가 요청한 페이지나 API가 최종적으로 결정(매칭)되어 응답하기 전에, 그리고 이미 캐시되어 있는 콘텐츠를 Next.js가 바로 반환하기 전에 , 미들웨어가 먼저 요청을 가로채어 로직을 처리한다는 뜻이다.

## 6.1 사용 사례

애플리케이션에 미들웨어를 통합하면 성능, 부안, 사용자 경험 측면에서 크게 향상될 수 있다.

1. 인증 및 권한 부여 (Authentication and Authorization)
   - 특정 페이지나 API 라우트에 접근하기 전, 사용자 신원 확인 및 세션 쿠키 검사.
2. 서버 사이드 리다이렉트 (Server-Side Redirects)
   - 특정 조건(예: locale, 사용자 역할)에 따라 서버 레벨에서 사용자 리다이렉트.
3. 경로 재작성 (Path Rewriting)
   - A/B 테스트, 기능 롤아웃, 레거시 경로 지원 등을 위해 요청 속성에 따라 경로를 동적으로 재작성해 API 라우트나 페이지로 연결.
4. 봇 감지(Bot Detection)
   - 봇 트래픽을 탐지하고 차단하여 리소스 보호.
5. 로깅 및 분석
   - 페이지나 API가 요청을 처리하기 전, 요청 데이터를 캡처하고 분석.
6. 기능 플래깅
   - 기능을 동적으로 활성/비활성화하여 원활한 기능 롤아웃 혹은 테스트 구현.

**반면, 미들웨어가 최적의 접근이 아닌 경우도 있다.**

- 복잡한 데이터 페칭 및 조작
  - 미들웨어는 직접적인 데이터 페칭이나 조작을 위해 설계되지 않았다. 이런 작업은 Route Handlers나 서버 사이드 유틸리티에서 처리해야 한다.
- 고비용 계산 작업
  - 미들웨어는 가벼우며 빠르게 응답해야 한다. 무거운 계산이나 오래 걸리는 프로세스는 전용 Route handlers에서 처리하는 것이 좋다.
- 대규모 세션 관리
  - 미들웨어로 간단한 세션 작업은 가능하지만, 규묘가 큰 세션 관리는 인증 서비스나 Route Handlers에서 전담하는 것이 권장된다.
- 직접적인 데이터베이스 작업
  - 미들웨어 안에서 데이터베이스 연산을 직접 수행하는 것은 권장되지 않는다. 데이터베이스 연산은 Route Handlers나 서버 사이드 유틸리티 내에서 처리하자.

## 6.2 컨벤션

프로젝트 루트에 `middleware.ts/js` 파일을 만들어 미들웨어를 정의한다.

프로젝트당 오직 하나의 미들웨어 파일만 지원된다. 그러나, 미들웨어 로직을 모듈 단위로 분리한 뒤, 각 기능별 .ts 파일로 나눈 다음, 메인 middleware 파일에서 불러와 사용할 수 있다.

이렇게 하면 라우트 별 미들웨어 로직을 효율적으로 구성하고, 미들웨어 파일에서 중앙집중적으로 관리할 수 있다.

미들웨어 파일이 하나라는 점은 설정을 단순화하고, 중복이나 충돌을 방지하며, 여러 미들웨어 레이어가 생성될 때 발생하는 성능 문제를 피하는 장점이 있다.

## 6.3 Matching Paths

미들웨어는 프로젝트 내 모든 겨올에 대해 호출된다. 따라서 특정 라우트를 대상으로 삼거나(혹은 제외하려면), 매처(matcher)를 사용하여 정확히 설정해야 한다.

실행 순서는 다음과 같다.

1. `next.config.js`의 `headers`
2. `next.config.js`의 `redirects`
3. **Middleware (재작성, 리디렉션 등)**
4. `next.config.js`의 `beforeFiles` (rewrites)
5. 파일시스템 라우트(`public/`, `_next/static/`, `pages/`, `app/` 등)
6. `next.config.js`의 `afterFiles` (rewrites)
7. **동적 라우트** (`/blog/[slug]`)
8. `next.config.js`의 `fallback` (rewrites)

- **⭐️ Next.js에서 요청이 처리되는 순차적인 과정 이해하기**
  ## **간단 예시 시나리오**
  ### **상황**
  사용자가 **`/old-route`** 주소로 접근한다. 이때 실제로 보여주고 싶은 페이지는 **`/new-route`**이지만, 접근 시 몇 가지 단계를 거치게 된다.
  1. **Headers**
     - 우선, `next.config.js`의 `headers` 설정을 확인한다.
     - `/old-route`에 대응되는 헤더 설정이 있다면, 해당 헤더를 **응답**에 추가하도록 준비한다. (하지만 실제 응답을 아직 내보내진 않는다.)
  2. **Redirects**
     - 이어서 `next.config.js`의 `redirects` 설정을 본다.
     - `/old-route`가 **`/new-route`로 리디렉션**되는 설정이 되어 있다면, **"아, 이 요청은 `/new-route`로 가야 하는구나"** 하고 **클라이언트에 301(또는 307) 리디렉션** 응답을 돌려줄 준비를 한다.
     - 이 시점에서, 만약 리디렉션이 발생하면, 사용자는 `/new-route`로 새롭게 요청을 보낸다.
  3. **Middleware**
     - 만약 2단계에서 리디렉션이 일어나지 않았다면, 이제 **미들웨어**가 실행된다.
     - 미들웨어는 **"이 요청이 `/old-route`네?** 그러면 `/another-route`로 재작성(Rewrite)하자"\*\* 같은 로직이 들어있을 수 있다.
     - 혹은 "로그인하지 않았으면 `/login`으로 리디렉션" 같은 인증 로직을 처리할 수도 있다.
  4. **BeforeFiles (Rewrites)**
     - 미들웨어를 통과하고 나면, **라우트 매칭 전에** `beforeFiles`에 설정된 **Rewrites**가 실행된다.
     - 여기서도 **"이 요청이 `/before-rewrite`면 `/rewritten-before` 경로로 바꿔준다"** 같은 규칙이 적용될 수 있다.
  5. **파일 시스템 라우트**
     - 이제 **실제** Next.js의 파일 구조( `pages/`, `app/`, `public/` 등)를 확인한다.
     - *`/new-route`*와 매칭되는 `pages/new-route.js`가 있으면 그 페이지를 렌더링한다.
     - 만약 매칭되는 파일이나 폴더가 없으면, 다음 단계로 넘어간다.
  6. **AfterFiles (Rewrites)**
     - 파일 시스템에서 매칭을 찾지 못한 경우에만 **afterFiles**가 동작한다.
     - 여기서도 재작성 규칙이 있으면 적용한다. 예: `/after-rewrite` → `/rewritten-after`.
  7. **동적 라우트**
     - 만약 위 단계를 모두 통과했지만, 동적 라우트(`/blog/[slug]`) 같은 것과 매칭될 수 있다면 여기서 처리한다.
     - 예: `/blog/some-post`가 실제 `/blog/[slug].js` 파일과 매칭되어 페이지를 렌더링할 수 있다.
  8. **Fallback (Rewrites)**
     - 끝까지 아무것도 매칭되지 않으면, 마지막에 `fallback` 규칙이 적용되어 예: `/fallback/anything` → `/404`로 재작성한다.
     - 최종적으로 **404** 페이지가 응답된다.
  ***
  ## **이 과정을 연결해 생각해 보기**
  1. **사용자**가 \**`/old-route`*로 요청
  2. **Headers 단계**: 이 경로에 설정된 헤더가 있으면 적용
  3. **Redirects 단계**: `next.config.js`에 `/old-route` → `/new-route` 리디렉트 규칙이 있다면 바로 301/307 응답
  4. 만약 **리디렉트가 없거나** 이미 `/new-route`로 바뀌었으면, **Middleware**에서 추가 검사 및 재작성
  5. **BeforeFiles**: 혹시 또 다른 재작성 규칙이 있으면 적용
  6. **파일 시스템 라우트**: `/new-route`에 해당하는 `pages/new-route.js`를 찾아 렌더링 (있다면)
  7. **AfterFiles**: 그래도 못 찾으면 afterFiles의 재작성 규칙 확인
  8. **동적 라우트**: `/blog/[slug]` 같은 동적 라우트가 맞을 수도 있으니 확인
  9. **Fallback**: 결국 모든 단계에서 매칭 실패 시 404나 특정 경로로 이동
  이렇게 흐름을 **한 번의 요청**에 대해 순서대로 생각해 보면:
  1. **"이 요청에 맞게 헤더 세팅할 거 있어?"**
  2. **"혹시 바로 리디렉션 시킬 거야?"**
  3. **"미들웨어에서 동적 로직(권한 체크 등) 실행할 거 있어?"**
  4. **"파일 찾기 전에 URL 재작성할 거 있어?"**
  5. **"파일 시스템에 일치하는 페이지나 정적 파일 있어?"**
  6. **"파일 없으면 afterFiles에서 재작성할 거?"**
  7. **"동적 라우트가 매칭되는지 확인할까?"**
  8. **"정말 아무것도 없으면 fallback으로 404 처리"**
  ***
  ## **정리**
  - **왜 이 순서인지**:
    1. 최우선적으로 **헤더** 설정,
    2. **잘못된 경로**를 빠르게 **리디렉션**,
    3. **미들웨어**로 동적 처리,
    4. **정적 라우트 매칭** 전에 `beforeFiles`,
    5. **파일 시스템 매칭**,
    6. 매칭 실패 시 `afterFiles`,
    7. **동적 라우트**,
    8. 마지막에 **fallback**.
  - **실무**:
    - 인증/권한 체크, 다국어 리디렉션, A/B 테스트, 레거시 URL 정리, 정적 파일 서빙, 404 처리 등 다양한 부분에 이 로직이 활용됨.
    <aside>
    🌟
    
    **역할 정리**
    
    - **headers** (next.config.js)
        - 응답 헤더를 미리 세팅하여 **보안, 캐싱 정책** 등을 설정한다.
    - **redirects** (next.config.js)
        - 잘못된 경로를 **새로운 경로**로 이동시켜 **SEO**와 **사용자 경험**을 개선한다.
    - **Middleware**
        - 요청을 가로채 **인증**, **A/B 테스트**, **권한 검사** 등을 동적으로 처리한다.
    - **beforeFiles (rewrites)**
        - 파일 시스템 매칭 전 **특정 경로**를 **우선적으로** 다른 경로로 바꾼다.
    - **파일 시스템 라우트**
        - Next.js의 **기본 라우팅**이 동작, `pages/`, `public/` 폴더 등에서 매칭을 시도한다.
    - **afterFiles (rewrites)**
        - 파일 시스템 매칭 실패 후 **추가적으로** 재작성 규칙을 적용한다.
    - **동적 라우트**
        - `/blog/[slug]` 같은 **동적 URL**을 처리해, 유연한 라우팅 구현한다.
    - **fallback (rewrites)**
        - 마지막까지 매칭되지 않으면 이 규칙이 적용되어, 보통 **404** 페이지로 처리한다.
    </aside>
    
    - 코드와 함께 이해하기
        
        ## **폴더 구조 예시**
        
        ```lua
        lua
        복사
        my-next-app/
        ├── next.config.js
        ├── middleware.ts
        └── pages/
            ├── about.js
            ├── new-route.js
            ├── rewritten-before.js
            ├── rewritten-after.js
            ├── fallback/
            │   └── index.js
            ├── blog/
            │   └── [slug].js
            └── 404.js
        
        ```
        
        - **`next.config.js`**: Headers, Redirects, Rewrites 설정
        - **`middleware.ts`**: 미들웨어 로직
        - **`pages/`**: 파일 시스템 라우트
            - `about.js`, `new-route.js` 등
            - `blog/[slug].js`: 동적 라우트 예시
            - `fallback/index.js`: fallback rewrites 예시
            - `404.js`: 404 페이지
        
        ---
        
        ## **1. next.config.js**
        
        **설명**
        
        1. **headers:** 특정 경로(`/about`)에 대해 응답 헤더를 설정.
        2. **redirects:** `/old-route` → `/new-route`로 리디렉션.
        3. **rewrites:**
            - **beforeFiles:** `/before-rewrite` → `/rewritten-before`
            - **afterFiles:** `/after-rewrite` → `/rewritten-after`
            - **fallback:** `/fallback/:path*` → `/404`
        
        ```
        js
        복사
        // next.config.js
        
        module.exports = {
          async headers() {
            return [
              {
                source: '/about',
                headers: [
                  { key: 'x-custom-header', value: 'my-custom-value' },
                  { key: 'Cache-Control', value: 'public, max-age=3600' },
                ],
              },
            ];
          },
        
          async redirects() {
            return [
              {
                source: '/old-route',
                destination: '/new-route',
                permanent: true, // 301 리디렉션
              },
            ];
          },
        
          async rewrites() {
            return {
              // (4) beforeFiles
              beforeFiles: [
                {
                  source: '/before-rewrite',
                  destination: '/rewritten-before',
                },
              ],
              // (6) afterFiles
              afterFiles: [
                {
                  source: '/after-rewrite',
                  destination: '/rewritten-after',
                },
              ],
              // (8) fallback
              fallback: [
                {
                  source: '/fallback/:path*',
                  destination: '/404',
                },
              ],
            };
          },
        };
        
        ```
        
        ### **어떤 순서로 적용되는가?**
        
        1. **headers** → 2. **redirects** → 3. (Middleware) → 4. **beforeFiles** → 5. **파일 시스템 라우트** → 6. **afterFiles** → 7. **동적 라우트** → 8. **fallback**
        
        ---
        
        ## **2. middleware.ts**
        
        **설명**
        
        - `/redirect-me`로 요청이 들어오면 `/redirected`로 리디렉션
        - `/rewrite-me`로 요청이 들어오면 `/rewritten`으로 재작성
        - 간단한 인증 로직 예시: `auth-token` 쿠키가 없으면 `/login`으로 리디렉션
        
        ```
        ts
        복사
        // middleware.ts
        import { NextResponse } from 'next/server';
        import type { NextRequest } from 'next/server';
        
        export function middleware(request: NextRequest) {
          const { pathname } = request.nextUrl;
        
          // (3) Middleware 단계 예시
          if (pathname === '/redirect-me') {
            // 리디렉션
            return NextResponse.redirect(new URL('/redirected', request.url));
          }
        
          if (pathname === '/rewrite-me') {
            // 재작성
            return NextResponse.rewrite(new URL('/rewritten', request.url));
          }
        
          // 인증 쿠키 유무 확인
          if (!request.cookies.has('auth-token') && pathname.startsWith('/member-only')) {
            return NextResponse.redirect(new URL('/login', request.url));
          }
        
          // 나머지 요청은 그대로 진행
          return NextResponse.next();
        }
        
        ```
        
        ---
        
        ## **3. 파일 시스템 라우트 (pages/)**
        
        ### **(5) 예시: /about**
        
        ```
        js
        복사
        // pages/about.js
        export default function About() {
          return <h1>About Page - 헤더가 추가됩니다.</h1>;
        }
        
        ```
        
        - `/about`으로 접근 시, `next.config.js`의 `headers` 설정에 따라 **`x-custom-header`*가 응답 헤더로 추가됨.
        
        ### **(5) 예시: /new-route**
        
        ```
        js
        복사
        // pages/new-route.js
        export default function NewRoute() {
          return <h1>This is the New Route Page</h1>;
        }
        
        ```
        
        - `/old-route` → `/new-route`로 **리디렉션(redirects)**
        - 리디렉션 후 여기서 페이지를 렌더링.
        
        ### **(5) 예시: /rewritten-before**
        
        ```
        js
        복사
        // pages/rewritten-before.js
        export default function RewrittenBefore() {
          return <h1>Page Rewritten Before Files</h1>;
        }
        
        ```
        
        - `/before-rewrite` → `/rewritten-before` (**beforeFiles**).
        
        ### **(5) 예시: /rewritten-after**
        
        ```
        js
        복사
        // pages/rewritten-after.js
        export default function RewrittenAfter() {
          return <h1>Page Rewritten After Files</h1>;
        }
        
        ```
        
        - `/after-rewrite` → `/rewritten-after` (**afterFiles**).
        
        ### **(5) 예시: /redirected**
        
        ```
        js
        복사
        // pages/redirected.js
        export default function Redirected() {
          return <h1>Redirected by Middleware</h1>;
        }
        
        ```
        
        - 미들웨어에서 `/redirect-me`를 `/redirected`로 리디렉션했을 때 렌더링되는 페이지.
        
        ### **(5) 예시: /rewritten**
        
        ```
        js
        복사
        // pages/rewritten.js
        export default function Rewritten() {
          return <h1>Rewritten by Middleware</h1>;
        }
        
        ```
        
        - 미들웨어에서 `/rewrite-me`를 `/rewritten`으로 재작성했을 때 렌더링되는 페이지.
        
        ### **(7) 동적 라우트 예시: /blog/[slug].js**
        
        ```
        js
        복사
        // pages/blog/[slug].js
        import { useRouter } from 'next/router';
        
        export default function BlogPost() {
          const router = useRouter();
          const { slug } = router.query;
        
          return <h1>Blog Slug: {slug}</h1>;
        }
        
        ```
        
        - `/blog/some-post` 등 동적 경로를 처리한다.
        
        ### **(8) fallback 예시: /fallback/index.js**
        
        ```
        js
        복사
        // pages/fallback/index.js
        export default function Fallback() {
          return <h1>This is the fallback page</h1>;
        }
        
        ```
        
        - `fallback` 설정에 따라 `/fallback/anything` → `/404` 대신 `/fallback/index.js`를 사용하고 싶다면,
            - 여기서 별도의 페이지를 렌더링하거나
            - 404 페이지로 안내하는 로직을 둘 수 있음.
        
        ### **(8) 404 페이지 예시: /404.js**
        
        ```
        js
        복사
        // pages/404.js
        export default function Custom404() {
          return <h1>404 - Page Not Found</h1>;
        }
        
        ```
        
        - **fallback** 단계에서 최종적으로 매칭되지 않는 경우 이 페이지가 렌더링된다.
        
        ---
        
        ## **동작 시나리오**
        
        1. **/about** → **Headers**
            - `x-custom-header: my-custom-value`가 응답 헤더에 추가됨.
            - 이후 파일 시스템 라우트(`pages/about.js`) 렌더링.
        2. **/old-route** → **Redirects**
            - `next.config.js`의 `redirects` 규칙으로 `/new-route`로 **301** 리디렉션.
        3. **/redirect-me** → **Middleware**
            - 미들웨어에서 `/redirected`로 **리디렉션**, 결과적으로 `pages/redirected.js` 렌더링.
        4. **/before-rewrite** → **beforeFiles**
            - 파일 시스템 라우트를 확인하기 전에 `/rewritten-before`로 재작성.
            - 최종적으로 `pages/rewritten-before.js` 렌더링.
        5. **파일 시스템 라우트**
            - `/images/logo.png` → `public/images/logo.png`
            - `/blog/my-post` → `pages/blog/[slug].js` (동적 라우트 전환은 (7) 단계에서 처리)
        6. **/after-rewrite** → **afterFiles**
            - 파일 시스템 라우트와 매칭되지 않는다면 → `/rewritten-after`로 재작성
            - `pages/rewritten-after.js` 렌더링.
        7. **동적 라우트**
            - `/blog/[slug]` 형태 요청 시, **정적 라우트**에 매칭되지 않으면(동적 매칭) `pages/blog/[slug].js`가 렌더링됨.
        8. **fallback**
            - 예: `/fallback/any-route`가 들어오면 `/404`로 재작성 → `pages/404.js` 렌더링
            - 모든 규칙에 매칭 실패 시 여기서 최종적으로 처리.

미들웨어가 실행될 경로를 정의하는 방법에는 2가지가 있다.

1. 커스텀 매처 설정
2. 조건문 사용

### 6.3.1 Matcher

`matcher` 옵션을 사용하면 특정 경로에만 미들웨어를 적용할 수 있다.

정규 표현식을 완전히 지원하므로 부정형 전방 탐색 등 문법을 사용할 수 있다.

단일 경로 또는 배열을 사용해 여러 경로 매칭도 가능하다.

matcher 값은 빌드 시점에 정적으로 분석 가능해야 하므로 상수로 선언해야 한다. 변수 같은 동적 값은 무시된다.

하위 호환성을 위해 Next.js는 항상 `/public` 을 `/public/index` 로 취급한다. 따라서 , `/public/:path` 매처는 정상적으로 매칭된다.

**Configured matchers 제약 조건:**

- 무조건 `/`로 시작해야 함
- \*이름 있는 파라미터(named parameters)\*\*를 사용할 수 있음예) `/about/:path`는 `/about/a`와 `/about/b`를 매칭하지만 `/about/a/c`는 매칭하지 않음
- \*파라미터에 수정자(modifier)\*\*를 붙일 수 있음
  - ``: 0개 이상
  - `?`: 0개 또는 1개
  - `+`: 1개 이상예) `/about/:path*`는 `/about/a/b/c`도 매칭
- **정규 표현식을 괄호로 감싸서 사용 가능**예) `/about/(.*)`는 `/about/:path*`와 동일

```tsx
// 특정 경로를 제외하고 모두 매칭하는 예시
export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
};

export const config = {
  matcher: [
    {
      source: "/((?!api|_next/static|_next/image|favicon.ico).*)",
      missing: [
        { type: "header", key: "next-router-prefetch" },
        { type: "header", key: "purpose", value: "prefetch" },
      ],
    },
    {
      source: "/((?!api|_next/static|_next/image|favicon.ico).*)",
      has: [
        { type: "header", key: "next-router-prefetch" },
        { type: "header", key: "purpose", value: "prefetch" },
      ],
    },
    {
      source: "/((?!api|_next/static|_next/image|favicon.ico).*)",
      has: [{ type: "header", key: "x-present" }],
      missing: [{ type: "header", key: "x-missing", value: "prefetch" }],
    },
  ],
};
```

### 6.3.2 조건문 사용

```tsx
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  if (request.nextUrl.pathname.startsWith("/about")) {
    return NextResponse.rewrite(new URL("/about-2", request.url));
  }

  if (request.nextUrl.pathname.startsWith("/dashboard")) {
    return NextResponse.rewrite(new URL("/dashboard/user", request.url));
  }
}
```

## 6.4 NextResponse

`NextResponse` API를 사용하여 다음 작업을 수행할 수 있다.

1. redirect: 들어오는 요청을 다른 URL로 리다이렉트
2. rewrite: 특정 URL을 표시하도록 응답 재작성
3. 요청 헤더 설정: API Routes, getServerSideProps, rewrite 대상 등에 헤더 추가
4. 응답 쿠키 설정
5. 응답 헤더 설정

미들웨어에서 응답을 생성하는 방법은 다음과 같다.

- 다른 라우트(페이지나 라우트 핸들러)로 rewrite 해서, 그 라우트가 응답을 생성하도록 함
- `NextResponse` 를 직접 반환

## 6.5 쿠키 사용

쿠키는 일반적인 헤더에 속한다. 요청에서는 `Cookie` 헤더를 통해, 응답에서는 `Set-Cookie` 헤더를 통해 전달된다.

Next.js는 `NextRequest`와 `NextResponse`의 cookies 확장을 통해 쿠키를 쉽게 다룰 수 있는 API를 제ㅐ공한다.

- **들어오는 요청**: `request.cookies`
  - `get`, `getAll`, `set`, `delete`, `has`, `clear` 등의 메서드
- **나가는 응답**: `response.cookies`
  - `get`, `getAll`, `set`, `delete` 메서드

```tsx
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  // 예: "Cookie: nextjs=fast" 헤더가 요청에 포함되어 있다고 가정
  let cookie = request.cookies.get("nextjs");
  console.log(cookie); // => { name: 'nextjs', value: 'fast', Path: '/' }
  const allCookies = request.cookies.getAll();
  console.log(allCookies); // => [{ name: 'nextjs', value: 'fast' }]

  request.cookies.has("nextjs"); // => true
  request.cookies.delete("nextjs");
  request.cookies.has("nextjs"); // => false

  // 응답에 쿠키를 설정
  const response = NextResponse.next();
  response.cookies.set("vercel", "fast");
  response.cookies.set({
    name: "vercel",
    value: "fast",
    path: "/",
  });
  cookie = response.cookies.get("vercel");
  console.log(cookie); // => { name: 'vercel', value: 'fast', Path: '/' }
  // 최종 응답 헤더에 `Set-Cookie: vercel=fast; path=/`가 추가됨

  return response;
}
```

## 6.6 헤더 설정

`NextResponse` AP를 사용해 요청 및 응답 헤더를 설정할 수 있다. (v13부터)

```tsx
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  // 요청 헤더 복사 후, `x-hello-from-middleware1` 헤더를 추가
  const requestHeaders = new Headers(request.headers);
  requestHeaders.set("x-hello-from-middleware1", "hello");

  // NextResponse.rewrite에서 요청 헤더를 설정할 수도 있음
  const response = NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  });

  // 응답 헤더 `x-hello-from-middleware2` 설정
  response.headers.set("x-hello-from-middleware2", "hello");
  return response;
}
```

주의: 너무 큰 헤더를 설정하면 431 Request Header Fields Too Large 오류가 발생할 수 있어, 서버 설정에 따라 주의가 필요하다.

## 6.7 CORS

미들웨어에서 CORS 헤더를 설정해 교차 출처 요청을 허용할 수 있다.

특정 라우트 핸들러에서도 CORS 헤더를 설정할 수 있다.

```tsx
// middleware.ts
import { NextRequest, NextResponse } from "next/server";

const allowedOrigins = ["https://acme.com", "https://my-app.org"];

const corsOptions = {
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
};

export function middleware(request: NextRequest) {
  // 요청의 Origin 확인
  const origin = request.headers.get("origin") ?? "";
  const isAllowedOrigin = allowedOrigins.includes(origin);

  // 사전 요청(OPTIONS) 확인
  const isPreflight = request.method === "OPTIONS";

  if (isPreflight) {
    const preflightHeaders = {
      ...(isAllowedOrigin && { "Access-Control-Allow-Origin": origin }),
      ...corsOptions,
    };
    return NextResponse.json({}, { headers: preflightHeaders });
  }

  // 일반 요청 처리
  const response = NextResponse.next();

  if (isAllowedOrigin) {
    response.headers.set("Access-Control-Allow-Origin", origin);
  }

  Object.entries(corsOptions).forEach(([key, value]) => {
    response.headers.set(key, value);
  });

  return response;
}

export const config = {
  matcher: "/api/:path*",
};
```

## 6.8 응답 생성

미들웨어에서 직접 응답을반환하려면, `Response` 또는 `NextResponse` 인스턴스를 반환하라. (v.13.1.0부터 가능)

```tsx
// middleware.ts
import { NextRequest } from "next/server";
import { isAuthenticated } from "@lib/auth";

// /api/ 경로로 시작하는 모든 요청에만 미들웨어 적용
export const config = {
  matcher: "/api/:function*",
};

export function middleware(request: NextRequest) {
  // 인증 함수로 요청 확인
  if (!isAuthenticated(request)) {
    // JSON 응답을 직접 반환 (401)
    return Response.json(
      { success: false, message: "authentication failed" },
      { status: 401 }
    );
  }
}
```

## 6.9 waitUntil과 NextFetchEvent

`NextFetchEvent` 객체는 기본 FetchEvent를 확장하며, `waitUntil()` 메서드를 제공한다.

- waitUntil 은 프라미스를 인자로 받아, 그 프라미스가 resolve될 때까지 미들웨어 수명을 확장한다.
- 백그라운드 작업을 수행하는데 유용하다.

```tsx
import { NextResponse } from "next/server";
import type { NextFetchEvent, NextRequest } from "next/server";

export function middleware(req: NextRequest, event: NextFetchEvent) {
  event.waitUntil(
    fetch("https://my-analytics-platform.com", {
      method: "POST",
      body: JSON.stringify({ pathname: req.nextUrl.pathname }),
    })
  );

  return NextResponse.next();
}
```

## 6.10 고급 미들웨어 플래그

v13.1에서 두가지 추가 플래그가 미들웨어에 도입됐다.

### 1. skipTrailingSlashRedirect

Next.js에서 기본적으로 URL에 슬래시가 누락되었거나 과도하게 붙은 경우 자동으로 리다이렉트를 수행한다.

이 옵션이 활성화되면 위 동작을 끄고, 미들웨어 내부에서 직접 처리할 수 있다.

```tsx
module.exports = {
  skipTrailingSlashRedirect: true,
};
```

```tsx
const legacyPrefixes = ["/docs", "/blog"];

export default async function middleware(req) {
  const { pathname } = req.nextUrl;

  if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {
    return NextResponse.next();
  }

  // 트레일링 슬래시 처리
  if (
    !pathname.endsWith("/") &&
    !pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)
  ) {
    req.nextUrl.pathname += "/";
    return NextResponse.redirect(req.nextUrl);
  }
}
```

### 2. skipMiddlewareUrlNormalize

이 옵션을 사용하면 Next.js의 URL 정규화를 비활성화하여, 직접 방문과 클라이언트 전환 간 동작을 동일하게 처리할수 있다.

## 6.11 런타임

미들웨어는 현재 엣지 런타임만 지원한다.
