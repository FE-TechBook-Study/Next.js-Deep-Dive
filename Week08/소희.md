# Bundle Analyzer

@next/bundle-analyzer는 Next.js에서 자바스크립트 모듈의 크기를 관리하는 데 도움이 되는 플러그인이다.

이 플러그인은 각 모듈과 해당 종속성의 크기에 대한 시각적 보고서를 생성한다.

이 정보를 활용하면 다음과 같은 작업을 수행할 수 있다.

- **큰 종속성 제거**
- **코드 분할 (Code Splitting)**
- **일부 모듈만 로드하여 클라이언트로 전송되는 데이터량 감소**

### 설치

```jsx
npm i @next/bundle-analyzer
# 또는
yarn add @next/bundle-analyzer
# 또는
pnpm add @next/bundle-analyzer
```

### **next.config.js 설정**

```jsx
const withBundleAnalyzer = require("@next/bundle-analyzer")({
  enabled: process.env.ANALYZE === "true",
});

/** @type {import('next').NextConfig} */
const nextConfig = {};

module.exports = withBundleAnalyzer(nextConfig);
```

위 코드에서 환경 변수 ANALYZE를 true로 설정해야 번들 분석이 실행된다.

### 번들 분석 실행하기

```jsx
ANALYZE=true npm run build
# 또는
ANALYZE=true yarn build
# 또는
ANALYZE=true pnpm build
```

명령어 실행 후 브라우저에서 세 개의 새 탭이 열리며 번들 분석 보고서를 확인할 수 있다.

개발 중 또는 배포 전에 정기적으로 번들 크기를 분석하면 큰 번들을 조기에 식별할 수 있으며,

이를 기반으로 애플리케이션을 더 성능 최적화된 구조로 설계할 수 있다.

# Lazy Loading

Next.js에서 **Lazy Loading(지연 로딩)**은 초기 페이지 로딩 성능을 향상시키는 기법으로, 특정 라우트(Route)를 렌더링하는 데 필요한 **JavaScript의 양을 줄이는 역할**을 한다.

이를 통해 **클라이언트 컴포넌트(Client Components)와 외부 라이브러리(Imported Libraries)의 로딩을 지연**시킬 수 있으며,

해당 요소가 실제로 필요할 때만 클라이언트 번들에 포함되도록 할 수 있다.

예를 들어, 모달 창을 사용자 클릭 시에만 로드하도록 설정할 수 있다.

## **Next.js에서 Lazy Loading을 구현하는 두 가지 방법**

1. **next/dynamic을 사용한 동적 import (Dynamic Imports with `next/dynamic`)**
2. **React.lazy()와 Suspense를 활용한 방법**

> 기본적으로 **서버 컴포넌트(Server Components)**는 자동으로 코드 스플리팅이 이루어지며,
>
> 스트리밍(Streaming) 기능을 활용해 UI를 점진적으로 클라이언트에 전송할 수 있다.
>
> 하지만 **Lazy Loading은 클라이언트 컴포넌트(Client Components)에 적용된다.**

## 1. `next/dynamic` 을 사용한 Lazy Loading

`next/dynamic`은 **React.lazy()와 Suspense의 조합**으로,

**app 디렉토리**와 **pages 디렉토리**에서 동일한 방식으로 동작하여 점진적인 마이그레이션을 가능하게 한다.

### `next/dynamic` 을 사용한 클라이언트 컴포넌트 동적 가져오기

`app/page.js`

```jsx
"use client"; // 클라이언트 컴포넌트 설정

import { useState } from "react";
import dynamic from "next/dynamic";

// 클라이언트 컴포넌트 동적 import
const ComponentA = dynamic(() => import("../components/A"));
const ComponentB = dynamic(() => import("../components/B"));
const ComponentC = dynamic(() => import("../components/C"), { ssr: false });

export default function ClientComponentExample() {
  const [showMore, setShowMore] = useState(false);

  return (
    <div>
      {/* 즉시 로드되지만 별도의 클라이언트 번들로 로드됨 */}
      <ComponentA />

      {/* 특정 조건이 충족될 때만 로드됨 */}
      {showMore && <ComponentB />}
      <button onClick={() => setShowMore(!showMore)}>Toggle</button>

      {/* 오직 클라이언트에서만 로드됨 (SSR 비활성화) */}
      <ComponentC />
    </div>
  );
}
```

### SSR 건너뛰기

기본적으로 **React.lazy() 및 Suspense를 사용하면 클라이언트 컴포넌트가 자동으로 SSR된다.**

하지만 특정 컴포넌트의 **SSR을 비활성화**하고 싶다면 `{ ssr: false }` 옵션을 사용할 수 있다

```jsx
const ComponentC = dynamic(() => import("../components/C"), { ssr: false });
```

이렇게 설정하면 **해당 컴포넌트는 서버에서 렌더링되지 않고, 오직 클라이언트에서만 로드된다.**

### 서버 컴포넌트 가져오기

만약 **서버 컴포넌트를 동적으로 가져오려는 경우**,

서버 컴포넌트 자체는 Lazy Loading되지 않으며,

**그 하위의 클라이언트 컴포넌트만 Lazy Loading이 적용된다.**

### `app/page.js`

```jsx
import dynamic from "next/dynamic";

// 서버 컴포넌트
const ServerComponent = dynamic(() => import("../components/ServerComponent"));

export default function ServerComponentExample() {
  return (
    <div>
      <ServerComponent />
    </div>
  );
}
```

이렇게 하면 서버 컴포넌트는 동적으로 가져오지만, 그 안의 클라이언트 컴포넌트만 지연 로딩된다.

## 2. 외부 라이브러리 동적 로딩

외부 라이브러리는 `import()` 함수를 사용해 필요할 때만 로드할 수 있다.

아래 예제에서는 **Fuse.js(퍼지 검색 라이브러리)**를 동적으로 로드하는 방법을 보여준다.

### `app/page.js`

```jsx
"use client";

import { useState } from "react";

const names = ["Tim", "Joe", "Bel", "Lee"];

export default function Page() {
  const [results, setResults] = useState();

  return (
    <div>
      <input
        type="text"
        placeholder="Search"
        onChange={async (e) => {
          const { value } = e.currentTarget;
          // fuse.js를 동적으로 가져오기
          const Fuse = (await import("fuse.js")).default;
          const fuse = new Fuse(names);

          setResults(fuse.search(value));
        }}
      />
      <pre>Results: {JSON.stringify(results, null, 2)}</pre>
    </div>
  );
}
```

**위 코드의 동작 방식**

1. 사용자가 검색 입력을 하면 **입력 값이 변경될 때마다 이벤트가 실행된다.**
2. `import('fuse.js')`를 사용하여 **Fuse.js 라이브러리를 동적으로 가져온다.**
3. 가져온 Fuse.js를 사용하여 입력값과 일치하는 검색 결과를 반환한다.
4. 필요한 경우에만 라이브러리를 로드하기 때문에 **불필요한 번들 크기 증가를 방지할 수 있다.**

### **3. 커스텀 로딩 컴포넌트 추가하기**

컴포넌트가 로딩될 때 사용자에게 **로딩 UI**를 보여주려면 `loading` 옵션을 사용할 수 있다.

### `app/page.js`

```jsx
import dynamic from "next/dynamic";

const WithCustomLoading = dynamic(
  () => import("../components/WithCustomLoading"),
  {
    loading: () => <p>Loading...</p>, // 로딩 중일 때 표시할 UI
  }
);

export default function Page() {
  return (
    <div>
      {/* 컴포넌트가 로딩될 때 "Loading..."이 먼저 표시됨 */}
      <WithCustomLoading />
    </div>
  );
}
```

이렇게 하면 `WithCustomLoading`이 **완전히 로드될 때까지 "Loading..."이라는 문구가 표시된다.**

### **4. Named Export**

일반적으로 `import()`를 사용할 때 **기본(default) export만 가져올 수 있다.**

하지만 **Named Export를 가져오려면 `then(mod => mod.<ExportedFunction>)`을 사용**해야 한다.

### `components/hello.js`

```jsx
"use client";

export function Hello() {
  return <p>Hello!</p>;
}
```

### `app/page.js`

```jsx
import dynamic from "next/dynamic";

// Named Export 가져오기
const ClientComponent = dynamic(() =>
  import("../components/hello").then((mod) => mod.Hello)
);

export default function Page() {
  return (
    <div>
      <ClientComponent />
    </div>
  );
}
```

이렇게 하면 `Hello`라는 함수형 컴포넌트만 **동적으로 가져올 수 있다.**

# Analytics

Next.js는 **웹 페이지의 성능을 측정하고 보고하는 기능을 기본적으로 제공한다**.

이를 통해 웹사이트의 성능을 분석하고 개선할 수 있다.

**두 가지 방법**으로 성능 데이터를 수집할 수 있다.

1. **`useReportWebVitals` 훅을 사용하여 직접 관리**
2. **Vercel의 관리형 서비스 활용 (자동으로 데이터 수집 및 시각화)**

## **1. 직접 성능 데이터 수집하기**

### **`useReportWebVitals`를 사용하여 성능 지표 출력하기**

다음과 같이 `useReportWebVitals` 훅을 사용하여 **웹 성능 지표(Web Vitals)를 측정하고 콘솔에 출력**할 수 있다.

### `app/_components/web-vitals.js`

```jsx
"use client";

import { useReportWebVitals } from "next/web-vitals";

export function WebVitals() {
  useReportWebVitals((metric) => {
    console.log(metric); // 측정된 성능 데이터 콘솔 출력
  });
}
```

이제 위에서 만든 `WebVitals` 컴포넌트를 **레이아웃에 추가한**다.

### `app/layout.js`

```jsx
import { WebVitals } from "./_components/web-vitals";

export default function Layout({ children }) {
  return (
    <html>
      <body>
        <WebVitals />
        {children}
      </body>
    </html>
  );
}
```

---

## **`use client`를 사용한 성능 최적화**

- `useReportWebVitals`는 **클라이언트 컴포넌트에서만 동작**하기 때문에 `"use client"` 지시어가 필요하다.
- 따라서 성능 최적화를 위해 **클라이언트 바운더리를 `WebVitals` 컴포넌트 내부로 한정**하는 것이 좋다.
  - 이렇게 하면 **불필요한 렌더링을 최소화**할 수 있다.

---

## **2. Web Vitals (웹 성능 지표)**

Web Vitals는 **사용자의 웹 페이지 경험을 측정하기 위한 주요 지표**다.

Next.js는 **다음과 같은 주요 성능 지표를 자동으로 측정**한다.

| 지표                                | 설명                                                       |
| ----------------------------------- | ---------------------------------------------------------- |
| **Time to First Byte (TTFB)**       | 서버에서 처음 응답을 받을 때까지 걸리는 시간               |
| **First Contentful Paint (FCP)**    | 첫 번째 콘텐츠(텍스트, 이미지 등)가 화면에 렌더링되는 시간 |
| **Largest Contentful Paint (LCP)**  | 가장 큰 콘텐츠(예: 히어로 이미지)가 화면에 렌더링되는 시간 |
| **First Input Delay (FID)**         | 사용자가 처음으로 페이지와 상호작용할 때까지의 지연 시간   |
| **Cumulative Layout Shift (CLS)**   | 페이지 로드 중 발생하는 레이아웃 이동의 총량               |
| **Interaction to Next Paint (INP)** | 사용자의 인터랙션 후 다음 화면 업데이트까지 걸리는 시간    |

> 💡 모든 성능 지표 결과는 name 속성을 통해 구분할 수 있다.

## **3. 특정 성능 지표 처리하기 (TypeScript 예제)**

아래 코드에서는 `useReportWebVitals`를 사용하여 **각 성능 지표별로 다른 처리를 적용한다.**

### `app/_components/web-vitals.tsx`

```tsx
"use client";

import { useReportWebVitals } from "next/web-vitals";

export function WebVitals() {
  useReportWebVitals((metric) => {
    switch (metric.name) {
      case "FCP": {
        // FCP 성능 지표 처리 로직
        console.log("First Contentful Paint:", metric.value);
        break;
      }
      case "LCP": {
        // LCP 성능 지표 처리 로직
        console.log("Largest Contentful Paint:", metric.value);
        break;
      }
      // 추가적인 성능 지표 처리 가능
    }
  });
}
```

> 📌 특정 성능 지표에 대한 개별적인 로직을 추가하여 원하는 방식으로 데이터를 활용할 수 있다.

## **4. 성능 데이터를 외부 시스템으로 전송하기**

웹 성능 데이터를 서버 또는 외부 애널리틱스 서비스로 전송할 수 있다.

아래 예제에서는 **성능 데이터를 특정 엔드포인트로 전송하는 방법**을 보여준다.

```jsx
useReportWebVitals((metric) => {
  const body = JSON.stringify(metric);
  const url = "https://example.com/analytics"; // 성능 데이터를 전송할 엔드포인트

  // `navigator.sendBeacon()`이 지원되면 이를 사용하고, 그렇지 않으면 `fetch()` 사용
  if (navigator.sendBeacon) {
    navigator.sendBeacon(url, body);
  } else {
    fetch(url, { body, method: "POST", keepalive: true });
  }
});
```

**위 코드의 동작 방식**

1. **측정된 성능 데이터를 JSON 형식으로 변환**
2. **서버로 전송 (`navigator.sendBeacon()` 또는 `fetch()`)**
   - `navigator.sendBeacon(url, body)`는 **페이지가 언로드(이탈)되더라도 요청을 보장한**다.
   - 지원되지 않는 경우, `fetch(url, { method: 'POST', keepalive: true })`를 사용하여 데이터를 전송한다.

## **5. Google Analytics로 성능 데이터 전송하기**

Google Analytics를 사용하는 경우, **메트릭 데이터를 `gtag`를 통해 전송할 수 있다.**

이를 활용하면 **퍼센타일(percentile) 계산 등 추가적인 분석이 가능하**다.

```jsx
useReportWebVitals((metric) => {
  // Google Analytics에 데이터 전송
  window.gtag("event", metric.name, {
    value: Math.round(
      metric.name === "CLS" ? metric.value * 1000 : metric.value
    ), // CLS 값은 1000을 곱해 정수 변환
    event_label: metric.id, // 현재 페이지 로드에 대한 고유 ID
    non_interaction: true, // 바운스율(Bounce Rate)에 영향을 주지 않도록 설정
  });
});
```

**주요 설정**

- `metric.name`: 어떤 성능 지표인지 (예: `LCP`, `CLS`, `FID` 등)
- `metric.value`: 측정된 성능 값
- `metric.id`: 현재 페이지 로드에 대한 **고유 ID**
- `non_interaction: true`: **바운스율(Bounce Rate)에 영향을 주지 않도록 설정**

> 🔗 참고: Google Analytics로 성능 데이터 보내기
