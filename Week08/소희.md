# Bundle Analyzer

@next/bundle-analyzer는 Next.js에서 자바스크립트 모듈의 크기를 관리하는 데 도움이 되는 플러그인이다.

이 플러그인은 각 모듈과 해당 종속성의 크기에 대한 시각적 보고서를 생성한다.

이 정보를 활용하면 다음과 같은 작업을 수행할 수 있다.

- **큰 종속성 제거**
- **코드 분할 (Code Splitting)**
- **일부 모듈만 로드하여 클라이언트로 전송되는 데이터량 감소**

### 설치

```jsx
npm i @next/bundle-analyzer
# 또는
yarn add @next/bundle-analyzer
# 또는
pnpm add @next/bundle-analyzer
```

### **next.config.js 설정**

```jsx
const withBundleAnalyzer = require("@next/bundle-analyzer")({
  enabled: process.env.ANALYZE === "true",
});

/** @type {import('next').NextConfig} */
const nextConfig = {};

module.exports = withBundleAnalyzer(nextConfig);
```

위 코드에서 환경 변수 ANALYZE를 true로 설정해야 번들 분석이 실행된다.

### 번들 분석 실행하기

```jsx
ANALYZE=true npm run build
# 또는
ANALYZE=true yarn build
# 또는
ANALYZE=true pnpm build
```

명령어 실행 후 브라우저에서 세 개의 새 탭이 열리며 번들 분석 보고서를 확인할 수 있다.

개발 중 또는 배포 전에 정기적으로 번들 크기를 분석하면 큰 번들을 조기에 식별할 수 있으며,

이를 기반으로 애플리케이션을 더 성능 최적화된 구조로 설계할 수 있다.

# Lazy Loading

Next.js에서 **Lazy Loading(지연 로딩)**은 초기 페이지 로딩 성능을 향상시키는 기법으로, 특정 라우트(Route)를 렌더링하는 데 필요한 **JavaScript의 양을 줄이는 역할**을 한다.

이를 통해 **클라이언트 컴포넌트(Client Components)와 외부 라이브러리(Imported Libraries)의 로딩을 지연**시킬 수 있으며,

해당 요소가 실제로 필요할 때만 클라이언트 번들에 포함되도록 할 수 있다.

예를 들어, 모달 창을 사용자 클릭 시에만 로드하도록 설정할 수 있다.

## **Next.js에서 Lazy Loading을 구현하는 두 가지 방법**

1. **next/dynamic을 사용한 동적 import (Dynamic Imports with `next/dynamic`)**
2. **React.lazy()와 Suspense를 활용한 방법**

> 기본적으로 **서버 컴포넌트(Server Components)**는 자동으로 코드 스플리팅이 이루어지며,
>
> 스트리밍(Streaming) 기능을 활용해 UI를 점진적으로 클라이언트에 전송할 수 있다.
>
> 하지만 **Lazy Loading은 클라이언트 컴포넌트(Client Components)에 적용된다.**

## 1. `next/dynamic` 을 사용한 Lazy Loading

`next/dynamic`은 **React.lazy()와 Suspense의 조합**으로,

**app 디렉토리**와 **pages 디렉토리**에서 동일한 방식으로 동작하여 점진적인 마이그레이션을 가능하게 한다.

### `next/dynamic` 을 사용한 클라이언트 컴포넌트 동적 가져오기

`app/page.js`

```jsx
"use client"; // 클라이언트 컴포넌트 설정

import { useState } from "react";
import dynamic from "next/dynamic";

// 클라이언트 컴포넌트 동적 import
const ComponentA = dynamic(() => import("../components/A"));
const ComponentB = dynamic(() => import("../components/B"));
const ComponentC = dynamic(() => import("../components/C"), { ssr: false });

export default function ClientComponentExample() {
  const [showMore, setShowMore] = useState(false);

  return (
    <div>
      {/* 즉시 로드되지만 별도의 클라이언트 번들로 로드됨 */}
      <ComponentA />

      {/* 특정 조건이 충족될 때만 로드됨 */}
      {showMore && <ComponentB />}
      <button onClick={() => setShowMore(!showMore)}>Toggle</button>

      {/* 오직 클라이언트에서만 로드됨 (SSR 비활성화) */}
      <ComponentC />
    </div>
  );
}
```

### SSR 건너뛰기

기본적으로 **React.lazy() 및 Suspense를 사용하면 클라이언트 컴포넌트가 자동으로 SSR된다.**

하지만 특정 컴포넌트의 **SSR을 비활성화**하고 싶다면 `{ ssr: false }` 옵션을 사용할 수 있다

```jsx
const ComponentC = dynamic(() => import("../components/C"), { ssr: false });
```

이렇게 설정하면 **해당 컴포넌트는 서버에서 렌더링되지 않고, 오직 클라이언트에서만 로드된다.**

### 서버 컴포넌트 가져오기

만약 **서버 컴포넌트를 동적으로 가져오려는 경우**,

서버 컴포넌트 자체는 Lazy Loading되지 않으며,

**그 하위의 클라이언트 컴포넌트만 Lazy Loading이 적용된다.**

### `app/page.js`

```jsx
import dynamic from "next/dynamic";

// 서버 컴포넌트
const ServerComponent = dynamic(() => import("../components/ServerComponent"));

export default function ServerComponentExample() {
  return (
    <div>
      <ServerComponent />
    </div>
  );
}
```

이렇게 하면 서버 컴포넌트는 동적으로 가져오지만, 그 안의 클라이언트 컴포넌트만 지연 로딩된다.

## 2. 외부 라이브러리 동적 로딩

외부 라이브러리는 `import()` 함수를 사용해 필요할 때만 로드할 수 있다.

아래 예제에서는 **Fuse.js(퍼지 검색 라이브러리)**를 동적으로 로드하는 방법을 보여준다.

### `app/page.js`

```jsx
"use client";

import { useState } from "react";

const names = ["Tim", "Joe", "Bel", "Lee"];

export default function Page() {
  const [results, setResults] = useState();

  return (
    <div>
      <input
        type="text"
        placeholder="Search"
        onChange={async (e) => {
          const { value } = e.currentTarget;
          // fuse.js를 동적으로 가져오기
          const Fuse = (await import("fuse.js")).default;
          const fuse = new Fuse(names);

          setResults(fuse.search(value));
        }}
      />
      <pre>Results: {JSON.stringify(results, null, 2)}</pre>
    </div>
  );
}
```

**위 코드의 동작 방식**

1. 사용자가 검색 입력을 하면 **입력 값이 변경될 때마다 이벤트가 실행된다.**
2. `import('fuse.js')`를 사용하여 **Fuse.js 라이브러리를 동적으로 가져온다.**
3. 가져온 Fuse.js를 사용하여 입력값과 일치하는 검색 결과를 반환한다.
4. 필요한 경우에만 라이브러리를 로드하기 때문에 **불필요한 번들 크기 증가를 방지할 수 있다.**

### **3. 커스텀 로딩 컴포넌트 추가하기**

컴포넌트가 로딩될 때 사용자에게 **로딩 UI**를 보여주려면 `loading` 옵션을 사용할 수 있다.

### `app/page.js`

```jsx
import dynamic from "next/dynamic";

const WithCustomLoading = dynamic(
  () => import("../components/WithCustomLoading"),
  {
    loading: () => <p>Loading...</p>, // 로딩 중일 때 표시할 UI
  }
);

export default function Page() {
  return (
    <div>
      {/* 컴포넌트가 로딩될 때 "Loading..."이 먼저 표시됨 */}
      <WithCustomLoading />
    </div>
  );
}
```

이렇게 하면 `WithCustomLoading`이 **완전히 로드될 때까지 "Loading..."이라는 문구가 표시된다.**

### **4. Named Export**

일반적으로 `import()`를 사용할 때 **기본(default) export만 가져올 수 있다.**

하지만 **Named Export를 가져오려면 `then(mod => mod.<ExportedFunction>)`을 사용**해야 한다.

### `components/hello.js`

```jsx
"use client";

export function Hello() {
  return <p>Hello!</p>;
}
```

### `app/page.js`

```jsx
import dynamic from "next/dynamic";

// Named Export 가져오기
const ClientComponent = dynamic(() =>
  import("../components/hello").then((mod) => mod.Hello)
);

export default function Page() {
  return (
    <div>
      <ClientComponent />
    </div>
  );
}
```

이렇게 하면 `Hello`라는 함수형 컴포넌트만 **동적으로 가져올 수 있다.**
