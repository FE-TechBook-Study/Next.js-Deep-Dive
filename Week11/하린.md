# 하린

## 캐싱 메커니즘 개요

1. **요청 메모이제이션(Request Memoization)**
   - **목적**: React 컴포넌트 트리 내에서 데이터 재사용
   - **위치**: 서버
   - **지속 기간**: 요청 생명주기 동안만 유지
   - **특징**: 동일한 렌더링 패스 내에서 중복 데이터 요청 방지
2. **데이터 캐시(Data Cache)**
   - **목적**: 사용자 요청 및 배포 간에 데이터 저장
   - **위치**: 서버
   - **지속 기간**: 영구적(재검증 가능)
   - **특징**: `fetch` 요청 결과를 저장하여 외부 데이터 소스 접근 최소화
3. **전체 경로 캐시(Full Route Cache)**
   - **목적**: 렌더링 비용 감소 및 성능 향상
   - **위치**: 서버
   - **지속 기간**: 영구적(재검증 가능)
   - **특징**: HTML과 React 서버 컴포넌트 페이로드를 캐싱
4. **라우터 캐시(Router Cache)**
   - **목적**: 네비게이션 시 서버 요청 감소
   - **위치**: 클라이언트
   - **지속 기간**: 사용자 세션 또는 시간 기반
   - **특징**: 클라이언트 측에서 이전에 방문한 경로를 저장

## 요청 메모이제이션

- React는 자동으로 동일한 URL과 옵션을 가진 `fetch` 요청을 메모이제이션
- 동일한 렌더링 과정에서 여러 컴포넌트가 같은 데이터를 요청할 때 한 번만 실행
- 메모이제이션은 GET 메서드와 React 컴포넌트 트리에만 적용
- 기간: 서버 요청 생명주기 동안만 유지

## 데이터 캐시

- Next.js는 서버 요청 및 배포 간에 데이터 페치 결과를 영구적으로 저장
- 기본적으로 `fetch` 요청은 자동으로 캐싱됨
- 재검증 방법:
  - **시간 기반 재검증**: `fetch('url', { next: { revalidate: 3600 } })`
  - **온디맨드 재검증**: `revalidatePath('/path')` 또는 `revalidateTag('tag')`
- 옵트아웃: `fetch('url', { cache: 'no-store' })`

## 전체 경로 캐시

- 빌드 시간에 정적 경로를 렌더링하고 캐싱
- 렌더링 결과(HTML 및 React 서버 컴포넌트 페이로드)를 서버에 저장
- 정적 경로는 기본적으로 캐싱되고, 동적 경로는 요청 시 렌더링됨
- 재검증:
  - 데이터 캐시 재검증 시 함께 무효화됨
  - 새로운 배포 시 캐시 삭제됨
- 옵트아웃:
  - 동적 함수 사용 (`cookies`, `headers`, `searchParams`)
  - 라우트 세그먼트 설정 사용 (`dynamic = 'force-dynamic'` 또는 `revalidate = 0`)
  - 데이터 캐시 옵트아웃 시 자동으로 전체 경로 캐시도 옵트아웃됨

## 라우터 캐시

- 사용자 세션 동안 브라우저에 React 서버 컴포넌트 페이로드를 저장
- 방문한 경로 세그먼트를 캐싱하고 사용자가 이동할 가능성이 높은 경로를 프리페치
- 빠른 네비게이션과 상태 유지 가능
- 지속 기간:
  - 페이지 새로고침 시 삭제됨
  - 자동 무효화 기간: 정적 페이지는 5분, 동적 페이지는 캐싱되지 않음(기본 프리페치)
- 무효화:
  - 서버 액션에서 `revalidatePath`, `revalidateTag`, `cookies.set` 사용
  - `router.refresh` 호출
