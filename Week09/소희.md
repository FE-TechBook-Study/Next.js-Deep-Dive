# TypeScript

Next.js는 React 애플리케이션을 개발할 때 TypeScript 우선 환경을 제공한다.

기본적으로 TypeScript를 지원하며, 필요한 패키지를 자동으로 설치하고 적절한 설정을 구성해준다.

또한, 개발 환경을 돕기 위한 TypeScript 플러그인이 포함되어 있어 ide에서도 사용할 수 있다.

## TypeScript 플러그인

Next.js는 VS Code 및 기타 코드 편집기에서 사용 가능한 커스텀 TypeScript 플러그인과 타입 검사기를 포함하고 있다.

### VS Code에서 TypeScript 플러그인 활성화하기

1. **명령 팔레트(Command Palette) 열기**

   `Ctrl` + `Shift` + `P` (Windows) 또는 `⌘` + `Shift` + `P` (Mac)

2. **"TypeScript: Select TypeScript Version" 검색**
3. **"Use Workspace Version" 선택**

이제 파일을 편집하면 Next.js 의 TypeScript 플러그인이 활성화도니다.

또한 next build를 실행할 때, Next.js의 커스텀 타입 검사기가 사용된다.

### **플러그인이 제공하는 기능**

- **올바르지 않은 설정 값**을 사용하면 경고 표시
- **사용 가능한 옵션과 문서 제공**
- `"use client"` 지시어가 올바르게 사용되었는지 검사
- `useState`, `useEffect` 같은 **클라이언트 훅이 Client Components에서만 사용되도록 검사**

## **TypeScript 최소 버전**

TypeScript **v4.5.2 이상**을 사용하는 것이 권장된다.

이 버전 이상을 사용하면 **import 이름의 타입 수정 기능** 및 **성능 향상** 등의 혜택을 받을 수 있다.

## **정적 타입 검사(Statically Typed Links)**

Next.js는 `next/link`를 사용할 때 **링크 URL의 타입 검사를 지원**하여 잘못된 경로 입력을 방지한다.

이 기능을 사용하려면 **`experimental.typedRoutes` 옵션을 활성화해야 한다.**

**`next.config.js` 설정 예시**

```jsx
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    typedRoutes: true,
  },
};

module.exports = nextConfig;
```

### **타입이 적용된 링크 사용 예시**

Next.js는 `.next/types` 내부에 **모든 유효한 라우트 정보를 포함한 타입 정의 파일**을 자동으로 생성한다.

```tsx

import type { Route } from 'next';
import Link from 'next/link';

// ✅ 올바른 라우트 (TypeScript 오류 없음)
<Link href="/about" />
<Link href="/blog/nextjs" />
<Link href={`/blog/${slug}`} />
<Link href={('/blog' + slug) as Route} />

// ❌ 잘못된 라우트 (TypeScript 오류 발생)
<Link href="/aboot" />

```

### **사용자 정의 컴포넌트에서 타입 지정**

사용자 정의 컴포넌트에서 `next/link`를 감싸는 경우, 제네릭(Generic)을 활용해 `href`의 타입을 지정할 수 있다.

```tsx
import type { Route } from "next";
import Link from "next/link";

function Card<T extends string>({ href }: { href: Route<T> | URL }) {
  return (
    <Link href={href}>
      <div>My Card</div>
    </Link>
  );
}
```

## **엔드 투 엔드 타입 안정성(End-to-End Type Safety)**

Next.js의 **App Router**는 데이터의 타입 안정성을 강화했다.

- **데이터를 직렬화할 필요 없음:**
  서버에서 데이터를 가져올 때 `Date`, `Map`, `Set` 등의 객체를 변환할 필요 없이 사용할 수 있다.
- **컴포넌트 간 데이터 흐름이 간소화됨:**`_app.js` 없이 **루트 레이아웃을 사용**하므로 데이터 흐름이 더 명확해졌다.

### **타입 안정성이 적용된 데이터 가져오기 예시**

```tsx
async function getData() {
  const res = await fetch("https://api.example.com/...");
  return res.json(); // 직렬화 없이 바로 사용 가능
}

export default async function Page() {
  const name = await getData();
  return "...";
}
```

---

## **비동기 Server Component 타입 오류 해결**

**TypeScript v5.1.3 이상과 @types/react v18.2.8 이상**을 사용해야 `Promise<Element>` 오류를 방지할 수 있다.

## **경로 별칭(Path Aliases) 및 baseUrl 설정**

Next.js는 `tsconfig.json`에서 **"paths"** 및 **"baseUrl"** 옵션을 자동으로 지원한다.

## **next.config.js에서 TypeScript 검사**

`next.config.js`는 JavaScript 파일이므로 TypeScript에서 직접 검사되지 않는다.

대신 **JSDoc 주석**을 사용하면 일부 타입 검사를 수행할 수 있다.

```jsx
// @ts-check

/**
 * @type {import('next').NextConfig}
 **/
const nextConfig = {
  /* 설정 옵션 */
};

module.exports = nextConfig;
```

## **점진적 타입 검사(Incremental Type Checking)**

Next.js v10.2.1부터 **점진적 타입 검사**가 추가되었으며, `tsconfig.json`에서 활성화할 수 있다.

이 기능은 **대규모 프로젝트에서 타입 검사 속도를 향상**시키는 데 유용하다.

## **TypeScript 오류 무시하기**

Next.js는 **TypeScript 오류가 있는 상태에서 `next build`를 실행하면 빌드를 중단**한다.

하지만, **위험을 감수하고라도 빌드를 강제로 진행**할 수도 있다.

**`next.config.js` 설정 예시**

```jsx
module.exports = {
  typescript: {
    // !! 경고 !!
    // TypeScript 오류가 있어도 빌드가 강제 완료됨
    ignoreBuildErrors: true,
  },
};
```

💡 **주의:**

이 옵션을 활성화하면 **타입 오류를 놓칠 위험이 크므로** 빌드 또는 배포 프로세스에서 타입 검사를 따로 실행해야 한다.

## **사용자 정의 타입 선언**

Next.js는 자동으로 `next-env.d.ts` 파일을 생성하지만, 이 파일을 직접 수정하면 **덮어씌워지므로** 새로운 타입 파일을 별도로 만들어야 한다.

```jsx
// tsconfig.json
{
  "compilerOptions": {
    "skipLibCheck": true},
  "include": [
    "new-types.d.ts",
    "next-env.d.ts",
    ".next/types/**/*.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": ["node_modules"]
}
```

# ESLint

Next.js는 기본적으로

**ESLint를 통합**

하여 제공한다.

따라서, 별도의 설정 없이도 프로젝트에서 ESLint를 바로 사용할 수 있다.

# **ESLint 플러그인**

Next.js에는 **eslint-plugin-next** 플러그인이 내장되어 있으며,

이를 통해 **Next.js 애플리케이션에서 발생할 수 있는 오류를 자동으로 감지**할 수 있다.

### **플러그인이 감지하는 주요 오류**

| **규칙**                                 | **설명**                                                       |
| ---------------------------------------- | -------------------------------------------------------------- |
| `@next/next/google-font-display`         | Google Fonts 사용 시 `font-display` 속성을 지정하도록 강제     |
| `@next/next/no-img-element`              | `<img>` 대신 `next/image`를 사용하도록 강제                    |
| `@next/next/no-html-link-for-pages`      | 내부 페이지로 이동 시 `<a>` 대신 `next/link`를 사용하도록 강제 |
| `@next/next/no-title-in-document-head`   | `<title>` 태그는 `next/head`에서만 사용하도록 강제             |
| `@next/next/no-script-component-in-head` | `next/script`는 `next/head` 내부에서 사용하지 못하도록 제한    |

## **프로젝트 루트가 다른 경우 (Monorepo)**

Next.js가 **루트 디렉토리에 없을 때**, `rootDir` 옵션을 지정해야 한다.

**`.eslintrc.json` 설정**

```json
{
  "extends": "next",
  "settings": {
    "next": {
      "rootDir": "packages/my-app/"
    }
  }
}
```

`rootDir`은 상대 경로, 절대 경로, 또는 `packages/*/`와 같은 glob 패턴을 지원한다.

## **ESLint 검사 대상 디렉터리 변경**

기본적으로 ESLint는 **`pages/`, `app/`, `components/`, `lib/`, `src/` 디렉터리**를 검사한다.

이것을 변경하려면 `next.config.js`에서 `dirs` 옵션을 설정할 수 있다.

**`next.config.js`에서 특정 디렉터리만 검사하도록 설정**

```jsx
module.exports = {
  eslint: {
    dirs: ["pages", "utils"], // 'pages'와 'utils' 디렉터리만 검사
  },
};
```

**특정 파일만 검사하는 명령어**

```bash
next lint --dir pages --dir utils --file bar.js
```

# **ESLint 캐싱**

- ESLint는 실행 속도를 향상시키기 위해 **파일 검사 정보를 `.next/cache`에 저장**한다.
- 만약 캐싱을 비활성화하려면 `-no-cache` 옵션을 사용한다.

**캐시 없이 실행하는 명령어**

```
next lint --no-cache
```

# **Git 커밋 전 ESLint 실행 (lint-staged)**

Git에 커밋하기 전에 ESLint를 실행하려면 `lint-staged`를 사용한다.

**`.lintstagedrc.js` 예시**

```jsx
const path = require("path");

const buildEslintCommand = (filenames) =>
  `next lint --fix --file ${filenames
    .map((f) => path.relative(process.cwd(), f))
    .join(" --file ")}`;

module.exports = {
  "*.{js,jsx,ts,tsx}": [buildEslintCommand],
};
```

# Envrionment Variables

Next.js는 환경 변수(Environment Variables)를 기본적으로 지원하며, 이를 통해 다음과 같은 작업을 할 수 있다.

- `.env.local`을 사용하여 환경 변수를 로드
- `NEXT_PUBLIC_`을 접두사로 추가하여 브라우저에서도 환경 변수를 사용할 수 있도록 번들링

## **환경 변수 로드 (Loading Environment Variables)**

Next.js는 **`.env.local` 파일**에서 환경 변수를 읽어 `process.env`에 자동으로 로드한다.

**`.env.local` 예시**

```
DB_HOST=localhost
DB_USER=myuser
DB_PASS=mypassword
```

**주의:**

- Next.js는 **멀티라인 환경 변수**도 지원한다.
- 비밀 키(private key) 같은 값도 저장 가능하다.

```
# .env.local

# 여러 줄을 사용할 경우:
PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----
...
Kh9NV...
...
-----END DSA PRIVATE KEY-----"

# `\n`을 사용해 한 줄로 표현 가능:
PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\nKh9NV...\n-----END DSA PRIVATE KEY-----\n"

```

**`.env` 파일의 위치:**

- 프로젝트 루트에 있어야 한다.
- `/src` 폴더 안에 `.env` 파일을 두면 Next.js가 이를 로드하지 않으므로 **프로젝트 루트에 위치해야 한다.**

**환경 변수 사용 예시 (`app/api/route.js`)**

```jsx
export async function GET() {
  const db = await myDB.connect({
    host: process.env.DB_HOST,
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
  });
  // ...
}
```

## **다른 환경 변수 참조 (Referencing Other Variables)**

Next.js는 **환경 변수 안에서 다른 환경 변수를 참조**하는 기능을 지원한다.

예를 들어, `$VARIABLE` 형식을 사용하여 다른 변수를 포함할 수 있다.

### **`.env` 예시**

```
TWITTER_USER=nextjs
TWITTER_URL=https://twitter.com/$TWITTER_USER
```

➡ **`process.env.TWITTER_URL`의 값:**

```
https://twitter.com/nextjs

```

**💡 `$` 문자를 값으로 그대로 사용하려면 `\$`로 이스케이프 해야 한다.**

## **브라우저에서 환경 변수 사용 (Bundling Environment Variables for the Browser)**

`NEXT_PUBLIC_` 접두사를 추가하면 **환경 변수를 클라이언트(브라우저)에서도 사용할 수 있다.**

일반적인 환경 변수는 **Node.js 서버에서만 사용 가능**하다.

**`NEXT_PUBLIC_` 사용 예시**

```
NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk
```

➡ **JavaScript 코드에서 사용 가능**

```jsx
import setupAnalyticsService from "../lib/my-analytics-service";

setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID);
```

**Next.js는 빌드(`next build`) 시점에 `NEXT_PUBLIC_` 환경 변수를 정적인 값으로 변환한다.**

즉, 이후 `.env.local`을 변경해도 **이미 빌드된 JavaScript 코드에는 반영되지 않는다.**

💡 **런타임 환경 변수 값이 필요하다면?**

- API를 따로 만들어 클라이언트에서 요청하도록 설계해야 한다.

## **런타임 환경 변수 (Runtime Environment Variables)**

Next.js는 **빌드 타임과 런타임 환경 변수**를 모두 지원한다.

- `NEXT_PUBLIC_`이 붙은 변수는 **빌드 타임에 JavaScript 번들에 포함**된다.
- 런타임 변수를 사용하려면 `getServerSideProps` 또는 **App Router의 동적 렌더링 기능**을 활용해야 한다.

### **서버에서 런타임 환경 변수 읽기**

```jsx
import { unstable_noStore as noStore } from 'next/cache'

export default function Component() {
  noStore()
  const value = process.env.MY_VALUE
  // ...

```

**💡 추가 정보:**

- `cookies()`, `headers()` 등을 사용하면 동적 렌더링이 적용되어 **환경 변수를 런타임에서 읽을 수 있다.**
- `runtimeConfig` 사용은 권장되지 않는다. (Standalone 모드에서 작동하지 않음)

## **기본 환경 변수 (Default Environment Variables)**

Next.js는 **환경별 `.env` 파일**을 지원한다.

| 환경                           | 파일명             |
| ------------------------------ | ------------------ |
| **모든 환경**                  | `.env`             |
| **개발 환경 (next dev)**       | `.env.development` |
| **프로덕션 환경 (next start)** | `.env.production`  |

### **우선순위**

`.env.local` 파일이 존재하면 **다른 환경 변수 파일보다 우선 적용**된다.

**버전 관리(Git) 관련 가이드**

- `.env`, `.env.development`, `.env.production` → **Git에 포함**
- `.env.local`, `.env*.local` → **Git에 포함 X** (`.gitignore`에 추가해야 함)

## **테스트 환경 변수 (Test Environment Variables)**

Next.js는 `test` 환경을 위한 `.env.test` 파일을 지원한다.

이는 **Jest, Cypress 등의 테스트 도구**에서 사용된다.

**테스트 환경에서는 `.env.local` 파일을 자동으로 무시한다.**

- `.env.test` 파일을 사용하여 테스트 환경에 맞는 기본값을 설정할 수 있다.

## **환경 변수 로드 순서 (Environment Variable Load Order)**

환경 변수를 로드하는 순서는 다음과 같다.

1️⃣ `process.env`

2️⃣ `.env.$(NODE_ENV).local`

3️⃣ `.env.local` (단, `NODE_ENV=test`일 경우 무시됨)

4️⃣ `.env.$(NODE_ENV)`

5️⃣ `.env`

**예시**

- `NODE_ENV=development`이고 `.env.development.local`과 `.env` 모두에서 같은 변수를 정의하면,**`.env.development.local`의 값이 적용된다.**

## **추가 정보 (Good to Know)**

- `/src` 디렉토리를 사용할 경우 `.env.*` 파일은 프로젝트 루트에 두어야 한다.
- `NODE_ENV`가 설정되지 않은 경우, `next dev` 실행 시 **자동으로 `development`로 설정**된다.
- `next build` 및 `next start` 실행 시 **자동으로 `production`으로 설정**된다.

# Absolute Imports and Module Path Aliases

Next.js는 기본적으로 **`tsconfig.json`** 또는 **`jsconfig.json`** 파일에서 제공하는 `"paths"` 및 `"baseUrl"` 옵션을 지원한다.

이 기능을 사용하면 **프로젝트 내의 경로를 절대 경로로 설정**하여 더 간결한 `import` 문을 사용할 수 있다.

## **1. 절대 경로(Absolute Imports)란?**

절대 경로(Absolute Imports)를 사용하면 프로젝트의 루트 디렉터리를 기준으로 모듈을 `import`할 수 있다.

### **상대 경로 사용 (Before)**

```tsx
import { Button } from "../../../components/button";
```

위 코드는 `../../../` 같은 상대 경로를 사용해야 하므로, **파일의 위치가 바뀌면 `import` 문도 바꿔야 하는 불편함이 있다.**

### **✅ 절대 경로 사용 (After)**

```tsx
timport { Button } from '@/components/button'
```

이제 **파일의 위치가 변경되어도 `import` 문을 수정할 필요가 없으며, 코드 가독성이 향상된다.**

## **2. 절대 경로 설정 방법**

`tsconfig.json` 또는 `jsconfig.json` 파일에서 `"baseUrl"` 옵션을 설정하면 프로젝트 루트에서 직접 `import`가 가능하다.

### **📌 절대 경로 설정 (`tsconfig.json` 또는 `jsconfig.json`)**

```json
{
  "compilerOptions": {
    "baseUrl": "."
  }
}
```

### **`components/button.tsx` (컴포넌트 예시)**

```tsx
export default function Button() {
  return <button>Click me</button>;
}
```

### **`app/page.tsx` (절대 경로를 활용한 `import`)**

```tsx
import Button from "components/button";

export default function HomePage() {
  return (
    <>
      <h1>Hello World</h1>
      <Button />
    </>
  );
}
```

`baseUrl`을 설정하면 `import` 시 `components/button`처럼 **루트 디렉터리에서 직접 참조**할 수 있다.

## **3. 모듈 경로 별칭(Module Path Aliases) 설정**

절대 경로를 설정하는 것 외에도, `"paths"` 옵션을 사용하여 **경로를 별칭(alias)으로 설정**할 수 있다.

이렇게 하면 특정 디렉터리를 `@/` 같은 짧은 경로로 쉽게 불러올 수 있다.

### **`paths` 옵션을 설정한 `tsconfig.json` 또는 `jsconfig.json`**

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/components/*": ["components/*"]
    }
  }
}
```

**위 설정을 적용하면 다음과 같이 `import`할 수 있다.**

### **`import` 시 별칭 적용 (Before)**

```tsx
import { Button } from "../../components/button";
```

### **별칭(`@/`)을 사용한 `import` (After)**

```tsx
import { Button } from "@/components/button";
```

**이제 상대 경로(`../../` 등)를 신경 쓰지 않고 `@/`를 사용해 간결하게 불러올 수 있다.**

## **4. `baseUrl`과 `paths` 함께 사용하기**

만약 `src/` 디렉터리를 루트로 사용하고 싶다면 `"baseUrl"`을 `"src/"`로 설정할 수도 있다.

### **`tsconfig.json` 설정 예시**

```json
{
  "compilerOptions": {
    "baseUrl": "src/",
    "paths": {
      "@/styles/*": ["styles/*"],
      "@/components/*": ["components/*"]
    }
  }
}
```

이렇게 설정하면 `"src/"` 디렉터리를 기준으로 `"@/styles"` 및 `"@/components"` 별칭을 사용할 수 있다.

### **`pages/index.js` 예제**

```tsx
import Button from "@/components/button";
import "@/styles/styles.css";
import Helper from "utils/helper";

export default function HomePage() {
  return (
    <Helper>
      <h1>Hello World</h1>
      <Button />
    </Helper>
  );
}
```

**이제 `@/components/button`처럼 깔끔하게 `import`할 수 있다.**

# MDX

## 1. Markdown(MD)란?

Markdown은 경량 마크업 언어로, 일반적인 텍스트 기반 문법을 사용하여 HTML로 변환할 수 있다.

웹사이트나 블로그에서 콘텐츠를 작성할 때 자주 사용된다.

### **Markdown 사용 예시**

```markdown
I **love** using [Next.js](https://nextjs.org/)
```

### **변환된 HTML 결과**

```html
<p>I <strong>love</strong> using <a href="https://nextjs.org/">Next.js</a></p>
```

**주요 특징**

- 간단한 문법으로 텍스트를 꾸밀 수 있음
- HTML 변환이 용이하여 웹사이트, 문서 작성 등에 활용됨
- `.md` 확장자를 가진 파일로 작성

## 2. MDX란?

Markdown의 확장판(Superset)으로, Markdown 문법뿐만 아니라 JSX(JavaScript XML)도 직접 작성할 수 있다.

즉, React 컴포넌트를 Markdown 문서 안에서 바로 사용할 수 있다.

**MDX 사용 시 장점**

- 일반적인 Markdown처럼 글을 작성할 수 있음
- JSX 문법을 그대로 사용할 수 있어 React 컴포넌트 삽입 가능
- Next.js의 App Router와 연동하여 동적인 콘텐츠 제작 가능

**MDX 사용 예시**

```markdown
import { MyComponent } from 'my-components'

# Welcome to my MDX page!

This is some **bold** and _italics_ text.

<MyComponent />
```

➡ **이제 Markdown 파일에서도 React 컴포넌트를 직접 불러올 수 있다**

## 3. Next.js에서 MDX 사용 설정하기

Next.js에서 MDX를 사용하려면 `@next/mdx` 패키지를 설치하고 설정해야 한다.

```markdown
npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx
```

Next.js의 App Router를 사용하려면 `mdx-components.tsx` 파일이 반드시 필요하다.

이 파일을 프로젝트의 `src/` 디렉터리 또는 `app/` 디렉터리의 부모 폴더에 생성해야 한다.

```tsx
// mdx-components.tsx

import type { MDXComponents } from "mdx/types";

export function useMDXComponents(components: MDXComponents): MDXComponents {
  return {
    ...components,
  };
}
```

`next.config.js`에서 MDX 파일을 지원하도록 설정한다.

### **`next.config.js`**

```jsx
const withMDX = require("@next/mdx")();

/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ["js", "jsx", "mdx", "ts", "tsx"],
};

module.exports = withMDX(nextConfig);
```

➡ **`pageExtensions` 옵션을 추가하면 `.mdx` 파일도 페이지로 인식된다.**

다음과 같이 `app/` 디렉터리에 MDX 페이지를 추가한다.

**프로젝트 구조**

```jsx
  your-project
  ├── app
  │   └── my-mdx-page
  │       └── page.mdx
  └── package.json
```

```jsx
// page.mdx

import { MyComponent } from 'my-components'

# Welcome to my MDX page!

This is some **bold** and _italics_ text.

<MyComponent />
```

→ 이제 `/my-mdx-page` 경로로 이동하면 MDX 콘텐츠가 정상적으로 렌더링된다.

## 4. 원격 MDX(Remote MDX) 사용

MDX 콘텐츠가 로컬 파일이 아닌 CMS, 데이터베이스, 외부 API 등에 저장된 경우 서버에서 데이터를 동적으로 불러올 수도 있다.

이때 `next-mdx-remote` 패키지를 사용하면 편리하다.

```jsx
import { MDXRemote } from "next-mdx-remote/rsc";

export default async function RemoteMdxPage() {
  const res = await fetch("https://...");
  const markdown = await res.text();
  return <MDXRemote source={markdown} />;
}
```

➡ **이제 `/my-mdx-page-remote` 경로로 이동하면 원격에서 불러온 MDX 콘텐츠가 렌더링된다.**

**주의 사항:**

- MDX는 **JavaScript로 변환되어 실행되므로, 신뢰할 수 있는 출처에서만 데이터를 가져와야 한다.**
- 그렇지 않으면 **원격 코드 실행(Remote Code Execution, RCE) 보안 문제**가 발생할 수 있다.

## 5. MDX 레이아웃 적용

MDX 페이지에서 공통 레이아웃을 적용하려면 `layout.tsx` 파일을 추가하면 된다.

**`app/my-mdx-page/layout.tsx`**

```tsx
export default function MdxLayout({ children }: { children: React.ReactNode }) {
  return <div style={{ color: "blue" }}>{children}</div>;
}
```

➡ **모든 MDX 콘텐츠에 파란색 텍스트 스타일을 적용할 수 있다.**

## 6. Markdown 변환 과정

React는 Markdown을 직접 해석할 수 없으므로, Markdown을 HTML로 변환하는 과정이 필요하다.

이를 위해 `remark` (Markdown 변환)와 `rehype` (HTML 변환) 라이브러리를 사용한다.

**Markdown을 HTML로 변환하는 예제**

```tsx
import { unified } from "unified";
import remarkParse from "remark-parse";
import remarkRehype from "remark-rehype";
import rehypeSanitize from "rehype-sanitize";
import rehypeStringify from "rehype-stringify";

async function main() {
  const file = await unified()
    .use(remarkParse) // Markdown 파싱
    .use(remarkRehype) // HTML 변환
    .use(rehypeSanitize) // 보안 처리
    .use(rehypeStringify) // 최종 HTML 변환
    .process("Hello, Next.js!");

  console.log(String(file)); // <p>Hello, Next.js!</p>
}
```

→ Next.js에서 `@next.mdx` 를 사용하면 내부적으로 이런 변환 작업을 자동으로 처리한다.

## 7. Rust 기반 MDX 컴파일러 (실험적 기능)

Next.js는 Rust 기반의 새로운 MDX 컴파일러를 실험적으로 지원하고 있다.

이 컴파일러는 기존 방식보다빠르지만, 아직 안정적이지 않아 프로덕션에서 사용을 권장하지 않는다.

**Rust 기반 MDX 컴파일러 활성화 (`next.config.js`)**

```jsx
module.exports = withMDX({
  experimental: {
    mdxRs: true,
  },
});
```

**→ 이 옵션을 설정하면 Next.js가 Rust 기반의 MDX 컴파일러를 사용하여 더욱 빠르게 MDX를 변환할 수 있다.**

| 기능                       | 설명                                               |
| -------------------------- | -------------------------------------------------- |
| **Markdown**               | `.md` 파일을 HTML로 변환할 수 있는 마크업 언어     |
| **MDX**                    | Markdown + JSX를 지원하는 확장된 마크업 언어       |
| **@next/mdx**              | Next.js에서 MDX를 사용할 수 있도록 지원하는 패키지 |
| **Remote MDX**             | 원격 서버에서 MDX 데이터를 불러와서 렌더링         |
| **remark & rehype**        | Markdown → HTML 변환에 사용되는 라이브러리         |
| **Rust 기반 MDX 컴파일러** | Next.js에서 실험적으로 지원하는 고속 MDX 컴파일러  |
