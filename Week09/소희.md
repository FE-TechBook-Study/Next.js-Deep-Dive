# TypeScript

Next.js는 React 애플리케이션을 개발할 때 TypeScript 우선 환경을 제공한다.

기본적으로 TypeScript를 지원하며, 필요한 패키지를 자동으로 설치하고 적절한 설정을 구성해준다.

또한, 개발 환경을 돕기 위한 TypeScript 플러그인이 포함되어 있어 ide에서도 사용할 수 있다.

## TypeScript 플러그인

Next.js는 VS Code 및 기타 코드 편집기에서 사용 가능한 커스텀 TypeScript 플러그인과 타입 검사기를 포함하고 있다.

### VS Code에서 TypeScript 플러그인 활성화하기

1. **명령 팔레트(Command Palette) 열기**

   `Ctrl` + `Shift` + `P` (Windows) 또는 `⌘` + `Shift` + `P` (Mac)

2. **"TypeScript: Select TypeScript Version" 검색**
3. **"Use Workspace Version" 선택**

이제 파일을 편집하면 Next.js 의 TypeScript 플러그인이 활성화도니다.

또한 next build를 실행할 때, Next.js의 커스텀 타입 검사기가 사용된다.

### **플러그인이 제공하는 기능**

- **올바르지 않은 설정 값**을 사용하면 경고 표시
- **사용 가능한 옵션과 문서 제공**
- `"use client"` 지시어가 올바르게 사용되었는지 검사
- `useState`, `useEffect` 같은 **클라이언트 훅이 Client Components에서만 사용되도록 검사**

## **TypeScript 최소 버전**

TypeScript **v4.5.2 이상**을 사용하는 것이 권장된다.

이 버전 이상을 사용하면 **import 이름의 타입 수정 기능** 및 **성능 향상** 등의 혜택을 받을 수 있다.

## **정적 타입 검사(Statically Typed Links)**

Next.js는 `next/link`를 사용할 때 **링크 URL의 타입 검사를 지원**하여 잘못된 경로 입력을 방지한다.

이 기능을 사용하려면 **`experimental.typedRoutes` 옵션을 활성화해야 한다.**

**`next.config.js` 설정 예시**

```jsx
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    typedRoutes: true,
  },
};

module.exports = nextConfig;
```

### **타입이 적용된 링크 사용 예시**

Next.js는 `.next/types` 내부에 **모든 유효한 라우트 정보를 포함한 타입 정의 파일**을 자동으로 생성한다.

```tsx

import type { Route } from 'next';
import Link from 'next/link';

// ✅ 올바른 라우트 (TypeScript 오류 없음)
<Link href="/about" />
<Link href="/blog/nextjs" />
<Link href={`/blog/${slug}`} />
<Link href={('/blog' + slug) as Route} />

// ❌ 잘못된 라우트 (TypeScript 오류 발생)
<Link href="/aboot" />

```

### **사용자 정의 컴포넌트에서 타입 지정**

사용자 정의 컴포넌트에서 `next/link`를 감싸는 경우, 제네릭(Generic)을 활용해 `href`의 타입을 지정할 수 있다.

```tsx
import type { Route } from "next";
import Link from "next/link";

function Card<T extends string>({ href }: { href: Route<T> | URL }) {
  return (
    <Link href={href}>
      <div>My Card</div>
    </Link>
  );
}
```

## **엔드 투 엔드 타입 안정성(End-to-End Type Safety)**

Next.js의 **App Router**는 데이터의 타입 안정성을 강화했다.

- **데이터를 직렬화할 필요 없음:**
  서버에서 데이터를 가져올 때 `Date`, `Map`, `Set` 등의 객체를 변환할 필요 없이 사용할 수 있다.
- **컴포넌트 간 데이터 흐름이 간소화됨:**`_app.js` 없이 **루트 레이아웃을 사용**하므로 데이터 흐름이 더 명확해졌다.

### **타입 안정성이 적용된 데이터 가져오기 예시**

```tsx
async function getData() {
  const res = await fetch("https://api.example.com/...");
  return res.json(); // 직렬화 없이 바로 사용 가능
}

export default async function Page() {
  const name = await getData();
  return "...";
}
```

---

## **비동기 Server Component 타입 오류 해결**

**TypeScript v5.1.3 이상과 @types/react v18.2.8 이상**을 사용해야 `Promise<Element>` 오류를 방지할 수 있다.

## **경로 별칭(Path Aliases) 및 baseUrl 설정**

Next.js는 `tsconfig.json`에서 **"paths"** 및 **"baseUrl"** 옵션을 자동으로 지원한다.

## **next.config.js에서 TypeScript 검사**

`next.config.js`는 JavaScript 파일이므로 TypeScript에서 직접 검사되지 않는다.

대신 **JSDoc 주석**을 사용하면 일부 타입 검사를 수행할 수 있다.

```jsx
// @ts-check

/**
 * @type {import('next').NextConfig}
 **/
const nextConfig = {
  /* 설정 옵션 */
};

module.exports = nextConfig;
```

## **점진적 타입 검사(Incremental Type Checking)**

Next.js v10.2.1부터 **점진적 타입 검사**가 추가되었으며, `tsconfig.json`에서 활성화할 수 있다.

이 기능은 **대규모 프로젝트에서 타입 검사 속도를 향상**시키는 데 유용하다.

## **TypeScript 오류 무시하기**

Next.js는 **TypeScript 오류가 있는 상태에서 `next build`를 실행하면 빌드를 중단**한다.

하지만, **위험을 감수하고라도 빌드를 강제로 진행**할 수도 있다.

**`next.config.js` 설정 예시**

```jsx
module.exports = {
  typescript: {
    // !! 경고 !!
    // TypeScript 오류가 있어도 빌드가 강제 완료됨
    ignoreBuildErrors: true,
  },
};
```

💡 **주의:**

이 옵션을 활성화하면 **타입 오류를 놓칠 위험이 크므로** 빌드 또는 배포 프로세스에서 타입 검사를 따로 실행해야 한다.

## **사용자 정의 타입 선언**

Next.js는 자동으로 `next-env.d.ts` 파일을 생성하지만, 이 파일을 직접 수정하면 **덮어씌워지므로** 새로운 타입 파일을 별도로 만들어야 한다.

```jsx
// tsconfig.json
{
  "compilerOptions": {
    "skipLibCheck": true},
  "include": [
    "new-types.d.ts",
    "next-env.d.ts",
    ".next/types/**/*.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": ["node_modules"]
}
```

# ESLint

Next.js는 기본적으로

**ESLint를 통합**

하여 제공한다.

따라서, 별도의 설정 없이도 프로젝트에서 ESLint를 바로 사용할 수 있다.

# **ESLint 플러그인**

Next.js에는 **eslint-plugin-next** 플러그인이 내장되어 있으며,

이를 통해 **Next.js 애플리케이션에서 발생할 수 있는 오류를 자동으로 감지**할 수 있다.

### **플러그인이 감지하는 주요 오류**

| **규칙**                                 | **설명**                                                       |
| ---------------------------------------- | -------------------------------------------------------------- |
| `@next/next/google-font-display`         | Google Fonts 사용 시 `font-display` 속성을 지정하도록 강제     |
| `@next/next/no-img-element`              | `<img>` 대신 `next/image`를 사용하도록 강제                    |
| `@next/next/no-html-link-for-pages`      | 내부 페이지로 이동 시 `<a>` 대신 `next/link`를 사용하도록 강제 |
| `@next/next/no-title-in-document-head`   | `<title>` 태그는 `next/head`에서만 사용하도록 강제             |
| `@next/next/no-script-component-in-head` | `next/script`는 `next/head` 내부에서 사용하지 못하도록 제한    |

## **프로젝트 루트가 다른 경우 (Monorepo)**

Next.js가 **루트 디렉토리에 없을 때**, `rootDir` 옵션을 지정해야 한다.

**`.eslintrc.json` 설정**

```json
{
  "extends": "next",
  "settings": {
    "next": {
      "rootDir": "packages/my-app/"
    }
  }
}
```

`rootDir`은 상대 경로, 절대 경로, 또는 `packages/*/`와 같은 glob 패턴을 지원한다.

## **ESLint 검사 대상 디렉터리 변경**

기본적으로 ESLint는 **`pages/`, `app/`, `components/`, `lib/`, `src/` 디렉터리**를 검사한다.

이것을 변경하려면 `next.config.js`에서 `dirs` 옵션을 설정할 수 있다.

**`next.config.js`에서 특정 디렉터리만 검사하도록 설정**

```jsx
module.exports = {
  eslint: {
    dirs: ["pages", "utils"], // 'pages'와 'utils' 디렉터리만 검사
  },
};
```

**특정 파일만 검사하는 명령어**

```bash
next lint --dir pages --dir utils --file bar.js
```

# **ESLint 캐싱**

- ESLint는 실행 속도를 향상시키기 위해 **파일 검사 정보를 `.next/cache`에 저장**한다.
- 만약 캐싱을 비활성화하려면 `-no-cache` 옵션을 사용한다.

**캐시 없이 실행하는 명령어**

```
next lint --no-cache
```

# **Git 커밋 전 ESLint 실행 (lint-staged)**

Git에 커밋하기 전에 ESLint를 실행하려면 `lint-staged`를 사용한다.

**`.lintstagedrc.js` 예시**

```jsx
const path = require("path");

const buildEslintCommand = (filenames) =>
  `next lint --fix --file ${filenames
    .map((f) => path.relative(process.cwd(), f))
    .join(" --file ")}`;

module.exports = {
  "*.{js,jsx,ts,tsx}": [buildEslintCommand],
};
```

# Envrionment Variables

Next.js는 환경 변수(Environment Variables)를 기본적으로 지원하며, 이를 통해 다음과 같은 작업을 할 수 있다.

- `.env.local`을 사용하여 환경 변수를 로드
- `NEXT_PUBLIC_`을 접두사로 추가하여 브라우저에서도 환경 변수를 사용할 수 있도록 번들링

## **환경 변수 로드 (Loading Environment Variables)**

Next.js는 **`.env.local` 파일**에서 환경 변수를 읽어 `process.env`에 자동으로 로드한다.

**`.env.local` 예시**

```
DB_HOST=localhost
DB_USER=myuser
DB_PASS=mypassword
```

**주의:**

- Next.js는 **멀티라인 환경 변수**도 지원한다.
- 비밀 키(private key) 같은 값도 저장 가능하다.

```
# .env.local

# 여러 줄을 사용할 경우:
PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----
...
Kh9NV...
...
-----END DSA PRIVATE KEY-----"

# `\n`을 사용해 한 줄로 표현 가능:
PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\nKh9NV...\n-----END DSA PRIVATE KEY-----\n"

```

**`.env` 파일의 위치:**

- 프로젝트 루트에 있어야 한다.
- `/src` 폴더 안에 `.env` 파일을 두면 Next.js가 이를 로드하지 않으므로 **프로젝트 루트에 위치해야 한다.**

**환경 변수 사용 예시 (`app/api/route.js`)**

```jsx
export async function GET() {
  const db = await myDB.connect({
    host: process.env.DB_HOST,
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
  });
  // ...
}
```

## **다른 환경 변수 참조 (Referencing Other Variables)**

Next.js는 **환경 변수 안에서 다른 환경 변수를 참조**하는 기능을 지원한다.

예를 들어, `$VARIABLE` 형식을 사용하여 다른 변수를 포함할 수 있다.

### **`.env` 예시**

```
TWITTER_USER=nextjs
TWITTER_URL=https://twitter.com/$TWITTER_USER
```

➡ **`process.env.TWITTER_URL`의 값:**

```
https://twitter.com/nextjs

```

**💡 `$` 문자를 값으로 그대로 사용하려면 `\$`로 이스케이프 해야 한다.**

## **브라우저에서 환경 변수 사용 (Bundling Environment Variables for the Browser)**

`NEXT_PUBLIC_` 접두사를 추가하면 **환경 변수를 클라이언트(브라우저)에서도 사용할 수 있다.**

일반적인 환경 변수는 **Node.js 서버에서만 사용 가능**하다.

**`NEXT_PUBLIC_` 사용 예시**

```
NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk
```

➡ **JavaScript 코드에서 사용 가능**

```jsx
import setupAnalyticsService from "../lib/my-analytics-service";

setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID);
```

**Next.js는 빌드(`next build`) 시점에 `NEXT_PUBLIC_` 환경 변수를 정적인 값으로 변환한다.**

즉, 이후 `.env.local`을 변경해도 **이미 빌드된 JavaScript 코드에는 반영되지 않는다.**

💡 **런타임 환경 변수 값이 필요하다면?**

- API를 따로 만들어 클라이언트에서 요청하도록 설계해야 한다.

## **런타임 환경 변수 (Runtime Environment Variables)**

Next.js는 **빌드 타임과 런타임 환경 변수**를 모두 지원한다.

- `NEXT_PUBLIC_`이 붙은 변수는 **빌드 타임에 JavaScript 번들에 포함**된다.
- 런타임 변수를 사용하려면 `getServerSideProps` 또는 **App Router의 동적 렌더링 기능**을 활용해야 한다.

### **서버에서 런타임 환경 변수 읽기**

```jsx
import { unstable_noStore as noStore } from 'next/cache'

export default function Component() {
  noStore()
  const value = process.env.MY_VALUE
  // ...

```

**💡 추가 정보:**

- `cookies()`, `headers()` 등을 사용하면 동적 렌더링이 적용되어 **환경 변수를 런타임에서 읽을 수 있다.**
- `runtimeConfig` 사용은 권장되지 않는다. (Standalone 모드에서 작동하지 않음)

## **기본 환경 변수 (Default Environment Variables)**

Next.js는 **환경별 `.env` 파일**을 지원한다.

| 환경                           | 파일명             |
| ------------------------------ | ------------------ |
| **모든 환경**                  | `.env`             |
| **개발 환경 (next dev)**       | `.env.development` |
| **프로덕션 환경 (next start)** | `.env.production`  |

### **우선순위**

`.env.local` 파일이 존재하면 **다른 환경 변수 파일보다 우선 적용**된다.

**버전 관리(Git) 관련 가이드**

- `.env`, `.env.development`, `.env.production` → **Git에 포함**
- `.env.local`, `.env*.local` → **Git에 포함 X** (`.gitignore`에 추가해야 함)

## **테스트 환경 변수 (Test Environment Variables)**

Next.js는 `test` 환경을 위한 `.env.test` 파일을 지원한다.

이는 **Jest, Cypress 등의 테스트 도구**에서 사용된다.

**테스트 환경에서는 `.env.local` 파일을 자동으로 무시한다.**

- `.env.test` 파일을 사용하여 테스트 환경에 맞는 기본값을 설정할 수 있다.

## **환경 변수 로드 순서 (Environment Variable Load Order)**

환경 변수를 로드하는 순서는 다음과 같다.

1️⃣ `process.env`

2️⃣ `.env.$(NODE_ENV).local`

3️⃣ `.env.local` (단, `NODE_ENV=test`일 경우 무시됨)

4️⃣ `.env.$(NODE_ENV)`

5️⃣ `.env`

**예시**

- `NODE_ENV=development`이고 `.env.development.local`과 `.env` 모두에서 같은 변수를 정의하면,**`.env.development.local`의 값이 적용된다.**

## **추가 정보 (Good to Know)**

- `/src` 디렉토리를 사용할 경우 `.env.*` 파일은 프로젝트 루트에 두어야 한다.
- `NODE_ENV`가 설정되지 않은 경우, `next dev` 실행 시 **자동으로 `development`로 설정**된다.
- `next build` 및 `next start` 실행 시 **자동으로 `production`으로 설정**된다.

# Absolute Imports and Module Path Aliases

Next.js는 기본적으로 **`tsconfig.json`** 또는 **`jsconfig.json`** 파일에서 제공하는 `"paths"` 및 `"baseUrl"` 옵션을 지원한다.

이 기능을 사용하면 **프로젝트 내의 경로를 절대 경로로 설정**하여 더 간결한 `import` 문을 사용할 수 있다.

## **1. 절대 경로(Absolute Imports)란?**

절대 경로(Absolute Imports)를 사용하면 프로젝트의 루트 디렉터리를 기준으로 모듈을 `import`할 수 있다.

### **상대 경로 사용 (Before)**

```tsx
import { Button } from "../../../components/button";
```

위 코드는 `../../../` 같은 상대 경로를 사용해야 하므로, **파일의 위치가 바뀌면 `import` 문도 바꿔야 하는 불편함이 있다.**

### **✅ 절대 경로 사용 (After)**

```tsx
timport { Button } from '@/components/button'
```

이제 **파일의 위치가 변경되어도 `import` 문을 수정할 필요가 없으며, 코드 가독성이 향상된다.**

## **2. 절대 경로 설정 방법**

`tsconfig.json` 또는 `jsconfig.json` 파일에서 `"baseUrl"` 옵션을 설정하면 프로젝트 루트에서 직접 `import`가 가능하다.

### **📌 절대 경로 설정 (`tsconfig.json` 또는 `jsconfig.json`)**

```json
{
  "compilerOptions": {
    "baseUrl": "."
  }
}
```

### **`components/button.tsx` (컴포넌트 예시)**

```tsx
export default function Button() {
  return <button>Click me</button>;
}
```

### **`app/page.tsx` (절대 경로를 활용한 `import`)**

```tsx
import Button from "components/button";

export default function HomePage() {
  return (
    <>
      <h1>Hello World</h1>
      <Button />
    </>
  );
}
```

`baseUrl`을 설정하면 `import` 시 `components/button`처럼 **루트 디렉터리에서 직접 참조**할 수 있다.

## **3. 모듈 경로 별칭(Module Path Aliases) 설정**

절대 경로를 설정하는 것 외에도, `"paths"` 옵션을 사용하여 **경로를 별칭(alias)으로 설정**할 수 있다.

이렇게 하면 특정 디렉터리를 `@/` 같은 짧은 경로로 쉽게 불러올 수 있다.

### **`paths` 옵션을 설정한 `tsconfig.json` 또는 `jsconfig.json`**

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/components/*": ["components/*"]
    }
  }
}
```

**위 설정을 적용하면 다음과 같이 `import`할 수 있다.**

### **`import` 시 별칭 적용 (Before)**

```tsx
import { Button } from "../../components/button";
```

### **별칭(`@/`)을 사용한 `import` (After)**

```tsx
import { Button } from "@/components/button";
```

**이제 상대 경로(`../../` 등)를 신경 쓰지 않고 `@/`를 사용해 간결하게 불러올 수 있다.**

## **4. `baseUrl`과 `paths` 함께 사용하기**

만약 `src/` 디렉터리를 루트로 사용하고 싶다면 `"baseUrl"`을 `"src/"`로 설정할 수도 있다.

### **`tsconfig.json` 설정 예시**

```json
{
  "compilerOptions": {
    "baseUrl": "src/",
    "paths": {
      "@/styles/*": ["styles/*"],
      "@/components/*": ["components/*"]
    }
  }
}
```

이렇게 설정하면 `"src/"` 디렉터리를 기준으로 `"@/styles"` 및 `"@/components"` 별칭을 사용할 수 있다.

### **`pages/index.js` 예제**

```tsx
import Button from "@/components/button";
import "@/styles/styles.css";
import Helper from "utils/helper";

export default function HomePage() {
  return (
    <Helper>
      <h1>Hello World</h1>
      <Button />
    </Helper>
  );
}
```

**이제 `@/components/button`처럼 깔끔하게 `import`할 수 있다.**

# MDX

## 1. Markdown(MD)란?

Markdown은 경량 마크업 언어로, 일반적인 텍스트 기반 문법을 사용하여 HTML로 변환할 수 있다.

웹사이트나 블로그에서 콘텐츠를 작성할 때 자주 사용된다.

### **Markdown 사용 예시**

```markdown
I **love** using [Next.js](https://nextjs.org/)
```

### **변환된 HTML 결과**

```html
<p>I <strong>love</strong> using <a href="https://nextjs.org/">Next.js</a></p>
```

**주요 특징**

- 간단한 문법으로 텍스트를 꾸밀 수 있음
- HTML 변환이 용이하여 웹사이트, 문서 작성 등에 활용됨
- `.md` 확장자를 가진 파일로 작성

## 2. MDX란?

Markdown의 확장판(Superset)으로, Markdown 문법뿐만 아니라 JSX(JavaScript XML)도 직접 작성할 수 있다.

즉, React 컴포넌트를 Markdown 문서 안에서 바로 사용할 수 있다.

**MDX 사용 시 장점**

- 일반적인 Markdown처럼 글을 작성할 수 있음
- JSX 문법을 그대로 사용할 수 있어 React 컴포넌트 삽입 가능
- Next.js의 App Router와 연동하여 동적인 콘텐츠 제작 가능

**MDX 사용 예시**

```markdown
import { MyComponent } from 'my-components'

# Welcome to my MDX page!

This is some **bold** and _italics_ text.

<MyComponent />
```

➡ **이제 Markdown 파일에서도 React 컴포넌트를 직접 불러올 수 있다**

## 3. Next.js에서 MDX 사용 설정하기

Next.js에서 MDX를 사용하려면 `@next/mdx` 패키지를 설치하고 설정해야 한다.

```markdown
npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx
```

Next.js의 App Router를 사용하려면 `mdx-components.tsx` 파일이 반드시 필요하다.

이 파일을 프로젝트의 `src/` 디렉터리 또는 `app/` 디렉터리의 부모 폴더에 생성해야 한다.

```tsx
// mdx-components.tsx

import type { MDXComponents } from "mdx/types";

export function useMDXComponents(components: MDXComponents): MDXComponents {
  return {
    ...components,
  };
}
```

`next.config.js`에서 MDX 파일을 지원하도록 설정한다.

### **`next.config.js`**

```jsx
const withMDX = require("@next/mdx")();

/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ["js", "jsx", "mdx", "ts", "tsx"],
};

module.exports = withMDX(nextConfig);
```

➡ **`pageExtensions` 옵션을 추가하면 `.mdx` 파일도 페이지로 인식된다.**

다음과 같이 `app/` 디렉터리에 MDX 페이지를 추가한다.

**프로젝트 구조**

```jsx
  your-project
  ├── app
  │   └── my-mdx-page
  │       └── page.mdx
  └── package.json
```

```jsx
// page.mdx

import { MyComponent } from 'my-components'

# Welcome to my MDX page!

This is some **bold** and _italics_ text.

<MyComponent />
```

→ 이제 `/my-mdx-page` 경로로 이동하면 MDX 콘텐츠가 정상적으로 렌더링된다.

## 4. 원격 MDX(Remote MDX) 사용

MDX 콘텐츠가 로컬 파일이 아닌 CMS, 데이터베이스, 외부 API 등에 저장된 경우 서버에서 데이터를 동적으로 불러올 수도 있다.

이때 `next-mdx-remote` 패키지를 사용하면 편리하다.

```jsx
import { MDXRemote } from "next-mdx-remote/rsc";

export default async function RemoteMdxPage() {
  const res = await fetch("https://...");
  const markdown = await res.text();
  return <MDXRemote source={markdown} />;
}
```

➡ **이제 `/my-mdx-page-remote` 경로로 이동하면 원격에서 불러온 MDX 콘텐츠가 렌더링된다.**

**주의 사항:**

- MDX는 **JavaScript로 변환되어 실행되므로, 신뢰할 수 있는 출처에서만 데이터를 가져와야 한다.**
- 그렇지 않으면 **원격 코드 실행(Remote Code Execution, RCE) 보안 문제**가 발생할 수 있다.

## 5. MDX 레이아웃 적용

MDX 페이지에서 공통 레이아웃을 적용하려면 `layout.tsx` 파일을 추가하면 된다.

**`app/my-mdx-page/layout.tsx`**

```tsx
export default function MdxLayout({ children }: { children: React.ReactNode }) {
  return <div style={{ color: "blue" }}>{children}</div>;
}
```

➡ **모든 MDX 콘텐츠에 파란색 텍스트 스타일을 적용할 수 있다.**

## 6. Markdown 변환 과정

React는 Markdown을 직접 해석할 수 없으므로, Markdown을 HTML로 변환하는 과정이 필요하다.

이를 위해 `remark` (Markdown 변환)와 `rehype` (HTML 변환) 라이브러리를 사용한다.

**Markdown을 HTML로 변환하는 예제**

```tsx
import { unified } from "unified";
import remarkParse from "remark-parse";
import remarkRehype from "remark-rehype";
import rehypeSanitize from "rehype-sanitize";
import rehypeStringify from "rehype-stringify";

async function main() {
  const file = await unified()
    .use(remarkParse) // Markdown 파싱
    .use(remarkRehype) // HTML 변환
    .use(rehypeSanitize) // 보안 처리
    .use(rehypeStringify) // 최종 HTML 변환
    .process("Hello, Next.js!");

  console.log(String(file)); // <p>Hello, Next.js!</p>
}
```

→ Next.js에서 `@next.mdx` 를 사용하면 내부적으로 이런 변환 작업을 자동으로 처리한다.

## 7. Rust 기반 MDX 컴파일러 (실험적 기능)

Next.js는 Rust 기반의 새로운 MDX 컴파일러를 실험적으로 지원하고 있다.

이 컴파일러는 기존 방식보다빠르지만, 아직 안정적이지 않아 프로덕션에서 사용을 권장하지 않는다.

**Rust 기반 MDX 컴파일러 활성화 (`next.config.js`)**

```jsx
module.exports = withMDX({
  experimental: {
    mdxRs: true,
  },
});
```

**→ 이 옵션을 설정하면 Next.js가 Rust 기반의 MDX 컴파일러를 사용하여 더욱 빠르게 MDX를 변환할 수 있다.**

| 기능                       | 설명                                               |
| -------------------------- | -------------------------------------------------- |
| **Markdown**               | `.md` 파일을 HTML로 변환할 수 있는 마크업 언어     |
| **MDX**                    | Markdown + JSX를 지원하는 확장된 마크업 언어       |
| **@next/mdx**              | Next.js에서 MDX를 사용할 수 있도록 지원하는 패키지 |
| **Remote MDX**             | 원격 서버에서 MDX 데이터를 불러와서 렌더링         |
| **remark & rehype**        | Markdown → HTML 변환에 사용되는 라이브러리         |
| **Rust 기반 MDX 컴파일러** | Next.js에서 실험적으로 지원하는 고속 MDX 컴파일러  |

# src Directory

Next.js에서는 프로젝트의 루트 디렉터리에 `app/` (App Router) 또는 `pages/` (Pages Router) 디렉터리를 두는 것이 기본 구조이지만, `src` 디렉터리를 사용하여 애플리케이션 코드를 보다 깔끔하게 정리할 수도 있다.

### `src` 디렉터리를 사용하는 이유

- 프로젝트 설정 파일과 애플리케이션 코드를 분리할 수 있다.
- `package.json` , `tsconfig.json` , `next.config.js` 같은 설정 파일을 루트에 두고, `src/` 디렉터리에는 애플리케이션 코드만 포함하도록 구성할 수 있다.
- 여러 팀과 협업할 때 더 깔금한 구조를 유지할 수 있다.

## `src` 디렉터리 사용 방법

- 기본적으로 `app/` 또는 `pages/` 디렉터리를 `src/` 내부로 이동
- 기존 `components/` , `lib/` 등의 폴더도 함께 `src/` 내부로 이동 가능

```jsx
  my-next-app/
  ├── src/
  │   ├── app/         # (App Router 사용 시) 페이지 폴더
  │   ├── pages/       # (Pages Router 사용 시) 페이지 폴더
  │   ├── components/  # 컴포넌트 폴더
  │   ├── lib/         # 유틸리티 함수 및 모듈 폴더
  │   ├── middleware/  # 미들웨어 폴더
  │   ├── styles/      # 스타일 폴더 (CSS, Tailwind 등)
  │   ├── assets/      # 이미지 및 정적 리소스 폴더
  │   └── hooks/       # 커스텀 훅 폴더
  ├── public/          # 정적 파일 (favicon, 이미지 등) -> 반드시 루트에 위치해야 함
  ├── .gitignore       # Git 무시 파일
  ├── package.json     # 프로젝트 설정 파일
  ├── next.config.js   # Next.js 설정 파일
  ├── tsconfig.json    # TypeScript 설정 파일
  ├── .env.local       # 환경 변수 파일

```

## **중요한 사항 (Good to Know)**

1.  **`/public` 디렉터리는 프로젝트 루트에 유지해야 한다.**

- `public/` 폴더는 정적 파일(이미지, 폰트, 아이콘 등)을 저장하는 공간이므로 `src/` 내부로 이동하면 안 된다.

1.  **`package.json`, `next.config.js`, `tsconfig.json` 같은 설정 파일은 루트에 유지해야 한다.**

- Next.js는 프로젝트의 루트에서 이 설정 파일들을 찾기 때문에 `src/` 내부로 옮기면 인식되지 않는다.

1.  **`.env.*` 파일도 프로젝트 루트에 있어야 한다.**

- 환경 변수 파일(`.env.local`, `.env.production`, `.env.development`)은 루트에 있어야 Next.js에서 정상적으로 로드된다.

1.  **루트 디렉터리에 `app/` 또는 `pages/` 폴더가 있으면 `src/app` 또는 `src/pages`는 무시된다.**

- 즉, `src/` 내부에 `app/` 또는 `pages/`가 존재해도, 루트에 같은 폴더가 있다면 Next.js는 루트의 폴더를 우선적으로 사용한다.

1.  **`src/`를 사용하는 경우, `components/`, `lib/` 같은 폴더도 `src/` 내부로 이동하는 것이 일반적이다.**

- 예를 들어, `components/`, `lib/`, `utils/` 폴더도 함께 `src/` 내부로 옮길 수 있다.

1.  **미들웨어(Middleware)를 사용할 경우, 반드시 `src/` 내부에 위치해야 한다.**

- 미들웨어(`middleware.ts` 또는 `middleware.js`)는 `src/` 디렉터리 내에 있어야 정상적으로 동작한다.

1.  **Tailwind CSS를 사용할 경우, `tailwind.config.js` 파일의 `content` 설정을 수정해야 한다.**

- `src/` 디렉터리를 사용하면 Tailwind가 파일을 찾을 수 있도록 `tailwind.config.js`의 `content` 경로를 수정해야 한다.

```jsx
module.exports = {
  content: [
    "./src/**/*.{js,ts,jsx,tsx}", // src/ 디렉터리 내부를 스캔하도록 설정
  ],
};
```

1. **TypeScript의 `paths` 설정을 수정해야 한다.**

- `@/components` 같은 **경로 별칭을 사용하려면** `tsconfig.json`의 `"paths"` 옵션을 업데이트해야 한다.

```json
{
  "compilerOptions": {
    "baseUrl": "src/",
    "paths": {
      "@/components/*": ["components/*"],
      "@/lib/*": ["lib/*"]
    }
  }
}
```

# Draft Mode

정적 렌더링(Static Rendering)은 헤드리스 CMS에서 데이터를 가져와 페이지를 생성할 때 유용하다.

그러나 헤드리스 CMS에서 초안을 작성하고 이를 즉시 확인하려는 경우,

정적 렌더링 방식은 적합하지 않다.

이 경우, Next.js가 빌드 타임이 아니라 요청 타임(request time)에 페이지를 렌더링하고

게시된 콘텐츠가 아닌 초안 상태의 콘텐츠를 가져오도록 해야 한다.

이 기능을 수행하는 것이 Next.js의 Dfraft Mode(초안 모드)이다.

## **1단계: 라우트 핸들러(Route Handler) 생성 및 접근**

먼저, 라우트 핸들러(Route Handler)를 생성해야 한다.

이 핸들러는 아무 이름이나 가질 수 있으며, 예를 들어 `app/api/draft/route.ts`로 만들 수 있다.

그런 다음, `next/headers`에서 `draftMode`를 가져와 `enable()` 메서드를 호출한다.

### **`app/api/draft/route.ts`**

```tsx
// 초안 모드를 활성화하는 라우트 핸들러
import { draftMode } from "next/headers";

export async function GET(request: Request) {
  draftMode().enable();
  return new Response("Draft mode is enabled");
}
```

이 코드가 실행되면 **Draft Mode를 활성화하는 쿠키**가 설정된다.

이후 해당 쿠키를 포함하는 모든 요청은 Draft Mode가 활성화된 상태에서 처리된다.

**테스트 방법:**

- `/api/draft` 엔드포인트를 직접 방문한 후, 브라우저의 개발자 도구를 열어본다.
- `Set-Cookie` 응답 헤더에 `__prerender_bypass`라는 쿠키가 설정된 것을 확인할 수 있다.

## **2. 헤드리스 CMS에서 안전하게 초안 모드 활성화하기**

실제 개발 환경에서는 **헤드리스 CMS에서 이 라우트 핸들러를 안전하게 호출**해야 한다.

사용하는 CMS마다 구체적인 방법은 다르지만, 일반적으로 아래의 절차를 따르면 된다.

1️⃣ **비밀 토큰(secret token) 생성**

- `토큰 생성기(token generator)`를 사용하여 **비밀 토큰**을 만든다.
- 이 토큰은 Next.js 애플리케이션과 헤드리스 CMS에서만 알고 있어야 한다.
- 이렇게 하면 CMS에 접근할 수 없는 사용자가 초안 URL을 확인하지 못하도록 보호할 수 있다.

2️⃣ **CMS에서 초안 URL을 설정**

- 헤드리스 CMS가 사용자 지정 초안 URL(Custom Draft URL)을 지원하는 경우,
  다음과 같이 URL을 설정한다.

```
https://<your-site>/api/draft?secret=<token>&slug=<path>
```

`<your-site>` → 배포된 도메인

`<token>` → 생성한 **비밀 토큰**

`<path>` → 초안을 확인하려는 페이지의 경로

- 예를 들어 `/posts/foo` 페이지를 확인하려면 `&slug=/posts/foo`를 추가해야 한다.
- 일부 CMS에서는 `{entry.fields.slug}` 변수를 사용해 `&slug=/posts/{entry.fields.slug}`처럼 동적으로 설정할 수도 있다.

### **`app/api/draft/route.ts` - 보안 적용**

```tsx
// 초안 모드를 활성화하는 보안 라우트 핸들러
import { draftMode } from "next/headers";
import { redirect } from "next/navigation";

export async function GET(request: Request) {
  // 쿼리 문자열 파싱
  const { searchParams } = new URL(request.url);
  const secret = searchParams.get("secret");
  const slug = searchParams.get("slug");

  // 비밀 키(secret) 및 slug 유효성 검사
  if (secret !== "MY_SECRET_TOKEN" || !slug) {
    return new Response("Invalid token", { status: 401 });
  }

  // 헤드리스 CMS에서 slug가 존재하는지 확인
  const post = await getPostBySlug(slug);

  // slug가 존재하지 않으면 Draft Mode 활성화 차단
  if (!post) {
    return new Response("Invalid slug", { status: 401 });
  }

  // Draft Mode 활성화
  draftMode().enable();

  // 초안이 존재하는 페이지로 리디렉션
  redirect(post.slug);
}
```

**보안 조치:**

- `secret`이 예상한 값과 다르면 401 응답을 반환
- `slug`가 존재하지 않으면 Draft Mode 활성화 차단
- `redirect(post.slug)`를 사용하여 열린 리디렉션(Open Redirect) 공격 방지

**초안 URL을 호출하면:**

- **정상적인 경우** → 브라우저가 초안 콘텐츠가 포함된 페이지로 이동
- **잘못된 토큰이 전달된 경우** → 401 에러 발생

## **3단계: 페이지에서 초안 모드 확인 및 동적 렌더링 설정**

이제 페이지에서 `draftMode().isEnabled` 값을 확인하여

Draft Mode가 활성화된 경우, 데이터를 동적으로 가져오도록 수정해야 한다.

**Draft Mode가 활성화된 경우:**

- 정적 빌드된 데이터를 사용하지 않고, 요청마다 최신 데이터를 가져온다.

**Draft Mode가 비활성화된 경우:**

- 기본적으로 정적 페이지를 사용한다.

### **`app/page.tsx` - 초안 모드에 따른 데이터 가져오기**

```tsx
// 데이터 가져오는 페이지
import { draftMode } from "next/headers";

async function getData() {
  const { isEnabled } = draftMode();

  const url = isEnabled
    ? "https://draft.example.com" // 초안 데이터 (Draft Mode 활성화 시)
    : "https://production.example.com"; // 게시된 데이터 (Draft Mode 비활성화 시)

  const res = await fetch(url);
  return res.json();
}

export default async function Page() {
  const { title, desc } = await getData();

  return (
    <main>
      <h1>{title}</h1>
      <p>{desc}</p>
    </main>
  );
}
```

**이제 초안 모드가 활성화되면 `draft.example.com`에서 초안 데이터를 가져오고,
비활성화되면 `production.example.com`에서 게시된 데이터를 가져온다.**

## **4단계: Draft Mode 쿠키 제거**

기본적으로 **Draft Mode는 브라우저를 닫으면 자동으로 해제된다.**

하지만 명시적으로 **Draft Mode를 비활성화하는 API 엔드포인트**를 만들 수도 있다.

**초안 모드 쿠키 제거 라우트**

```tsx
// Draft Mode 비활성화 라우트
import { draftMode } from "next/headers";

export async function GET(request: Request) {
  draftMode().disable();
  return new Response("Draft mode is disabled");
}
```

`/api/disable-draft`로 요청을 보내면 **Draft Mode 쿠키가 삭제된다.**

**💡 주의:**

- `next/link`로 이 엔드포인트를 호출하는 경우, `prefetch={false}`를 설정해야 한다.
  (미리 불러오면서 쿠키가 삭제되는 것을 방지하기 위해)

## **추가 정보**

### **1. Draft Mode 쿠키는 `next build` 때마다 변경됨**

- `next build`를 실행할 때마다 **새로운 우회 쿠키(bypass cookie) 값이 생성된다.**
- 이렇게 하면 기존 쿠키 값을 예측하는 것을 방지할 수 있다.

### **2. 로컬 환경에서 HTTP로 테스트할 경우**

- 브라우저에서 **서드파티 쿠키 및 로컬 스토리지 접근을 허용**해야 한다.

---

<aside>
🌟

**ISR(revalidate)와 Draft Mode의 차이점이 뭐지?**

### **✅ `revalidate`(ISR)와 `Draft Mode`(초안 모드)의 차이점**

**"Draft Mode 없이 `revalidate`를 사용해서 ISR을 걸면 되는 거 아닌가?"** 🤔

➡️ **비슷한 기능이지만, 핵심적인 차이점이 있다!**

---

## **📌 `revalidate` (ISR, Incremental Static Regeneration)**

ISR(점진적 정적 재생성)은 **정적 페이지를 일정 시간마다 다시 생성**하는 방식이다.

✅ `revalidate`를 사용하면 **Next.js가 특정 시간마다 최신 데이터를 가져오도록 설정 가능**

✅ `revalidate` 값이 10초라면, 페이지 요청 시 **최대 10초까지는 기존 정적 페이지를 유지**

✅ 새로운 요청이 들어올 때마다 데이터를 다시 가져와 **정적 페이지를 업데이트**

```tsx
export async function getStaticProps() {
  const res = await fetch("https://api.example.com/data");
  const data = await res.json();

  return {
    props: { data },
    revalidate: 10, // 10초마다 페이지를 재생성
  };
}
```

➡ **즉, ISR을 사용하면 정적 페이지를 유지하면서도 일정 주기마다 최신 데이터를 반영할 수 있다.**

---

## **📌 `Draft Mode` (초안 모드)**

Draft Mode는 **게시되지 않은 초안을 즉시 확인하기 위한 기능**이다.

✅ ISR과 다르게 **정적 페이지를 즉시 무시하고, 요청 시점마다 데이터를 가져온다.**

✅ `revalidate`(ISR)는 일정 시간이 지나야 새 데이터가 반영되지만, **Draft Mode는 즉시 반영됨.**

✅ 헤드리스 CMS에서 **게시(Publish)**하지 않아도 초안을 미리볼 수 있음.

```tsx
tsx;
복사;
import { draftMode } from "next/headers";

async function getData() {
  const { isEnabled } = draftMode();

  const url = isEnabled
    ? "https://api.example.com/draft" // Draft Mode 활성화 시 초안 데이터 가져오기
    : "https://api.example.com/live"; // 일반 사용자에게는 게시된 데이터 제공

  const res = await fetch(url);
  return res.json();
}
```

➡ **즉, Draft Mode를 사용하면 "실시간 초안 미리보기"가 가능하다.**

---

## **📌 `revalidate`(ISR) vs. `Draft Mode`(초안 모드) 비교**

| **기능**                    | **ISR (`revalidate`)**                | **Draft Mode**                              |
| --------------------------- | ------------------------------------- | ------------------------------------------- |
| **사용 목적**               | 일정 주기로 정적 페이지 재생성        | 헤드리스 CMS 초안 미리보기                  |
| **데이터 갱신 시점**        | `revalidate` 시간이 지나면 갱신       | 초안 모드 활성화 시 즉시 갱신               |
| **게시 전 초안 확인 가능?** | ❌ 불가능 (항상 게시된 데이터만 표시) | ✅ 가능 (초안 데이터 즉시 반영)             |
| **정적 페이지 유지?**       | ✅ 유지                               | ❌ 유지하지 않음 (요청마다 동적 렌더링)     |
| **사용 대상**               | 모든 방문자에게 최신 데이터 제공      | 관리자/에디터가 초안 확인                   |
| **성능 최적화**             | ✅ 캐시 활용 (서버 부하 낮음)         | ❌ 매 요청마다 데이터 요청 (서버 부하 높음) |

---

## **📌 결론: 어떤 경우에 `revalidate` vs. `Draft Mode`를 써야 할까?**

| **사용 사례**          | **ISR (`revalidate`) 사용**  | **Draft Mode 사용**               |
| ---------------------- | ---------------------------- | --------------------------------- |
| 📰 **뉴스 사이트**     | 10~60초 단위로 뉴스 업데이트 | 새 기사 초안을 미리보기           |
| 🛍 **이커머스 사이트**  | 재고 데이터, 할인 정보 반영  | 관리자만 비공개 상품을 미리보기   |
| 📚 **블로그 사이트**   | 새 글이 게시되면 업데이트    | 초안을 저장하고 확인              |
| 📢 **공지사항 페이지** | 일정 주기로 공지 내용 변경   | 관리자가 새로운 공지 작성 후 확인 |

✅ **ISR (`revalidate`)는 일반 사용자에게 최신 데이터를 제공할 때 적합**

✅ **Draft Mode는 CMS에서 작성 중인 초안을 확인할 때 필수적**

💡 **한마디로, `ISR`은 "시간이 지나면 자동으로 데이터 업데이트",
Draft Mode는 "게시 전에 초안을 즉시 미리보기" 기능을 제공한다!**

</aside>

# Content Security Policy (CSP)

CSP는 교차 사이트 스크립팅(XSS), 클릭재킹, 그리고 기타 코드 주입 공격과 같은 다양한 보안 위협으로부터 Next.js 애플리케이션을 보호하는 데 중요하다.

개발자는 CSP를 사용하여 콘텐츠 소스, 스크립트, 스타일 시트, 이미지, 폰트, 객체, 미디이(오디오, 비디오), inframe 등과 관련된 출처(origin)를 명시적으로 허용할 수 있다.

## Nonces

Nonce는 한 번만 사용하기 위해 생성된 고유하고 무작위의 문자열이다.

이는 CSP와 함께 사용되어 특정 인라인 스크립트나 스타일이 실행되도록 선택적으로 허용하며, 엄격한 CSP 지시 사항을 우회할 수 있게 해준다.

### 왜 nonce를 사용해야 하는가?

비록 CSP가 악의적인 스크립트를 차단하도록 설계되었더라도, 인라인 스크립트가 필요한 정당한 상황이 존재한다.

이러한 경우, nonce를 사용하면 올바른 nonce 값을 가진 인라인 스크립트만 실행되도록 하여 필요한 경우에 한해 인라인 스크립트의 실행을 허용할 수 있다.

## Nonce 추가하기 (Middleware 사용)

Middleware를 사용하면 페이지가 렌더링되기 전에 헤더를 추가하고 nonce를 생성할 수 있다.

페이지가 볼 때마다 새로운 Nonce가 생성되어야 한다.

즉, nonce를 추가하려면 동적 렌더링을 사용해야 한다.

### middleware.ts

```jsx
import { NextRequest, NextResponse } from "next/server";

export function middleware(request: NextRequest) {
  const nonce = Buffer.from(crypto.randomUUID()).toString("base64");
  const cspHeader = `
    default-src 'self';
    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';
    style-src 'self' 'nonce-${nonce}';
    img-src 'self' blob: data:;
    font-src 'self';
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    upgrade-insecure-requests;
`;
  // 줄바꿈 문자와 공백을 교체합니다.
  const contentSecurityPolicyHeaderValue = cspHeader
    .replace(/\s{2,}/g, " ")
    .trim();

  const requestHeaders = new Headers(request.headers);
  requestHeaders.set("x-nonce", nonce);

  requestHeaders.set(
    "Content-Security-Policy",
    contentSecurityPolicyHeaderValue
  );

  const response = NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  });
  response.headers.set(
    "Content-Security-Policy",
    contentSecurityPolicyHeaderValue
  );

  return response;
}
```

## Middleware 경로 매칭 설정

기본적으로 Middleware는 모든 요청에 대해 실행된다.

매처(matcher)를 사용하여 특정 경로에서만 Middleware가 실행되도록 필터링할 수 있다.

Next.js는 prefetch(next/link로부터의)요청과 CSP 헤더가 필요없는 정적 자산들을 무시할 것을 권장한다.

### middleware.ts

```jsx
export const config = {
  matcher: [
    /*
     * 다음으로 시작하지 않는 모든 요청 경로와 매칭:
     * - api (API 라우트)
     * - _next/static (정적 파일)
     * - _next/image (이미지 최적화 파일)
     * - favicon.ico (파비콘 파일)
     */
    {
      source: "/((?!api|_next/static|_next/image|favicon.ico).*)",
      /*
       * 헤더가 prefetch인 경우도 제외한다.
       */
      missing: [
        { type: "header", key: "next-router-prefetch" },
        { type: "header", key: "purpose", value: "prefetch" },
      ],
    },
  ],
};
```

## Nonce 읽기

이제 Server Component에서 headers를 사용하여 nonce를 읽을 수 있다.

```jsx
// app/page.tsx

import { headers } from "next/headers";
import Script from "next/script";

export default function Page() {
  const nonce = headers().get("x-nonce");

  return (
    <Script
      src="https://www.googletagmanager.com/gtag/js"
      strategy="afterInteractive"
      nonce={nonce}
    />
  );
}
```

## Nonce를 사용하지 않는 경우

Nonce가 필요 없는 애플리케이션의 경우, next.config.js 파일에서 직접 CSP 헤더를 설정할 수 있다.

```jsx
const cspHeader = `
    default-src 'self';
    script-src 'self' 'unsafe-eval' 'unsafe-inline';
    style-src 'self' 'unsafe-inline';
    img-src 'self' blob: data:;
    font-src 'self';
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    upgrade-insecure-requests;
`;

module.exports = {
  async headers() {
    return [
      {
        source: "/(.*)",
        headers: [
          {
            key: "Content-Security-Policy",
            value: cspHeader.replace(/\n/g, ""),
          },
        ],
      },
    ];
  },
};
```

—> 즉, middleware를 사용하지 않을 경우 next.config.js에서 직접 CSP 헤더를 설정할 수 있다는 의미.

고정된 CSP 헤더를 설정하고 모든 요청에 적용.

보안이 중요한 경우 Nonce 방식이 더 안전함.

정적 사이트나 간단한 프로젝트에서는 next.config.js 방식이 편리함.

# Vitest

Vite의 React Testing Library는 Unit Testing를 수행할 때 자주 함께 사용된다.

### 알아두면 좋은 점

- 비동기 Server Components(Async Server Components)는 React 생태계에서 새로운 개념이기 때문에, 현재 Vitest에서 지원하지 않는다.
- 하지만 동기(Server & Client Components) 컴포넌트의 유닛 테스트는 실행할 수 있다.
- 비동기 컴포넌트는 E2E(End-to-End) 테스트를 수행하는 것이 더 적절하다.

다음 명령어를 사용하여 Next.js + Vitest 예제 프로젝트를 빠르게 생성할 수 있다.

```jsx
npx create-next-app@latest --example with-vitest with-vitest-app
```

Vitest를 직접 설정하려면, 필요한패키지를 개발 의존성(dev dependencies)으로 설치해야 한다.

```jsx
npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react
# 또는
yarn add -D vitest @vitejs/plugin-react jsdom @testing-library/react
# 또는
pnpm install -D vitest @vitejs/plugin-react jsdom @testing-library/react
# 또는
bun add -D vitest @vitejs/plugin-react jsdom @testing-library/react
```

`vitest.config.ts` 설정 파일 생성

프로젝트 루트에 `vitest.config.ts` 파일을 생성하고, 다음 내용을 추가한다.

```jsx
import { defineConfig } from "vitest/config";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  test: {
    environment: "jsdom", // 브라우저 환경에서 테스트 실행
  },
});
```

`environment: 'jsdom'` → 테스트 실행 시 브라우저 환경을 시뮬레이션하도록 설정

`package.json` 에 테스트 스크립트 추가

`package.json` 파일의 `scripts` 섹션에 `"test"` 스크립트를 추가한다.

```jsx
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "test": "vitest"
  }
}
```

## 첫 번째 Vitest 유닛 테스트 작성하기

### 1. 테스트할 페이지 컴포넌트 (app/page.tsx)

```jsx
import Link from "next/link";

export default function Page() {
  return (
    <div>
      <h1>Home</h1>
      <Link href="/about">About</Link>
    </div>
  );
}
```

### 2. 유닛 테스트 파일 생성(**tests**/page.test.tsx)

테스트를 실행할 파일을 `__tests__/page.test.tsx` 에 생성하고, 다음과 같이 작성한다.

```jsx
import { expect, test } from "vitest";
import { render, screen } from "@testing-library/react";
import Page from "../app/page";

test("Page", () => {
  render(<Page />);
  expect(screen.getByRole("heading", { level: 1, name: "Home" })).toBeDefined();
});
```

✅ `render(<Page />)`: 페이지 컴포넌트를 가상 DOM에 렌더링

✅ `screen.getByRole('heading', { level: 1, name: 'Home' })`: `<h1>` 태그가 존재하는지 확인

✅ `expect(...).toBeDefined()`: 해당 요소가 존재하는지 테스트

### 3. 스크립트 명령어로 테스트 실행하기

- 위 예제에서는 테스트 파일을 `__tests__` 폴더에 저장하는 **일반적인 방식**을 사용했다.
- 하지만 **Next.js App Router (`app/` 폴더 구조)를 사용할 경우, 테스트 파일을 컴포넌트와 같은 위치에 저장할 수도 있다.**
- 예를 들어, `app/page.test.tsx`처럼 같은 폴더 안에 테스트 파일을 두는 것도 가능하다.

# Jest

Jest와 React Testing Library는 유닛 테스트와 스냅샷 테스트(Unit Testing & Snapshot Testing)를 수행할 때 자주 함께 사용된다.

- **비동기 Server Components(Async Server Components)는 React 생태계에서 새로운 개념이기 때문에, 현재 Jest에서 지원하지 않는다.**
- 하지만 **동기(Server & Client Components) 컴포넌트의 유닛 테스트는 실행할 수 있다.**
- **비동기 컴포넌트는 E2E(End-to-End) 테스트를 수행하는 것이 더 적절하다.**

다음 명령어를 사용하여 Next.js + Jest 예제 프로젝트를 빠르게 생성할 수 있다.

```jsx
npx create-next-app@latest --example with-jest with-jest-app
```

### 1. 패키지 설치

Next.js12 부터 Jest에 대한 기본 설정이 내장되어 있으므로, 추가적인 설정 없이 사용할 수 있다.

터미널에서 다음 명령어를 실행한다.

```
npm install -D jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom
# 또는
yarn add -D jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom
# 또는
pnpm install -D jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom
```

✅ `jest`: Jest 테스트 러너

✅ `jest-environment-jsdom`: 브라우저 환경에서 테스트 실행

✅ `@testing-library/react`: React 컴포넌트 테스트를 위한 라이브러리

✅ `@testing-library/jest-dom`: Jest의 확장된 Matcher 제공 (`toBeInTheDocument` 등)

### 2. `jest.config.ts` 설정 파일 생성

터미널에서 다음 명령어를 실행하여 기본 Jest 설정 파일을 생성한다.

```jsx
npm init jest@latest
# 또는
yarn create jest@latest
# 또는
pnpm create jest@latest
```

이 명령을 실행하면 **여러 가지 설정 옵션을 묻는 프롬프트가 나타나며, `jest.config.ts` 또는 `jest.config.js` 파일이 자동으로 생성된다.**

이제 `jest.config.ts`를 수정하여 `next/jest`를 사용하도록 설정한다.

```tsx
import type { Config } from "jest";
import nextJest from "next/jest.js";

const createJestConfig = nextJest({
  // Next.js의 환경 설정(`next.config.js`, `.env` 파일 등)을 로드하기 위한 경로
  dir: "./",
});

// Jest 커스텀 설정 추가
const config: Config = {
  coverageProvider: "v8",
  testEnvironment: "jsdom", // 브라우저 환경에서 실행
  // setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'], // 추가 설정 파일 (옵션)
};

// Jest 설정을 내보내기 (비동기 Next.js 환경 설정을 로드하기 위해 필요)
export default createJestConfig(config);
```

✅ **`next/jest`는 Jest가 Next.js 환경에서 원활하게 실행될 수 있도록 자동으로 설정해준다.**

✅ `next/jest`는 다음과 같은 작업을 자동으로 수행한다.

- Next.js 컴파일러(Transform) 설정
- `.css`, `.module.css`, `.scss` 등의 스타일시트 모킹(Mock) 처리
- 이미지 및 `next/font` 관련 처리
- `.env` 파일(환경 변수) 로드
- `node_modules` 및 `.next` 디렉터리 무시
- `next.config.js`에서 SWC 관련 설정 자동 적용

## 모듈 경로 별칭 (Absolute Imports) 설정

만약 프로젝트에서 `@/components/*` 같은 경로 별칭을 사용한다면, Jest에서도 이를 해석할 수 있도록 설정해야 한다.

### **1️⃣ `tsconfig.json` 또는 `jsconfig.json` 설정**

```json
{
  "compilerOptions": {
    "module": "esnext",
    "moduleResolution": "bundler",
    "baseUrl": "./",
    "paths": {
      "@/components/*": ["components/*"]
    }
  }
}
```

### **2️⃣ `jest.config.js`에서 `moduleNameMapper` 추가**

```jsx
moduleNameMapper: {
  '^@/components/(.*)$': '<rootDir>/components/$1',
}
```

✅ 이렇게 설정하면 Jest가 `@/components/Button` 같은 모듈 경로를 `components/Button`으로 해석할 수 있습니다.

## **Jest의 확장 Matcher 추가**

`@testing-library/jest-dom` 라이브러리는 `.toBeInTheDocument()` 같은 **추가 Matcher 기능**을 제공한다.

이를 모든 테스트에서 사용하려면 `jest.config.ts`에 다음 설정을 추가해야한다.

```tsx
setupFilesAfterEnv: ["<rootDir>/jest.setup.ts"];
```

### **`jest.setup.ts` 파일 생성**

```tsx
import "@testing-library/jest-dom";
```

✅ 이렇게 하면 **모든 테스트에서 `@testing-library/jest-dom`의 확장 Matcher를 자동으로 사용할 수 있다.**

## **`package.json`에 Jest 실행 스크립트 추가**

`package.json` 파일의 `scripts` 섹션에 `"test"` 스크립트를 추가한다.

```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "test": "jest",
    "test:watch": "jest --watch"
  }
}
```

✅ `jest --watch`를 실행하면 **파일이 변경될 때마다 자동으로 테스트를 다시 실행한다.**

## **첫 번째 테스트 작성하기**

### **1. `app/page.tsx` (테스트할 페이지 컴포넌트)**

```tsx
import Link from "next/link";

export default function Home() {
  return (
    <div>
      <h1>Home</h1>
      <Link href="/about">About</Link>
    </div>
  );
}
```

---

### **2. 유닛 테스트 작성 (`__tests__/page.test.jsx`)**

```tsx
import "@testing-library/jest-dom";
import { render, screen } from "@testing-library/react";
import Page from "../app/page";

describe("Page", () => {
  it("renders a heading", () => {
    render(<Page />);

    const heading = screen.getByRole("heading", { level: 1 });

    expect(heading).toBeInTheDocument();
  });
});
```

✅ `screen.getByRole('heading', { level: 1 })` → `<h1>` 요소 찾기

✅ `expect(heading).toBeInTheDocument()` → 요소가 존재하는지 확인

### **3️⃣ 스냅샷 테스트 작성 (`__tests__/snapshot.js`)**

```tsx
import { render } from "@testing-library/react";
import Page from "../app/page";

it("renders homepage unchanged", () => {
  const { container } = render(<Page />);
  expect(container).toMatchSnapshot();
});
```

스냅샷 테스트는 **컴포넌트 UI가 변경되지 않았는지 확인하는 용도로 사용된다.**

## **테스트 실행**

터미널에서 다음 명령어를 실행하여 테스트를 실행한다.

```
npm run test
# 또는
yarn test
# 또는
pnpm test

```

# Playwirght

Playwright는 Chromium, Firefox, WebKit 브라우저 자동화를 지원하는 테스트 프레임워크로, 이를 활용하면 End-to-End (E2E) 테스트를 수행할 수 있다.

**빠른 시작 (Quickstart)**

Playwright가 설정된 Next.js 예제 프로젝트를 생성하는 방법은 다음과 같다.

```
npx create-next-app@latest --example with-playwright with-playwright-app
```

이 명령어를 실행하면 Next.js 프로젝트가 생성되며 Playwright도 자동으로 설정된다.

**수동으로 Playwright 설정하기 (Manual Setup)**

Playwright를 직접 설정하려면 다음 명령어를 실행한다.

```
npm init playwright
# 또는
yarn create playwright
# 또는
pnpm create playwright

```

이 명령어를 실행하면 Playwright 설정 마법사가 실행되며 프로젝트에 필요한 파일이 자동으로 생성된다.

실행 후 `playwright.config.ts` 파일이 추가된다

## **첫 번째 Playwright E2E 테스트 작성하기**

### **1. 테스트할 Next.js 페이지 만들기**

다음과 같이 두 개의 페이지를 만든다.

`app/page.tsx`

```tsx
import Link from "next/link";

export default function Page() {
  return (
    <div>
      <h1>Home</h1>
      <Link href="/about">About</Link>
    </div>
  );
}
```

`app/about/page.tsx`

```tsx
import Link from "next/link";

export default function Page() {
  return (
    <div>
      <h1>About</h1>
      <Link href="/">Home</Link>
    </div>
  );
}
```

홈페이지와 About 페이지를 만들고, 페이지 이동을 위한 링크를 추가한다.

### **2. E2E 테스트 작성 (`tests/example.spec.ts`)**

홈페이지에서 "About" 링크를 클릭하면 About 페이지로 이동하는지 확인하는 테스트를 작성한다.

`tests/example.spec.ts`

```tsx
import { test, expect } from "@playwright/test";

test("should navigate to the about page", async ({ page }) => {
  await page.goto("http://localhost:3000/");
  await page.click("text=About");
  await expect(page).toHaveURL("http://localhost:3000/about");
  await expect(page.locator("h1")).toContainText("About");
});
```

홈페이지로 이동한 후 "About" 링크를 클릭하면 `/about` 페이지로 이동해야 하고,

그 페이지에는 `<h1>` 태그가 포함되어 있어야 한다.

## **테스트 실행하기**

Playwright는 크로미움(Chrome), 파이어폭스(Firefox), WebKit(Safari)을 사용하여 실제 사용자가 애플리케이션을 탐색하는 것을 시뮬레이션한다.

테스트 실행 전에 Next.js 서버가 실행 중이어야 한다.

### **1. Next.js 빌드 및 실행**

```
npm run build
npm run start
```

Next.js 애플리케이션을 프로덕션 모드에서 실행한다.

### **2. Playwright 테스트 실행**

```
npx playwright test
```

Playwright가 크로미움(Chrome), 파이어폭스(Firefox), WebKit(Safari)에서 테스트를 실행한다.

모든 테스트가 성공하면 통과 메시지가 출력되며, 실패하면 어떤 단계에서 오류가 발생했는지 확인할 수 있다.

## **`baseURL` 설정을 활용하여 코드 단순화**

Playwright 설정 파일에서 `baseURL`을 지정하면 `page.goto("http://localhost:3000/")` 대신 `page.goto("/")`처럼 사용할 수 있다.

`playwright.config.ts`

```tsx
import { defineConfig } from "@playwright/test";

export default defineConfig({
  webServer: {
    command: "npm run dev",
    port: 3000,
  },
  use: {
    baseURL: "http://localhost:3000",
  },
});
```

`tests/example.spec.ts`

```tsx
test("should navigate to the about page", async ({ page }) => {
  await page.goto("/");
  await page.click("text=About");
  await expect(page).toHaveURL("/about");
  await expect(page.locator("h1")).toContainText("About");
});
```

테스트 코드가 더 간결해진다.

## **CI/CD에서 Playwright 실행하기**

Playwright는 기본적으로 헤드리스(Headless) 모드에서 실행되므로 CI/CD 환경에서 자동화 테스트에 적합하다.

CI/CD 환경에서 Playwright를 실행하려면 Playwright의 필수 의존성을 설치해야 한다.

### **1. Playwright 의존성 설치**

```
npx playwright install-deps
```

CI 환경에서도 Playwright가 정상적으로 동작하도록 모든 브라우저 의존성을 설치한다.

### **2. GitHub Actions 또는 CI/CD 파이프라인 설정**

Playwright를 CI/CD 파이프라인에서 실행하는 방법은 공식 문서를 참고하면 된다.
